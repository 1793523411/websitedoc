## 知道有哪些可能引起前端安全的问题

前端应用中常遇到的安全问题：

+ 跨站脚本xss
+ 跨站请求伪造 csrf
+ 网络劫持攻击
+ iframe滥用
+ 恶意第三方库


## 什么是 XSS 范 攻击？如何防范 XSS 攻击

XSS 攻击指的是**跨站脚本攻击**，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而**盗取用户的信息如 cookie 等**。

XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

XSS 一般分为**存储型、反射型和 DOM 型**。

存储型指的是**恶意代码提交到了网站的数据库中**，当用户请求数据的时候，服务器将其拼接为HTML 后返回给了用户，从而导致了恶意代码的执行。

反射型指的是攻击者**构建了特殊的 URL**，当服务器接收到请求后，从 URL 中获取数据，拼接到HTML 后返回，从而导致了恶意代码的执行。

```js
<!--比如--> 
http://www.test.com/search.php?key="><script>alert("XSS")</script> 
```

DOM 型指的是攻击者**构建了特殊的 URL**，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。较上面两种，DOM型取出和执行恶意代码都由浏览器端完成，属于前端自身安全漏洞

XSS 攻击的预防可以从两个方面入手，一个是**恶意代码提交**的时候，一个是**浏览器执行恶意代码**的时候。

对于第一个方面，如果我们对存入数据库的数据都进行的**转义**处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。

对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。

还有一些方式，比如使用 CSP ，**CSP 的本质是建立一个白名单**，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

## XSS

### XSS 是什么

XSS 是一种经常出现在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。<br>
比如这些代码包括 HTML 代码和客户端脚本。攻击者利用 XSS 漏洞旁路掉访问控制——例如同源策略(same origin policy)。<br>
这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。<br>
对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而 JavaScript 是新型的“ShellCode”。

```
示例：
<script>alert(document.cookie)</script>
```

### 特点

能注入恶意的 HTML/JavaScript 代码到用户浏览的网页上，从而达到 Cookie 资料窃取、会话劫持、钓鱼欺骗等攻击。
<攻击代码不一定（非要）在` <script></script>` 中>

### 原因

- Web 浏览器本身的设计不安全。浏览器能解析和执行 JS 等代码，但是不会判断该数据和程序代码是否恶意。
- 输入和输出是 Web 应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现 XSS 漏洞。
- 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。
- XSS 攻击手段灵活多变。

### 危害

- 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
- 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
- 盗窃企业重要的具有商业价值的资料
- 非法转账
- 强制发送电子邮件
- 网站挂马
- 控制受害者机器向其它网站发起攻击

### 如何防范

- 将重要的 cookie 标记为 http only, 这样的话 Javascript 中的 document.cookie 语句就不能获取到 cookie 了.
- 表单数据规定值的类型，例如：年龄应为只能为 int、name 只能为字母数字组合。。。。
- 对数据进行 Html Encode 处理
- 过滤或移除特殊的 Html 标签， 例如: `<script>`, `<iframe>` , `&lt`; for <, `&gt`; for >, &quot for
- 过滤 JavaScript 事件的标签。例如 "onclick=", "onfocus" 等等。


## 预防XSS

xss攻击有两大要素：攻击者提交恶意代码，浏览器执行恶意代码

+ 针对cookie劫持，攻击者向漏洞页面写入恶意代码获取cookie，可以通过防止cookie会话劫持来防范，一般要在设置cookie时加HttpOnly，来禁止意外注入站点的恶意js代码操作Cookie造成xss攻击

```js
// node设置httponly 
'Set-Cookie' : 'SSID=EqAc1D; Expires=Wed; HttpOnly' 
```

+ 提高攻击门槛：(XSS Filter)针对用户提交的数据进行有效的验证，只接受我们规定的长
度或内容的提交，过滤掉其他的输入内容 或者 将特殊字符输出编码(xss Escape)

![](../../.vuepress/public/Xss.png)

+ xss漏洞检测poc：通过漏洞检测代码，完成自测，最小化被攻击风险

```html
<!--比如img图片标记属性跨站攻击代码--> 
<img src="javascript:alert(/xss/)"></img><img dynsrc="javascript:alert('xss')"></img> 
<!--无需 “<>”，利用 html 标记事件属性跨站--> 
<img src="" onerror=alert("xss")> 
```

## 什么是 CSP

CSP 指的是**内容安全策略**，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是**设置 HTTP 首部中的 Content-Security-Policy**，一种是**设置 meta 标签的方式 `<meta http-equiv="Content-Security-Policy">`**

## 什么是 CSRF 范 攻击？如何防范 CSRF 攻击？

CSRF 攻击指的是**跨站请求伪造攻击**，攻击者**诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求**。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的**本质是利用了 cookie 会在同源请求中携带发送给服务器的特点**，以此来实现用户的冒充。

一般的 CSRF 攻击类型有三种：

第一种是 **GET 类型的 CSRF 攻击**，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。

第二种是**POST 类型的 CSRF 攻击**，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。

第三种是**链接类型的 CSRF 攻击**，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

CSRF 可以用下面几种方法来防护：

第一种是**同源检测**的方法，服务器**根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点**，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。

第二种方法是**使用 CSRF Token 来进行验证**，服务器向用户**返回一个随机数 Token**，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。

第三种方式使用**双重 Cookie 验证**的办法，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。

第四种方式是使用**在设置 cookie 属性的时候设置 Samesite** ，**限制 cookie 不能作为被第三方使用**，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

总结：

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站执⾏某项操作的⽬的，常规的过程如下：

1. 用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器
3. 未退出网站A之前，在同一浏览器中，攻击者引诱用户进入网站B
4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A根据用户的Cookie信息以及用户的权限处理该请求，导致来自网站B的恶意代码被执行

CSRF通常从第三⽅⽹站发起，被攻击的⽹站⽆法防⽌攻击发⽣，只能通过增强⾃⼰⽹站针对CSRF的防护能⼒来提升安全性

CSRF有两个特点：

+ 通常发生在第三方域名
+ 攻击者不能获取到cookie等信息，只是使用

针对这两点，我们可以制定专门的防护策略：

+ 阻止不明外域的访问
  + 同源检测
  + Samesite Cookie
+ 提交时要求附加文本域验证身份才可以获取信息
  + CSRF Token
  + 双重cookie验证

## XSS 与 CSRF 有什么区别吗


XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：

- 登录受信任网站 A，并在本地生成 Cookie。
- 在不登出 A 的情况下，访问危险网站 B。

## 同源检测

通过使用Orgin Header确定来源域名：在部分与CSRF有关的请求中，请求的Header中会携带Origin字段,如果Origin存在，那么直接使⽤Origin中的字段确认来源域名就可以使用Referer Header确定域名来源：根据HTTP协议，HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址

## 什么是 Samesite Cookie 属性

Google起草了⼀份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性

Samesite Cookie 表示**同站 cookie**，避免 cookie 被第三方所利用。**将 Samesite 设为 strict ，这种称为严格模式**，表示这个 cookie 在任何情况下都不可能作为第三方 cookie**将 Samesite 设为 Lax ，这种模式称为宽松模式**，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它**不支持子域**，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。

## CSRF Token

通过csrf token验证请求的身份，是够携带正确的token，来区分正常的请求和攻击的请求

CSRF Token的防护策略分为三个步骤：

+ 将CSRF Token输出到⻚⾯中
+ ⻚⾯提交的请求携带这个Token
+ 服务器验证Token是否

## 双重cookie验证

利⽤CSRF攻击不能获取到⽤户Cookie的特点，我们可以要求Ajax和表单请求携带⼀个Cookie中的值

双重Cookie采⽤以下流程：

+ 在⽤户访问⽹站⻚⾯时，向请求域名注⼊⼀个Cookie，内容为随机字符串
+ 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中
+ 后端接⼝验证Cookie中的字段与URL参数中的字段是否⼀致，不⼀致则拒

## 什么是点击劫持？如何防范点击劫持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以**在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击**。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。

## 网络劫持有哪几种

网络劫持一般分为两种：HTTP劫持和DNS劫持

DNS劫持：

+ DNS强制解析：通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
+ 302跳转的⽅式：通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起跳转的回复，引导⽤户获取内容

HTTP劫持: 由于http明⽂传输，运营商会修改你的http响应内容(即加⼴告)DNS劫持由于涉嫌违法,已经被监管；针对HTTP劫持，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容

## 中间人攻击的了解

中间人(Man-in-the-middle attack, MITM)是指攻击者和通讯的两端分别创建独立的联系，并交换其得到的数据，攻击者可以拦截通信双方的通话并插入新的内容

一般的过程如下:

+ 客户端发送请求到服务端，请求被中间⼈截获
+ 服务器向客户端发送公钥
+ 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个【伪造的】公钥，发给客户端
+ 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
+ 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
+ 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端

## SQL 注入攻击

SQL 注入攻击指的是攻击者在 HTTP 请求中注入**恶意的 SQL 代码**，服务器使用参数构建数据库SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。

## sql 注入原理

就是通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

总的来说有以下几点：

1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。

2. 永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。

3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。

4. 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息。

## 介绍下前端加密的常见场景和方法

首先，加密的目的，简而言之就是将明文转换为密文、甚至转换为其他的东西，用来隐藏明文内容本身，防止其他人直接获取到敏感明文信息、或者提高其他人获取到明文信息的难度。通常我们提到加密会想到密码加密、HTTPS 等关键词，这里从场景和方法分别提一些我的个人见解

### 场景- 密码传输

前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。这种加密其实相对比较简单，可以使用 PlanA-前端加密、后端解密后计算密码字符串的 MD5/MD6 存入数据库；也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行 MD5/MD6，全程密码明文不出现在程序中。

PlanA 使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的MD5/MD6 。

PlanB 直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 

### 场景- 数据包加密
应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如X 通的流量浮层，X 信的插入式广告……（我没有针对谁）但是这几年，我们会发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。被人插入这种广告的方法其实很好理解：你的网页数据包被抓取->在数据包到达你手机之前被篡改->你得到了带网页广告的数据包->渲染到你手机屏幕。而 HTTPS 进行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。Plan 全面采用 HTTPS 

### 场景

经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开……比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容也很容易被爬取。

Plan 将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变成“乱码”。举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成这样：

图形：1 2 3 4 5 字码：2 3 1 5 4

这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。

这种手段也可以算作一种加密。