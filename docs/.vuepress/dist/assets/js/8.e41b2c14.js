(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{723:function(v,_,t){v.exports=t.p+"assets/img/01.dedd9a78.png"},769:function(v,_,t){"use strict";t.r(_);var r=t(103),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h2",{attrs:{id:"对浏览器的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对浏览器的理解"}},[v._v("#")]),v._v(" 对浏览器的理解")]),v._v(" "),r("p",[v._v("浏览器的"),r("strong",[v._v("主要功能")]),v._v("是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。"),r("strong",[v._v("简单来说浏览器可以分为两部分，shell 和 内核")]),v._v("。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。")]),v._v(" "),r("h2",{attrs:{id:"对浏览器内核的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对浏览器内核的理解"}},[v._v("#")]),v._v(" 对浏览器内核的理解")]),v._v(" "),r("p",[v._v("主要分成两部分："),r("strong",[v._v("渲染引擎和 JS 引擎")]),v._v("。")]),v._v(" "),r("p",[v._v("渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。")]),v._v(" "),r("p",[v._v("JS 引擎：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，"),r("strong",[v._v("后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。")])]),v._v(" "),r("h2",{attrs:{id:"常见的浏览器内核比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见的浏览器内核比较"}},[v._v("#")]),v._v(" 常见的浏览器内核比较")]),v._v(" "),r("p",[r("strong",[v._v("Trident：这种浏览器内核是 IE 浏览器用的内核")]),v._v("，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。")]),v._v(" "),r("p",[r("strong",[v._v("Gecko：这是 Firefox 和 Flock 所采用的内核")]),v._v("，这个内核的优点就是"),r("strong",[v._v("功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口")]),v._v("，但是代价是也显而易见就是要"),r("strong",[v._v("消耗很多的资源，比如内存")])]),v._v(" "),r("p",[r("strong",[v._v("Presto：Opera 曾经采用的就是 Presto 内核")]),v._v("，Presto 内核被称为公认的浏览网页"),r("strong",[v._v("速度最快的内核")]),v._v("，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会"),r("strong",[v._v("比其他的内核快 3 倍左右")]),v._v("，缺点就是为了达到很快的速度而"),r("strong",[v._v("丢掉了一部分网页兼容性")])]),v._v(" "),r("p",[r("strong",[v._v("Webkit：Webkit 是 Safari 采用的内核")]),v._v("，它的优点就是"),r("strong",[v._v("网页浏览速度较快")]),v._v("，虽然"),r("strong",[v._v("不及 Presto 但是也胜于 Gecko 和 Trident")]),v._v("，缺点是对于网页代码的容错性不高，也就是说"),r("strong",[v._v("对网页代码的兼容性较低")]),v._v("，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 "),r("strong",[v._v("KHTML")]),v._v(" 的一个开源的分支")]),v._v(" "),r("p",[r("strong",[v._v("Blink")]),v._v("：谷歌在 Chromium Blog 上发表博客，称"),r("strong",[v._v("将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎")]),v._v("（即浏览器核心），内置于 Chrome 浏览器之中。其实 "),r("strong",[v._v("Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样")]),v._v("。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，"),r("strong",[v._v("Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink")])]),v._v(" "),r("h3",{attrs:{id:"常见浏览器所用内核"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见浏览器所用内核"}},[v._v("#")]),v._v(" 常见浏览器所用内核")]),v._v(" "),r("p",[v._v("（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；")]),v._v(" "),r("p",[v._v("（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；")]),v._v(" "),r("p",[v._v("（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；")]),v._v(" "),r("p",[v._v("（4） Safari 浏览器内核：Webkit 内核；")]),v._v(" "),r("p",[v._v("（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；")]),v._v(" "),r("p",[v._v("（6） 360 浏览器、猎豹浏览器内核：IE + Chrome 双内核；")]),v._v(" "),r("p",[v._v("（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；")]),v._v(" "),r("p",[v._v("（8） 百度浏览器、世界之窗内核：IE 内核；")]),v._v(" "),r("p",[v._v("（9） 2345 浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；")]),v._v(" "),r("p",[v._v("（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核")]),v._v(" "),r("h2",{attrs:{id:"浏览器的渲染原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染原理"}},[v._v("#")]),v._v(" 浏览器的渲染原理")]),v._v(" "),r("p",[v._v("（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，"),r("strong",[v._v("DOM 树")]),v._v("是由** DOM 元素及属性节点组成的**。")]),v._v(" "),r("p",[v._v("（2）然后对 CSS 进行解析，生成** CSSOM 规则树**。")]),v._v(" "),r("p",[v._v("（3）"),r("strong",[v._v("根据 DOM 树和 CSSOM 规则树构建渲染树")]),v._v("。渲染树的节点被称为"),r("strong",[v._v("渲染对象")]),v._v("，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。")]),v._v(" "),r("p",[v._v("（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以"),r("strong",[v._v("当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）")]),v._v("。这一阶段浏览器要做的事情是要"),r("strong",[v._v("弄清楚各个节点在页面中的确切位置和大小")]),v._v("。通常这一行为也被称为“自动重排”。")]),v._v(" "),r("p",[v._v("（5）"),r("strong",[v._v("布局阶段结束后是绘制阶段")]),v._v("，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是"),r("strong",[v._v("逐步完成的")]),v._v("，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容")]),v._v(" "),r("h2",{attrs:{id:"浏览器解析过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析过程"}},[v._v("#")]),v._v(" 浏览器解析过程")]),v._v(" "),r("h3",{attrs:{id:"渲染过程中遇到-js-文件怎么处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程中遇到-js-文件怎么处理"}},[v._v("#")]),v._v(" 渲染过程中遇到 JS 文件怎么处理？")]),v._v(" "),r("p",[v._v("JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，"),r("strong",[v._v("HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎")]),v._v("，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议"),r("strong",[v._v("将 script 标签放在 body 标签底部的原因")]),v._v("。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 "),r("strong",[v._v("defer")]),v._v(" 或者 "),r("strong",[v._v("async")]),v._v(" 属性")]),v._v(" "),r("h3",{attrs:{id:"async-和-和-defer-的作用是什么-有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async-和-和-defer-的作用是什么-有什么区别"}},[v._v("#")]),v._v(" async 和 和 defer 的作用是什么？有什么区别？")]),v._v(" "),r("p",[v._v("（1）脚本没有 defer 或 async，浏览器会"),r("strong",[v._v("立即加载并执行指定的脚本")]),v._v("，也就是说不等待后续载入的文档元素，读到就加载并执行。")]),v._v(" "),r("p",[v._v("（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是"),r("strong",[v._v("并行")]),v._v("的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。"),r("strong",[v._v("多个脚本按顺序执行")]),v._v("。")]),v._v(" "),r("p",[v._v("（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。"),r("strong",[v._v("多个脚本的执行顺序无法保证")]),v._v("。")]),v._v(" "),r("h3",{attrs:{id:"什么是文档的预解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是文档的预解析"}},[v._v("#")]),v._v(" 什么是文档的预解析")]),v._v(" "),r("p",[v._v("Webkit 和 Firefox 都做了这个优化，"),r("strong",[v._v("当执行 JavaScript 脚本时，另一个线程解析剩下的文档")]),v._v("，并加载后面需要通过网络加载的资源。这种方式可以"),r("strong",[v._v("使资源并行加载从而使整体速度更快")]),v._v("。需要注意的是，"),r("strong",[v._v("预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片")])]),v._v(" "),r("h3",{attrs:{id:"css-如何阻塞文档解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-如何阻塞文档解析"}},[v._v("#")]),v._v(" CSS 如何阻塞文档解析")]),v._v(" "),r("p",[v._v("理论上，既然"),r("strong",[v._v("样式表不改变 DOM 树")]),v._v("，也就没有必要停下文档的解析等待它们，然而，存在一个问题，"),r("strong",[v._v("JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值")]),v._v("，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么"),r("strong",[v._v("浏览器将延迟 JavaScript 脚本执行和文档的解析")]),v._v("，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，"),r("strong",[v._v("浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析")]),v._v("。")]),v._v(" "),r("h2",{attrs:{id:"浏览器渲染过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染过程"}},[v._v("#")]),v._v(" 浏览器渲染过程")]),v._v(" "),r("h3",{attrs:{id:"渲染页面时常见哪些不良现象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染页面时常见哪些不良现象"}},[v._v("#")]),v._v(" 渲染页面时常见哪些不良现象")]),v._v(" "),r("p",[v._v("FOUC：主要指的是"),r("strong",[v._v("样式闪烁")]),v._v("的问题，由于浏览器渲染机制（比如 firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。"),r("strong",[v._v("白屏")]),v._v("：有些浏览器渲染机制（比如 chrome）要"),r("strong",[v._v("先构建 DOM 树和 CSSOM 树")]),v._v("，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 "),r("strong",[v._v("js 文件放在头部")]),v._v("，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题")]),v._v(" "),r("h3",{attrs:{id:"如何优化关键渲染路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何优化关键渲染路径"}},[v._v("#")]),v._v(" 如何优化关键渲染路径")]),v._v(" "),r("p",[v._v("为尽快完成"),r("strong",[v._v("首次渲染")]),v._v("，我们需要最大限度减小以下三种可变因素：")]),v._v(" "),r("p",[v._v("（1）关键"),r("strong",[v._v("资源的数量")]),v._v("。\n（2）关键路径"),r("strong",[v._v("长度")]),v._v("。\n（3）关键"),r("strong",[v._v("字节的数量")]),v._v("。")]),v._v(" "),r("p",[r("strong",[v._v("关键资源")]),v._v("是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少,同样，关"),r("strong",[v._v("键路径长度")]),v._v("受所有关键资源与其"),r("strong",[v._v("字节大小")]),v._v("之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要"),r("strong",[v._v("压缩和优化各项资源，确保最大限度减小传送大小")])]),v._v(" "),r("p",[v._v("优化关键渲染路径的"),r("strong",[v._v("常规步骤")]),v._v("如下：")]),v._v(" "),r("p",[v._v("（1）对关键路径"),r("strong",[v._v("进行分析和特性描述")]),v._v("：资源数、字节数、长度。")]),v._v(" "),r("p",[v._v("（2）最大限度减少关键资源的"),r("strong",[v._v("数量")]),v._v("：删除它们，延迟它们的下载，将它们标记为异步等。")]),v._v(" "),r("p",[v._v("（3）优化关键字节数以缩短下载时间（"),r("strong",[v._v("往返次数")]),v._v("）。")]),v._v(" "),r("p",[v._v("（4）优化其余关键资源的"),r("strong",[v._v("加载顺序")]),v._v("：您需要尽早下载所有关键资产，以缩短关键路径长度。")]),v._v(" "),r("h2",{attrs:{id:"浏览器绘制过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器绘制过程"}},[v._v("#")]),v._v(" 浏览器绘制过程")]),v._v(" "),r("h3",{attrs:{id:"什么是重绘和回流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘和回流"}},[v._v("#")]),v._v(" 什么是重绘和回流")]),v._v(" "),r("p",[v._v("重绘: "),r("strong",[v._v("当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background color，我们将这样的操作称为重绘")]),v._v("。")]),v._v(" "),r("p",[v._v("回流："),r("strong",[v._v("当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流")]),v._v("。")]),v._v(" "),r("p",[r("strong",[v._v("区别：")])]),v._v(" "),r("p",[v._v("回流指当前窗口发生改变，发生滚动操作，或者元素的位置大小相关属性被更新时会触发布局过程，发生在 render 树，比如元素的几何尺寸变化，就需要重新验证并计算 Render Tree")]),v._v(" "),r("p",[v._v("重绘指当前视觉样式属性被更新时触发的绘制过程，发生在渲染层 render layer 所以相比之下，回流的成本要比重绘高得多")]),v._v(" "),r("p",[v._v("常见引起回流属性和方法：")]),v._v(" "),r("p",[r("strong",[v._v("任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。")])]),v._v(" "),r("p",[v._v("（1）添加或者删除可见的 DOM 元素；")]),v._v(" "),r("p",[v._v("（2）元素尺寸改变——边距、填充、边框、宽度和高度")]),v._v(" "),r("p",[v._v("（3）内容变化，比如用户在 input 框中输入文字")]),v._v(" "),r("p",[v._v("（4）浏览器窗口尺寸改变——resize 事件发生时")]),v._v(" "),r("p",[v._v("（5）计算 offsetWidth 和 offsetHeight 属性")]),v._v(" "),r("p",[v._v("（6）设置 style 属性的值")]),v._v(" "),r("p",[v._v("（7）当你修改网页的默认字体时。")]),v._v(" "),r("p",[r("strong",[v._v("回流必定会发生重绘，重绘不一定会引发回流")]),v._v("。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流")]),v._v(" "),r("h3",{attrs:{id:"如何减少回流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何减少回流"}},[v._v("#")]),v._v(" 如何减少回流")]),v._v(" "),r("ul",[r("li",[v._v("使用 transform 替代 top")]),v._v(" "),r("li",[v._v("不要把节点的属性值放在一个循环里当成循环里的变量")]),v._v(" "),r("li",[v._v("不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局")]),v._v(" "),r("li",[v._v("把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM")]),v._v(" "),r("li",[v._v("在内存中多次操作节点，完成后在添加到文档中")]),v._v(" "),r("li",[v._v("不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className 或者 style.classText。")]),v._v(" "),r("li",[v._v("在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中")]),v._v(" "),r("li",[v._v("对元素进行一个复杂的操作，可以先隐藏它，操作完成后在显示")])]),v._v(" "),r("h3",{attrs:{id:"为什么操作-dom-慢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么操作-dom-慢"}},[v._v("#")]),v._v(" 为什么操作 DOM 慢")]),v._v(" "),r("p",[v._v("一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。")]),v._v(" "),r("h2",{attrs:{id:"浏览器渲染页面过程概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染页面过程概述"}},[v._v("#")]),v._v(" 浏览器渲染页面过程概述")]),v._v(" "),r("p",[v._v("大致过程：")]),v._v(" "),r("p",[r("strong",[v._v("HTML 解析构建 DOM->CSS 解析构建 CSSOM 树->根据 DOM 树和 CSSOM 树构建 render 树->根据 render 树进行布局渲染 render layer->根据计算的布局信息进行绘制")]),v._v(",不同浏览器的内核不同，所以渲染过程其中有部分细节有不一样，以 webkit 主流程为例")]),v._v(" "),r("p",[r("img",{attrs:{src:t(723),alt:"浏览器渲染原理"}})]),v._v(" "),r("p",[v._v("浏览器解析渲染页面过程是一个复杂的过程，其中有不少的细节和规则，所以这里只能总结大致过程")]),v._v(" "),r("p",[v._v("较详细过程：")]),v._v(" "),r("p",[v._v("HTML 解析构建 DOM 树：其中 HTML Parser 就起到了将 HTML 标记解析成 DOM Tree 的作用，HTML Parser 将文本的 HTML 文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展；这其中也有很多的规则和操作，比如容错机制，识别特殊标签 "),r("code",[v._v("<br></br>")]),v._v("  等")]),v._v(" "),r("p",[v._v("CSS 解析构建 CSSOM 树：CSS Parser 将很多个 CSS 文件中的样式合并解析出具有树形结构 Style Rules，也叫做 CSSOM")]),v._v(" "),r("p",[v._v("其中还有一个细节是浏览器解析文档：当遇到 "),r("code",[v._v("<script>")]),v._v("  标签的时候会停止解析文档，立即解析脚本，将脚本中改变 DOM 和 CSS 的地方分别解析出来，追加到 DOM Tree 和 CSSOM 上")]),v._v(" "),r("p",[v._v('根据 DOM 树和 CSSOM 树构建 Render 树：Render Tree 的构建其实就是 DOM Tree 和 CSSOMAttach 的过程，在 webkit 中，解析样式和创建呈现器的过程称为"附加"，每个 DOM 节点都有一个"attach"方法，Render Tree 其实就相当于一个计算好样式，与 HTML 对应的 Tree')]),v._v(" "),r("p",[v._v("根据 Render 树进行布局渲染 render layer：创建渲染树后，Layout 根据根据渲染树中渲染对象的信息，计算好每一个渲染对象的位置和尺寸，将其放在浏览器窗口的正确位置，某些时候会在文档布局完成之后进行 DOM 修改，重新布局的过程就称为"),r("strong",[v._v("回流")])]),v._v(" "),r("p",[v._v("其中计算（样式计算）是一个复杂的过程，因为 DOM 中的一个元素可以对应样式表中的多个元素，"),r("strong",[v._v("Firefox 采用了规则树和样式上下文树来简化样式计算")]),v._v("，规则树包含了所有已知规则的匹配路径，样式上下文包含端值，webkit 也有样式对象，但它们不保存在类似上下文树这样的结构中，只是由 DOM 节点指向此类对象的相关样式")]),v._v(" "),r("p",[v._v("根据计算的布局信息进行绘制：绘制阶段则会遍历呈现树，并调用呈现器的 paint 方法，将呈现器的内容显示在屏幕上，绘制的顺序其实就是元进入堆栈样素式上下文的顺序，例如，块呈现器的堆栈顺序如下：1.背景颜色，2.背景图片，3.边框，4.子代，5.轮廓")])])}),[],!1,null,null,null);_.default=s.exports}}]);