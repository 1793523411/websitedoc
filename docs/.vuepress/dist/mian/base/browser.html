<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>对浏览器的理解 | 跌倒的小黄瓜</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="这儿将描述一些东西···💤">
    <link rel="preload" href="/assets/css/0.styles.5251e6d5.css" as="style"><link rel="preload" href="/assets/js/app.faa285f4.js" as="script"><link rel="preload" href="/assets/js/2.9d52316c.js" as="script"><link rel="preload" href="/assets/js/7.6f34402a.js" as="script"><link rel="prefetch" href="/assets/js/10.bbf5c89c.js"><link rel="prefetch" href="/assets/js/11.19763db3.js"><link rel="prefetch" href="/assets/js/12.11c6e053.js"><link rel="prefetch" href="/assets/js/13.b72958f5.js"><link rel="prefetch" href="/assets/js/14.a80388f7.js"><link rel="prefetch" href="/assets/js/15.fae12494.js"><link rel="prefetch" href="/assets/js/16.808dae0a.js"><link rel="prefetch" href="/assets/js/17.2d3452f6.js"><link rel="prefetch" href="/assets/js/18.ae403e4c.js"><link rel="prefetch" href="/assets/js/19.d0b80e8b.js"><link rel="prefetch" href="/assets/js/20.46ad75ee.js"><link rel="prefetch" href="/assets/js/21.78a0bec0.js"><link rel="prefetch" href="/assets/js/22.2290246e.js"><link rel="prefetch" href="/assets/js/23.779da382.js"><link rel="prefetch" href="/assets/js/24.0ce957a7.js"><link rel="prefetch" href="/assets/js/25.f8fa3f9e.js"><link rel="prefetch" href="/assets/js/26.3cc57f60.js"><link rel="prefetch" href="/assets/js/27.86d5c583.js"><link rel="prefetch" href="/assets/js/28.ae767434.js"><link rel="prefetch" href="/assets/js/29.29be888f.js"><link rel="prefetch" href="/assets/js/3.0ad412b0.js"><link rel="prefetch" href="/assets/js/30.7ccc305e.js"><link rel="prefetch" href="/assets/js/31.7671813f.js"><link rel="prefetch" href="/assets/js/32.5df49cd3.js"><link rel="prefetch" href="/assets/js/33.226789d6.js"><link rel="prefetch" href="/assets/js/34.b7c52c26.js"><link rel="prefetch" href="/assets/js/35.e795b3ef.js"><link rel="prefetch" href="/assets/js/36.9de972a8.js"><link rel="prefetch" href="/assets/js/37.f42aab44.js"><link rel="prefetch" href="/assets/js/38.1fedf3ed.js"><link rel="prefetch" href="/assets/js/39.cb9d1e06.js"><link rel="prefetch" href="/assets/js/4.63c7b1b9.js"><link rel="prefetch" href="/assets/js/40.6bedd913.js"><link rel="prefetch" href="/assets/js/41.eb6343cd.js"><link rel="prefetch" href="/assets/js/42.f47a7c52.js"><link rel="prefetch" href="/assets/js/43.d403faba.js"><link rel="prefetch" href="/assets/js/44.0460b3b2.js"><link rel="prefetch" href="/assets/js/45.f165ca5c.js"><link rel="prefetch" href="/assets/js/46.a0c05375.js"><link rel="prefetch" href="/assets/js/47.09bea62e.js"><link rel="prefetch" href="/assets/js/48.49758f8f.js"><link rel="prefetch" href="/assets/js/49.54a2cffb.js"><link rel="prefetch" href="/assets/js/5.0023607c.js"><link rel="prefetch" href="/assets/js/50.a7bfff69.js"><link rel="prefetch" href="/assets/js/51.1bdbc178.js"><link rel="prefetch" href="/assets/js/52.5eca7e72.js"><link rel="prefetch" href="/assets/js/53.3e28da7f.js"><link rel="prefetch" href="/assets/js/54.6b7aba7f.js"><link rel="prefetch" href="/assets/js/55.6e988143.js"><link rel="prefetch" href="/assets/js/56.67135f9e.js"><link rel="prefetch" href="/assets/js/57.087c1e15.js"><link rel="prefetch" href="/assets/js/58.3e0fd45e.js"><link rel="prefetch" href="/assets/js/59.5927447b.js"><link rel="prefetch" href="/assets/js/6.30af8f3e.js"><link rel="prefetch" href="/assets/js/60.010511fe.js"><link rel="prefetch" href="/assets/js/61.8f4053f9.js"><link rel="prefetch" href="/assets/js/62.9a71b83e.js"><link rel="prefetch" href="/assets/js/63.2818c6cb.js"><link rel="prefetch" href="/assets/js/64.94d9beeb.js"><link rel="prefetch" href="/assets/js/65.26d56fd9.js"><link rel="prefetch" href="/assets/js/66.a04d4029.js"><link rel="prefetch" href="/assets/js/67.5bb5e9d7.js"><link rel="prefetch" href="/assets/js/68.e6d67d28.js"><link rel="prefetch" href="/assets/js/69.9d22b2f1.js"><link rel="prefetch" href="/assets/js/70.e6dba323.js"><link rel="prefetch" href="/assets/js/71.f0363ba1.js"><link rel="prefetch" href="/assets/js/72.affcc093.js"><link rel="prefetch" href="/assets/js/73.b321e3dc.js"><link rel="prefetch" href="/assets/js/74.55d673c6.js"><link rel="prefetch" href="/assets/js/75.381fc3d4.js"><link rel="prefetch" href="/assets/js/8.d948cff6.js"><link rel="prefetch" href="/assets/js/9.9e952900.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5251e6d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">跌倒的小黄瓜</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mian/index.html">
          面试
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/Demo/index.html">
          Demo
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          其他
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><div><div class="ads"><div id="ads_2"><div class="ant-carousel"><div class="slick-slider slick-initialized"><div class="slick-list"><div class="slick-track"><div tabIndex="-1" data-index="-1" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="0" class="slick-slide slick-active slick-current" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="1" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="2" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="3" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="4" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="5" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="6" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="7" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div></div></div><ul class="slick-dots slick-dots-bottom" style="display:block;"><li class="slick-active"><button>1</button></li><li><button>2</button></li><li><button>3</button></li><li><button>4</button></li></ul></div></div></div></div> <div role="separator" id="reset-margin" class="ant-divider ant-divider-horizontal ant-divider-dashed"></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试知识点</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mian/base/browser.html" aria-current="page" title="浏览器" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#对浏览器的理解" title="对浏览器的理解" class="sidebar-link">对浏览器的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器的主要组成部分是什么" title="浏览器的主要组成部分是什么？" class="sidebar-link">浏览器的主要组成部分是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#对浏览器内核的理解" title="对浏览器内核的理解" class="sidebar-link">对浏览器内核的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#常见的浏览器内核比较" title="常见的浏览器内核比较" class="sidebar-link">常见的浏览器内核比较</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#常见浏览器所用内核" title="常见浏览器所用内核" class="sidebar-link">常见浏览器所用内核</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器的渲染原理" title="浏览器的渲染原理" class="sidebar-link">浏览器的渲染原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器解析过程" title="浏览器解析过程" class="sidebar-link">浏览器解析过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#渲染过程中遇到-js-文件怎么处理" title="渲染过程中遇到 JS 文件怎么处理？" class="sidebar-link">渲染过程中遇到 JS 文件怎么处理？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#async-和-和-defer-的作用是什么-有什么区别" title="async 和 和 defer 的作用是什么？有什么区别？" class="sidebar-link">async 和 和 defer 的作用是什么？有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#什么是文档的预解析" title="什么是文档的预解析" class="sidebar-link">什么是文档的预解析</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#css-如何阻塞文档解析" title="CSS 如何阻塞文档解析" class="sidebar-link">CSS 如何阻塞文档解析</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器渲染过程" title="浏览器渲染过程" class="sidebar-link">浏览器渲染过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#渲染页面时常见哪些不良现象" title="渲染页面时常见哪些不良现象" class="sidebar-link">渲染页面时常见哪些不良现象</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#如何优化关键渲染路径" title="如何优化关键渲染路径" class="sidebar-link">如何优化关键渲染路径</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器绘制过程" title="浏览器绘制过程" class="sidebar-link">浏览器绘制过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#什么是重绘和回流" title="什么是重绘和回流" class="sidebar-link">什么是重绘和回流</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#如何减少回流" title="如何减少回流" class="sidebar-link">如何减少回流</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#为什么操作-dom-慢" title="为什么操作 DOM 慢" class="sidebar-link">为什么操作 DOM 慢</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器渲染页面过程概述" title="浏览器渲染页面过程概述" class="sidebar-link">浏览器渲染页面过程概述</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#重排与重绘的区别-什么情况下会触发" title="重排与重绘的区别，什么情况下会触发？" class="sidebar-link">重排与重绘的区别，什么情况下会触发？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器如何解析-css-选择器" title="浏览器如何解析 css 选择器？" class="sidebar-link">浏览器如何解析 css 选择器？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#浏览器是如何渲染-ui-的" title="浏览器是如何渲染 UI 的？" class="sidebar-link">浏览器是如何渲染 UI 的？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#如何实现浏览器内多个标签页之间的通信" title="如何实现浏览器内多个标签页之间的通信" class="sidebar-link">如何实现浏览器内多个标签页之间的通信</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#跨标签页的通讯方式有哪些" title="跨标签页的通讯方式有哪些" class="sidebar-link">跨标签页的通讯方式有哪些</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#为何会出现浏览器兼容问题" title="为何会出现浏览器兼容问题" class="sidebar-link">为何会出现浏览器兼容问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/browser.html#处理兼容问题的思路" title="处理兼容问题的思路" class="sidebar-link">处理兼容问题的思路</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#请求时浏览器缓存-from-memory-cache-和-from-disk-cache-的依据是什么-哪些数据什么时候存放在-memory-cache-和-disk-cache-中" title="请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？" class="sidebar-link">请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#说说浏览器缓存机制" title="说说浏览器缓存机制" class="sidebar-link">说说浏览器缓存机制</a></li><li class="sidebar-sub-header"><a href="/mian/base/browser.html#如何获取浏览器版本信息" title="如何获取浏览器版本信息" class="sidebar-link">如何获取浏览器版本信息</a></li></ul></li><li><a href="/mian/base/html2.html" title="HTML" class="sidebar-link">HTML</a></li><li><a href="/mian/base/css.html" title="CSS" class="sidebar-link">CSS</a></li><li><a href="/mian/base/js.html" title="Javascript" class="sidebar-link">Javascript</a></li><li><a href="/mian/base/Ajax.html" title="Ajax" class="sidebar-link">Ajax</a></li><li><a href="/mian/base/es6.html" title="ES6" class="sidebar-link">ES6</a></li><li><a href="/mian/base/nodejs.html" title="nodejs" class="sidebar-link">nodejs</a></li><li><a href="/mian/base/ts.html" title="TypeScript" class="sidebar-link">TypeScript</a></li><li><a href="/mian/base/vue.html" title="vue" class="sidebar-link">vue</a></li><li><a href="/mian/base/react.html" title="react" class="sidebar-link">react</a></li><li><a href="/mian/base/wx.html" title="微信小程序" class="sidebar-link">微信小程序</a></li><li><a href="/mian/base/project.html" title="工程化" class="sidebar-link">工程化</a></li><li><a href="/mian/base/network.html" title="计算机网络" class="sidebar-link">计算机网络</a></li><li><a href="/mian/base/design.html" title="设计模式" class="sidebar-link">设计模式</a></li><li><a href="/mian/base/safe.html" title="安全" class="sidebar-link">安全</a></li><li><a href="/mian/base/better.html" title="性能优化" class="sidebar-link">性能优化</a></li><li><a href="/mian/base/tools.html" title="工具" class="sidebar-link">工具</a></li><li><a href="/mian/base/datastruct.html" title="数据结构" class="sidebar-link">数据结构</a></li><li><a href="/mian/base/jstimu.html" title="js相关题目" class="sidebar-link">js相关题目</a></li><li><a href="/mian/base/suanfa.html" title="算法" class="sidebar-link">算法</a></li><li><a href="/mian/base/select.html" title="选择题" class="sidebar-link">选择题</a></li><li><a href="/mian/base/shim.html" title="兼容性问题" class="sidebar-link">兼容性问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="对浏览器的理解"><a href="#对浏览器的理解" class="header-anchor">#</a> 对浏览器的理解</h2> <p>浏览器的<strong>主要功能</strong>是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。<strong>简单来说浏览器可以分为两部分，shell 和 内核</strong>。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p> <h2 id="浏览器的主要组成部分是什么"><a href="#浏览器的主要组成部分是什么" class="header-anchor">#</a> 浏览器的主要组成部分是什么？</h2> <div class="language- extra-class"><pre class="language-text"><code>1.  用户界面:

        用户界面主要包括：地址栏，后退/前进按钮，书签目录等；（除了从服务器请求到的网页窗口）

2.  浏览器引擎：

        用来查询及操作渲染引擎的接口；

3.  渲染引擎：

        用来显示请求的 html 内容；（包括样式，图片，js）

4.  网络：

        主要是来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作；


6. UI后端：

        用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。

6.  JS 解释器 ：

        用来解释执行 JS 代码；


7. 数据存储：

        属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的      客户端存储技术；

</code></pre></div><h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="header-anchor">#</a> 对浏览器内核的理解</h2> <p>主要分成两部分：<strong>渲染引擎和 JS 引擎</strong>。</p> <p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</p> <p>JS 引擎：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，<strong>后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</strong></p> <h2 id="常见的浏览器内核比较"><a href="#常见的浏览器内核比较" class="header-anchor">#</a> 常见的浏览器内核比较</h2> <p><strong>Trident：这种浏览器内核是 IE 浏览器用的内核</strong>，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p> <p><strong>Gecko：这是 Firefox 和 Flock 所采用的内核</strong>，这个内核的优点就是<strong>功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口</strong>，但是代价是也显而易见就是要<strong>消耗很多的资源，比如内存</strong></p> <p><strong>Presto：Opera 曾经采用的就是 Presto 内核</strong>，Presto 内核被称为公认的浏览网页<strong>速度最快的内核</strong>，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会<strong>比其他的内核快 3 倍左右</strong>，缺点就是为了达到很快的速度而<strong>丢掉了一部分网页兼容性</strong></p> <p><strong>Webkit：Webkit 是 Safari 采用的内核</strong>，它的优点就是<strong>网页浏览速度较快</strong>，虽然<strong>不及 Presto 但是也胜于 Gecko 和 Trident</strong>，缺点是对于网页代码的容错性不高，也就是说<strong>对网页代码的兼容性较低</strong>，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 <strong>KHTML</strong> 的一个开源的分支</p> <p><strong>Blink</strong>：谷歌在 Chromium Blog 上发表博客，称<strong>将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎</strong>（即浏览器核心），内置于 Chrome 浏览器之中。其实 <strong>Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样</strong>。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，<strong>Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink</strong></p> <h3 id="常见浏览器所用内核"><a href="#常见浏览器所用内核" class="header-anchor">#</a> 常见浏览器所用内核</h3> <p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p> <p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；</p> <p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p> <p>（4） Safari 浏览器内核：Webkit 内核；</p> <p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p> <p>（6） 360 浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p> <p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p> <p>（8） 百度浏览器、世界之窗内核：IE 内核；</p> <p>（9） 2345 浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p> <p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核</p> <h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="header-anchor">#</a> 浏览器的渲染原理</h2> <p>（1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，<strong>DOM 树</strong>是由** DOM 元素及属性节点组成的**。</p> <p>（2）然后对 CSS 进行解析，生成** CSSOM 规则树**。</p> <p>（3）<strong>根据 DOM 树和 CSSOM 规则树构建渲染树</strong>。渲染树的节点被称为<strong>渲染对象</strong>，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p> <p>（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以<strong>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）</strong>。这一阶段浏览器要做的事情是要<strong>弄清楚各个节点在页面中的确切位置和大小</strong>。通常这一行为也被称为“自动重排”。</p> <p>（5）<strong>布局阶段结束后是绘制阶段</strong>，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是<strong>逐步完成的</strong>，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容</p> <h2 id="浏览器解析过程"><a href="#浏览器解析过程" class="header-anchor">#</a> 浏览器解析过程</h2> <h3 id="渲染过程中遇到-js-文件怎么处理"><a href="#渲染过程中遇到-js-文件怎么处理" class="header-anchor">#</a> 渲染过程中遇到 JS 文件怎么处理？</h3> <p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，<strong>HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎</strong>，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议<strong>将 script 标签放在 body 标签底部的原因</strong>。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 <strong>defer</strong> 或者 <strong>async</strong> 属性</p> <h3 id="async-和-和-defer-的作用是什么-有什么区别"><a href="#async-和-和-defer-的作用是什么-有什么区别" class="header-anchor">#</a> async 和 和 defer 的作用是什么？有什么区别？</h3> <p>（1）脚本没有 defer 或 async，浏览器会<strong>立即加载并执行指定的脚本</strong>，也就是说不等待后续载入的文档元素，读到就加载并执行。</p> <p>（2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是<strong>并行</strong>的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。<strong>多个脚本按顺序执行</strong>。</p> <p>（3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。<strong>多个脚本的执行顺序无法保证</strong>。</p> <h3 id="什么是文档的预解析"><a href="#什么是文档的预解析" class="header-anchor">#</a> 什么是文档的预解析</h3> <p>Webkit 和 Firefox 都做了这个优化，<strong>当执行 JavaScript 脚本时，另一个线程解析剩下的文档</strong>，并加载后面需要通过网络加载的资源。这种方式可以<strong>使资源并行加载从而使整体速度更快</strong>。需要注意的是，<strong>预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片</strong></p> <h3 id="css-如何阻塞文档解析"><a href="#css-如何阻塞文档解析" class="header-anchor">#</a> CSS 如何阻塞文档解析</h3> <p>理论上，既然<strong>样式表不改变 DOM 树</strong>，也就没有必要停下文档的解析等待它们，然而，存在一个问题，<strong>JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值</strong>，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么<strong>浏览器将延迟 JavaScript 脚本执行和文档的解析</strong>，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，<strong>浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析</strong>。</p> <h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="header-anchor">#</a> 浏览器渲染过程</h2> <h3 id="渲染页面时常见哪些不良现象"><a href="#渲染页面时常见哪些不良现象" class="header-anchor">#</a> 渲染页面时常见哪些不良现象</h3> <p>FOUC：主要指的是<strong>样式闪烁</strong>的问题，由于浏览器渲染机制（比如 firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。<strong>白屏</strong>：有些浏览器渲染机制（比如 chrome）要<strong>先构建 DOM 树和 CSSOM 树</strong>，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 <strong>js 文件放在头部</strong>，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题</p> <h3 id="如何优化关键渲染路径"><a href="#如何优化关键渲染路径" class="header-anchor">#</a> 如何优化关键渲染路径</h3> <p>为尽快完成<strong>首次渲染</strong>，我们需要最大限度减小以下三种可变因素：</p> <p>（1）关键<strong>资源的数量</strong>。
（2）关键路径<strong>长度</strong>。
（3）关键<strong>字节的数量</strong>。</p> <p><strong>关键资源</strong>是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少,同样，关<strong>键路径长度</strong>受所有关键资源与其<strong>字节大小</strong>之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要<strong>压缩和优化各项资源，确保最大限度减小传送大小</strong></p> <p>优化关键渲染路径的<strong>常规步骤</strong>如下：</p> <p>（1）对关键路径<strong>进行分析和特性描述</strong>：资源数、字节数、长度。</p> <p>（2）最大限度减少关键资源的<strong>数量</strong>：删除它们，延迟它们的下载，将它们标记为异步等。</p> <p>（3）优化关键字节数以缩短下载时间（<strong>往返次数</strong>）。</p> <p>（4）优化其余关键资源的<strong>加载顺序</strong>：您需要尽早下载所有关键资产，以缩短关键路径长度。</p> <h2 id="浏览器绘制过程"><a href="#浏览器绘制过程" class="header-anchor">#</a> 浏览器绘制过程</h2> <h3 id="什么是重绘和回流"><a href="#什么是重绘和回流" class="header-anchor">#</a> 什么是重绘和回流</h3> <p>重绘: <strong>当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background color，我们将这样的操作称为重绘</strong>。</p> <p>回流：<strong>当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流</strong>。</p> <p><strong>区别：</strong></p> <p>回流指当前窗口发生改变，发生滚动操作，或者元素的位置大小相关属性被更新时会触发布局过程，发生在 render 树，比如元素的几何尺寸变化，就需要重新验证并计算 Render Tree</p> <p>重绘指当前视觉样式属性被更新时触发的绘制过程，发生在渲染层 render layer 所以相比之下，回流的成本要比重绘高得多</p> <p>常见引起回流属性和方法：</p> <p><strong>任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。</strong></p> <p>（1）添加或者删除可见的 DOM 元素；</p> <p>（2）元素尺寸改变——边距、填充、边框、宽度和高度</p> <p>（3）内容变化，比如用户在 input 框中输入文字</p> <p>（4）浏览器窗口尺寸改变——resize 事件发生时</p> <p>（5）计算 offsetWidth 和 offsetHeight 属性</p> <p>（6）设置 style 属性的值</p> <p>（7）当你修改网页的默认字体时。</p> <p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流</p> <h3 id="如何减少回流"><a href="#如何减少回流" class="header-anchor">#</a> 如何减少回流</h3> <ul><li>使用 transform 替代 top</li> <li>不要把节点的属性值放在一个循环里当成循环里的变量</li> <li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li> <li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li> <li>在内存中多次操作节点，完成后在添加到文档中</li> <li>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className 或者 style.classText。</li> <li>在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中</li> <li>对元素进行一个复杂的操作，可以先隐藏它，操作完成后在显示</li></ul> <h3 id="为什么操作-dom-慢"><a href="#为什么操作-dom-慢" class="header-anchor">#</a> 为什么操作 DOM 慢</h3> <p>一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p> <h2 id="浏览器渲染页面过程概述"><a href="#浏览器渲染页面过程概述" class="header-anchor">#</a> 浏览器渲染页面过程概述</h2> <p>大致过程：</p> <p><strong>HTML 解析构建 DOM-&gt;CSS 解析构建 CSSOM 树-&gt;根据 DOM 树和 CSSOM 树构建 render 树-&gt;根据 render 树进行布局渲染 render layer-&gt;根据计算的布局信息进行绘制</strong>,不同浏览器的内核不同，所以渲染过程其中有部分细节有不一样，以 webkit 主流程为例</p> <p><img src="/assets/img/01.dedd9a78.png" alt="浏览器渲染原理"></p> <p>浏览器解析渲染页面过程是一个复杂的过程，其中有不少的细节和规则，所以这里只能总结大致过程</p> <p>较详细过程：</p> <p>HTML 解析构建 DOM 树：其中 HTML Parser 就起到了将 HTML 标记解析成 DOM Tree 的作用，HTML Parser 将文本的 HTML 文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展；这其中也有很多的规则和操作，比如容错机制，识别特殊标签 <code>&lt;br&gt;&lt;/br&gt;</code>  等</p> <p>CSS 解析构建 CSSOM 树：CSS Parser 将很多个 CSS 文件中的样式合并解析出具有树形结构 Style Rules，也叫做 CSSOM</p> <p>其中还有一个细节是浏览器解析文档：当遇到 <code>&lt;script&gt;</code>  标签的时候会停止解析文档，立即解析脚本，将脚本中改变 DOM 和 CSS 的地方分别解析出来，追加到 DOM Tree 和 CSSOM 上</p> <p>根据 DOM 树和 CSSOM 树构建 Render 树：Render Tree 的构建其实就是 DOM Tree 和 CSSOMAttach 的过程，在 webkit 中，解析样式和创建呈现器的过程称为&quot;附加&quot;，每个 DOM 节点都有一个&quot;attach&quot;方法，Render Tree 其实就相当于一个计算好样式，与 HTML 对应的 Tree</p> <p>根据 Render 树进行布局渲染 render layer：创建渲染树后，Layout 根据根据渲染树中渲染对象的信息，计算好每一个渲染对象的位置和尺寸，将其放在浏览器窗口的正确位置，某些时候会在文档布局完成之后进行 DOM 修改，重新布局的过程就称为<strong>回流</strong></p> <p>其中计算（样式计算）是一个复杂的过程，因为 DOM 中的一个元素可以对应样式表中的多个元素，<strong>Firefox 采用了规则树和样式上下文树来简化样式计算</strong>，规则树包含了所有已知规则的匹配路径，样式上下文包含端值，webkit 也有样式对象，但它们不保存在类似上下文树这样的结构中，只是由 DOM 节点指向此类对象的相关样式</p> <p>根据计算的布局信息进行绘制：绘制阶段则会遍历呈现树，并调用呈现器的 paint 方法，将呈现器的内容显示在屏幕上，绘制的顺序其实就是元进入堆栈样素式上下文的顺序，例如，块呈现器的堆栈顺序如下：1.背景颜色，2.背景图片，3.边框，4.子代，5.轮廓</p> <hr> <p>答案：</p> <ul><li>解析 HTML 生成 DOM 树。</li> <li>解析 CSS 生成 CSSOM 规则树。</li> <li>将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。</li> <li>遍历渲染树开始布局，计算每个节点的位置大小信息。</li> <li>将渲染树每个节点绘制到屏幕。</li></ul> <p>解析：</p> <ul><li>使用 HTML 创建文档对象模型（DOM）</li> <li>使用 CSS 创建 CSS 对象模型（CSSOM）</li> <li>基于 DOM 和 CSSOM 执行脚本（Scripts）</li> <li>合并 DOM 和 CSSOM 形成渲染树（Render Tree）</li> <li>使用渲染树布局（Layout）所有元素</li> <li>渲染（Paint）所有元素</li></ul> <h2 id="重排与重绘的区别-什么情况下会触发"><a href="#重排与重绘的区别-什么情况下会触发" class="header-anchor">#</a> 重排与重绘的区别，什么情况下会触发？</h2> <ol><li>简述重排的概念</li></ol> <p>浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。</p> <ol start="2"><li>简述重绘的概念</li></ol> <p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p> <p><strong>简述重绘和重排的关系 重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</strong></p> <ol start="3"><li>什么情况下会触发重排？</li></ol> <ul><li>页面渲染初始化时；（这个无法避免）</li> <li>浏览器窗口改变尺寸；</li> <li>元素尺寸改变时；</li> <li>元素位置改变时；</li> <li>元素内容改变时；</li> <li>添加或删除可见的 DOM 元素时。</li></ul> <ol start="4"><li>重排优化有如下五种方法</li></ol> <ul><li>将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。</li> <li>如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）</li> <li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</li> <li>由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。</li> <li>在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。</li></ul> <h2 id="浏览器如何解析-css-选择器"><a href="#浏览器如何解析-css-选择器" class="header-anchor">#</a> 浏览器如何解析 css 选择器？</h2> <p>CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。 而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p> <h2 id="浏览器是如何渲染-ui-的"><a href="#浏览器是如何渲染-ui-的" class="header-anchor">#</a> 浏览器是如何渲染 UI 的？</h2> <p>① 浏览器将获取的 HTML 文档解析成 DOM 树</p> <p>② 处理 CSS 标记，构成层叠样式表模型 CSSOM(CSS Object Model)</p> <p>③ 将 DOM 和 CSSOM 合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象</p> <p>④ 渲染树的每个元素包含的内容都是计算过的，它被称之为布局 layout。浏览器使用一种流式处理的方法，只需要一次 pass 绘制操作就可以布局所有的元素</p> <p>⑤ 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制 painting</p> <p><img src="/assets/img/09.2081da6f.png" alt=""></p> <h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="header-anchor">#</a> 如何实现浏览器内多个标签页之间的通信</h2> <p>调用 localstorge、cookies 等本地存储方式，注意 sessionstorge 不可以哦</p> <h2 id="跨标签页的通讯方式有哪些"><a href="#跨标签页的通讯方式有哪些" class="header-anchor">#</a> 跨标签页的通讯方式有哪些</h2> <div class="language- extra-class"><pre class="language-text"><code>(1) BroadCast Channel
(2) Service Worker
(3) LocalStorage + window.onstorage监听
(4) Shared Worker + 定时器轮询(setInterval)
(5) IndexedDB + 定时器轮询(setInterval)
(6) cookie + 定时器轮询(setInterval)
(7) window.open + window.postMessage
(8) Websocket
</code></pre></div><h2 id="为何会出现浏览器兼容问题"><a href="#为何会出现浏览器兼容问题" class="header-anchor">#</a> 为何会出现浏览器兼容问题</h2> <ul><li>同一产品，版本越老 bug 越多</li> <li>同一产品，版本越新，功能越多</li> <li>不同产品，不同标准，不同实现方式</li></ul> <h3 id="处理兼容问题的思路"><a href="#处理兼容问题的思路" class="header-anchor">#</a> 处理兼容问题的思路</h3> <ol><li>要不要做</li></ol> <ul><li>产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）</li> <li>成本的角度 (有无必要做某件事)</li></ul> <ol start="2"><li>做到什么程度</li></ol> <p>让哪些浏览器支持哪些效果</p> <ol start="3"><li>如何做</li></ol> <ul><li><p>根据兼容需求选择技术框架/库(jquery)</p></li> <li><p>根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)</p></li> <li><p>条件注释、CSS Hack、js 能力检测做一些修补</p></li> <li><p>渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验</p></li> <li><p>优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p></li></ul> <h2 id="请求时浏览器缓存-from-memory-cache-和-from-disk-cache-的依据是什么-哪些数据什么时候存放在-memory-cache-和-disk-cache-中"><a href="#请求时浏览器缓存-from-memory-cache-和-from-disk-cache-的依据是什么-哪些数据什么时候存放在-memory-cache-和-disk-cache-中" class="header-anchor">#</a> 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？</h2> <p>一、前言
缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p> <p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p> <p>接下来的内容中我们将通过缓存位置、缓存策略以及实际场景应用缓存策略来探讨浏览器缓存机制。</p> <p><img src="/assets/img/cache.40ce2d3b.png" alt=""></p> <p>二、缓存位置
从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p> <ol><li><p>Service Worker</p></li> <li><p>Memory Cache</p></li> <li><p>Disk Cache</p></li> <li><p>Push Cache</p></li> <li><p>Service Worker</p></li></ol> <p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p> <p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。.</p> <p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p> <p>Memory Cache
Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p> <p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？ 这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p> <p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p> <p>内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如 ）下载的资源。总所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。</p> <p>需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。</p> <p>Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p> <p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。</p> <p>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住：</p> <p>对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘</p> <p>Push Cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p> <p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读 Jake Archibald 的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： - 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 - 可以推送 no-cache 和 no-store 的资源 - 一旦连接被关闭，Push Cache 就被释放 - 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。 - Push Cache 中的缓存只能被使用一次 - 浏览器可以拒绝接受已经存在的资源推送 - 你可以给其他域名推送资源</p> <p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p> <p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p> <h2 id="说说浏览器缓存机制"><a href="#说说浏览器缓存机制" class="header-anchor">#</a> 说说浏览器缓存机制</h2> <p>答案：过期机制、验证机制</p> <p>解析：</p> <p>对于浏览器的缓存来讲，这些规则是在 HTTP 协议头部和 HTML 页面的 Meta 标签中定义的。他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。</p> <p><strong>过期机制</strong>：指的是缓存副本的有效期。一个缓存的副本必须满足以下条件，浏览器会认为它是有效的，足够新的： 1.含有完整的过期时间控制头信息（HTTP 协议报头），并且仍在有效期内 2.浏览器已经使用过这个缓存的副本，并且会在一个会话中已经检查过新鲜度(即服务器上的资源是否发生改变) 满足以上两种情况的一种，浏览器会直接从缓存中获取副本进行渲染</p> <p><strong>校验值（验证机制）</strong>：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签 Etag(Entity Tag),它可以用来作为浏览器再次请求过程中的校验标识，如果发现校验标识不匹配，说明资源已经被修改或者过期，浏览器需要重新获取资源内容。</p> <h2 id="如何获取浏览器版本信息"><a href="#如何获取浏览器版本信息" class="header-anchor">#</a> 如何获取浏览器版本信息</h2> <p><code>window.navigator.userAgent</code></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/mian/base/html2.html">
        HTML
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.faa285f4.js" defer></script><script src="/assets/js/2.9d52316c.js" defer></script><script src="/assets/js/7.6f34402a.js" defer></script>
  </body>
</html>