<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>js 是一门怎样的语言，它有什么特点 | 跌倒的小黄瓜</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="这儿将描述一些东西···💤">
    <link rel="preload" href="/assets/css/0.styles.ef377faa.css" as="style"><link rel="preload" href="/assets/js/app.19ab200f.js" as="script"><link rel="preload" href="/assets/js/2.e7f3efaa.js" as="script"><link rel="preload" href="/assets/js/5.d521be3c.js" as="script"><link rel="prefetch" href="/assets/js/10.77cbd99c.js"><link rel="prefetch" href="/assets/js/100.0ed1ec36.js"><link rel="prefetch" href="/assets/js/101.d0e457f2.js"><link rel="prefetch" href="/assets/js/102.31448b83.js"><link rel="prefetch" href="/assets/js/103.ef53c205.js"><link rel="prefetch" href="/assets/js/104.72dce2be.js"><link rel="prefetch" href="/assets/js/105.f8e0c5f5.js"><link rel="prefetch" href="/assets/js/106.2d04b1b6.js"><link rel="prefetch" href="/assets/js/107.816cd36c.js"><link rel="prefetch" href="/assets/js/108.235ce5d9.js"><link rel="prefetch" href="/assets/js/109.2897d01e.js"><link rel="prefetch" href="/assets/js/11.636b413f.js"><link rel="prefetch" href="/assets/js/110.ff3a0b04.js"><link rel="prefetch" href="/assets/js/111.6ac52f6c.js"><link rel="prefetch" href="/assets/js/112.b7b486b1.js"><link rel="prefetch" href="/assets/js/113.db966af9.js"><link rel="prefetch" href="/assets/js/114.6442fe87.js"><link rel="prefetch" href="/assets/js/115.9a3cb4a2.js"><link rel="prefetch" href="/assets/js/116.7f52e1a3.js"><link rel="prefetch" href="/assets/js/117.20db4440.js"><link rel="prefetch" href="/assets/js/118.be815d45.js"><link rel="prefetch" href="/assets/js/119.01719dc4.js"><link rel="prefetch" href="/assets/js/12.37623088.js"><link rel="prefetch" href="/assets/js/13.cd9045df.js"><link rel="prefetch" href="/assets/js/14.4a1bb161.js"><link rel="prefetch" href="/assets/js/15.be8b44e3.js"><link rel="prefetch" href="/assets/js/16.7e5a1d9b.js"><link rel="prefetch" href="/assets/js/17.444615f4.js"><link rel="prefetch" href="/assets/js/18.fc038c10.js"><link rel="prefetch" href="/assets/js/19.ac8ed601.js"><link rel="prefetch" href="/assets/js/20.6136202d.js"><link rel="prefetch" href="/assets/js/21.577439f2.js"><link rel="prefetch" href="/assets/js/22.c663c2bd.js"><link rel="prefetch" href="/assets/js/23.dec63df2.js"><link rel="prefetch" href="/assets/js/24.0ec40893.js"><link rel="prefetch" href="/assets/js/25.eaf22a9d.js"><link rel="prefetch" href="/assets/js/26.8e379da8.js"><link rel="prefetch" href="/assets/js/27.ec2be807.js"><link rel="prefetch" href="/assets/js/28.9c164fc7.js"><link rel="prefetch" href="/assets/js/29.b2c52bb2.js"><link rel="prefetch" href="/assets/js/3.0e650678.js"><link rel="prefetch" href="/assets/js/30.6084b589.js"><link rel="prefetch" href="/assets/js/31.419243a2.js"><link rel="prefetch" href="/assets/js/32.0831af44.js"><link rel="prefetch" href="/assets/js/33.40816d69.js"><link rel="prefetch" href="/assets/js/34.4c005507.js"><link rel="prefetch" href="/assets/js/35.3dc5beed.js"><link rel="prefetch" href="/assets/js/36.25650c65.js"><link rel="prefetch" href="/assets/js/37.9c5d9bfa.js"><link rel="prefetch" href="/assets/js/38.7cfe7242.js"><link rel="prefetch" href="/assets/js/39.ad075d23.js"><link rel="prefetch" href="/assets/js/4.91510760.js"><link rel="prefetch" href="/assets/js/40.3a9277ea.js"><link rel="prefetch" href="/assets/js/41.b631d4ba.js"><link rel="prefetch" href="/assets/js/42.f36fe5ee.js"><link rel="prefetch" href="/assets/js/43.dc37bf53.js"><link rel="prefetch" href="/assets/js/44.43571a71.js"><link rel="prefetch" href="/assets/js/45.be678cb4.js"><link rel="prefetch" href="/assets/js/46.cd24fcdc.js"><link rel="prefetch" href="/assets/js/47.f644ca8d.js"><link rel="prefetch" href="/assets/js/48.eb45b138.js"><link rel="prefetch" href="/assets/js/49.9075c9fe.js"><link rel="prefetch" href="/assets/js/50.7da282b0.js"><link rel="prefetch" href="/assets/js/51.c418b05a.js"><link rel="prefetch" href="/assets/js/52.f1718cba.js"><link rel="prefetch" href="/assets/js/53.08a81059.js"><link rel="prefetch" href="/assets/js/54.120aa548.js"><link rel="prefetch" href="/assets/js/55.c29140a1.js"><link rel="prefetch" href="/assets/js/56.8a6142d5.js"><link rel="prefetch" href="/assets/js/57.2dc21e1b.js"><link rel="prefetch" href="/assets/js/58.9c411dee.js"><link rel="prefetch" href="/assets/js/59.dcb9b32c.js"><link rel="prefetch" href="/assets/js/6.f9c36fed.js"><link rel="prefetch" href="/assets/js/60.9a5a48c6.js"><link rel="prefetch" href="/assets/js/61.16afe103.js"><link rel="prefetch" href="/assets/js/62.1d67d2c7.js"><link rel="prefetch" href="/assets/js/63.04299a55.js"><link rel="prefetch" href="/assets/js/64.cb371b6c.js"><link rel="prefetch" href="/assets/js/65.7a25f61e.js"><link rel="prefetch" href="/assets/js/66.0ebe56de.js"><link rel="prefetch" href="/assets/js/67.f9150706.js"><link rel="prefetch" href="/assets/js/68.4278da26.js"><link rel="prefetch" href="/assets/js/69.ee78f446.js"><link rel="prefetch" href="/assets/js/7.9d457f30.js"><link rel="prefetch" href="/assets/js/70.30a493ed.js"><link rel="prefetch" href="/assets/js/71.ca917fd8.js"><link rel="prefetch" href="/assets/js/72.71e13e99.js"><link rel="prefetch" href="/assets/js/73.f86546f3.js"><link rel="prefetch" href="/assets/js/74.76a6af11.js"><link rel="prefetch" href="/assets/js/75.76cc481d.js"><link rel="prefetch" href="/assets/js/76.33409640.js"><link rel="prefetch" href="/assets/js/77.9ed40890.js"><link rel="prefetch" href="/assets/js/78.e3d92445.js"><link rel="prefetch" href="/assets/js/79.a858eee5.js"><link rel="prefetch" href="/assets/js/8.c3c4fcf3.js"><link rel="prefetch" href="/assets/js/80.ec8f486c.js"><link rel="prefetch" href="/assets/js/81.5b7d6e15.js"><link rel="prefetch" href="/assets/js/82.f1cfe96f.js"><link rel="prefetch" href="/assets/js/83.bb845d1a.js"><link rel="prefetch" href="/assets/js/84.aafac322.js"><link rel="prefetch" href="/assets/js/85.c81a6495.js"><link rel="prefetch" href="/assets/js/86.bcf7ece5.js"><link rel="prefetch" href="/assets/js/87.923ef708.js"><link rel="prefetch" href="/assets/js/88.b9710862.js"><link rel="prefetch" href="/assets/js/89.ae8d6fbd.js"><link rel="prefetch" href="/assets/js/9.f47eb619.js"><link rel="prefetch" href="/assets/js/90.8a0b8488.js"><link rel="prefetch" href="/assets/js/91.7fb16aa2.js"><link rel="prefetch" href="/assets/js/92.d988fd4b.js"><link rel="prefetch" href="/assets/js/93.ff8dc497.js"><link rel="prefetch" href="/assets/js/94.829ec7a1.js"><link rel="prefetch" href="/assets/js/95.3c13eeeb.js"><link rel="prefetch" href="/assets/js/96.bdde969a.js"><link rel="prefetch" href="/assets/js/97.5bb40e82.js"><link rel="prefetch" href="/assets/js/98.3f1ab848.js"><link rel="prefetch" href="/assets/js/99.40cc6eb0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ef377faa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">跌倒的小黄瓜</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mian/index.html">
          面试
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/Demo/index.html">
          Demo
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/collection/index.html">
          收集
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/notes/index.html">
          笔记
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          其他
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><div><div class="ads"><div id="ads_2"><div class="ant-carousel"><div class="slick-slider slick-initialized"><div class="slick-list"><div class="slick-track"><div tabIndex="-1" data-index="-1" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="0" class="slick-slide slick-active slick-current" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="1" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="2" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="3" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="4" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="5" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="6" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="7" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div></div></div><ul class="slick-dots slick-dots-bottom" style="display:block;"><li class="slick-active"><button>1</button></li><li><button>2</button></li><li><button>3</button></li><li><button>4</button></li></ul></div></div></div></div> <div role="separator" id="reset-margin" class="ant-divider ant-divider-horizontal ant-divider-dashed"></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试知识点</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mian/base/browser.html" title="浏览器" class="sidebar-link">浏览器</a></li><li><a href="/mian/base/html2.html" title="HTML" class="sidebar-link">HTML</a></li><li><a href="/mian/base/css.html" title="CSS" class="sidebar-link">CSS</a></li><li><a href="/mian/base/js.html" aria-current="page" title="Javascript" class="active sidebar-link">Javascript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-是一门怎样的语言-它有什么特点" title="js 是一门怎样的语言，它有什么特点" class="sidebar-link">js 是一门怎样的语言，它有什么特点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-的基本数据类型" title="js 的基本数据类型" class="sidebar-link">js 的基本数据类型</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-的-typeof-返回哪些数据类型" title="javascript 的 typeof 返回哪些数据类型" class="sidebar-link">javascript 的 typeof 返回哪些数据类型</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#typeof原理" title="typeof原理" class="sidebar-link">typeof原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何判断-js-变量的一个类型-至少三种方式" title="如何判断 JS 变量的一个类型（至少三种方式）" class="sidebar-link">如何判断 JS 变量的一个类型（至少三种方式）</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#值类型和引用类型有哪些区别" title="值类型和引用类型有哪些区别" class="sidebar-link">值类型和引用类型有哪些区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-有几种类型的值-画内存图" title="JavaScript 有几种类型的值，画内存图" class="sidebar-link">JavaScript 有几种类型的值，画内存图</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是堆-什么是栈-它们之间有什么区别和联系" title="什么是堆？什么是栈？它们之间有什么区别和联系" class="sidebar-link">什么是堆？什么是栈？它们之间有什么区别和联系</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#内部属性-class-是什么-是什么" title="内部属性[[Class]]是什么？是什么" class="sidebar-link">内部属性[[Class]]是什么？是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#介绍-js-有哪些内置对象" title="介绍 js 有哪些内置对象" class="sidebar-link">介绍 js 有哪些内置对象</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#undefined-与-undeclared-的区别" title="undefined 与 undeclared 的区别" class="sidebar-link">undefined 与 undeclared 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#null-和-和-undefined-的区别" title="null 和 和 undefined 的区别" class="sidebar-link">null 和 和 undefined 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何获取安全的-undefined-值" title="如何获取安全的 undefined 值" class="sidebar-link">如何获取安全的 undefined 值</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#说几条写-javascript-的基本规范" title="说几条写 JavaScript 的基本规范" class="sidebar-link">说几条写 JavaScript 的基本规范</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-原型-原型链-有什么特点" title="JavaScript 原型，原型链,有什么特点" class="sidebar-link">JavaScript 原型，原型链,有什么特点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-获取原型的方法" title="js 获取原型的方法" class="sidebar-link">js 获取原型的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#在-js-中不同进制数字的表示方式" title="在 js 中不同进制数字的表示方式" class="sidebar-link">在 js 中不同进制数字的表示方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中整数的安全范围是多少" title="js 中整数的安全范围是多少" class="sidebar-link">js 中整数的安全范围是多少</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#typeof-nan-的结果是什么" title="typeof NaN 的结果是什么" class="sidebar-link">typeof NaN 的结果是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#isnan-和-和-number-isnan-函数的区别" title="isNaN 和 和 Number.isNaN 函数的区别？" class="sidebar-link">isNaN 和 和 Number.isNaN 函数的区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#array-构造函数只有一个参数值时的表现" title="Array 构造函数只有一个参数值时的表现？" class="sidebar-link">Array 构造函数只有一个参数值时的表现？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#使用构造函数的注意点" title="使用构造函数的注意点" class="sidebar-link">使用构造函数的注意点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-中如何检测一个变量是一个-string-类型" title="JavaScript 中如何检测一个变量是一个 String 类型？" class="sidebar-link">JavaScript 中如何检测一个变量是一个 String 类型？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#列举-3-种强制类型转换和-2-种隐式类型转换" title="列举 3 种强制类型转换和 2 种隐式类型转换" class="sidebar-link">列举 3 种强制类型转换和 2 种隐式类型转换</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#其他值到字符串的转换规则" title="其他值到字符串的转换规则" class="sidebar-link">其他值到字符串的转换规则</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#在-js-中哪些会被隐式转换为-false" title="在 js 中哪些会被隐式转换为 false" class="sidebar-link">在 js 中哪些会被隐式转换为 false</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#复杂数据类型如何转变为字符串" title="复杂数据类型如何转变为字符串" class="sidebar-link">复杂数据类型如何转变为字符串</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#其他值到数字值的转换规则" title="其他值到数字值的转换规则？" class="sidebar-link">其他值到数字值的转换规则？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#其他值到布尔类型的值的转换规则" title="其他值到布尔类型的值的转换规则" class="sidebar-link">其他值到布尔类型的值的转换规则</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#和-和-的-的-valueof-和-和-tostring-的结果是什么" title="{} 和 和 [] 的 的 valueOf 和 和 toString 的结果是什么" class="sidebar-link">{} 和 和 [] 的 的 valueOf 和 和 toString 的结果是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是假值对象" title="什么是假值对象" class="sidebar-link">什么是假值对象</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#操作符的作用" title="~ 操作符的作用" class="sidebar-link">~ 操作符的作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字-它们之间的区别是什么" title="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么" class="sidebar-link">解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#操作符什么时候用于字符串的拼接" title="+ 操作符什么时候用于字符串的拼接？" class="sidebar-link">+ 操作符什么时候用于字符串的拼接？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么情况下会发生布尔值的隐式强制类型转换" title="什么情况下会发生布尔值的隐式强制类型转换" class="sidebar-link">什么情况下会发生布尔值的隐式强制类型转换</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#和-和-操作符的返回值" title="|| 和 和 &amp;&amp; 操作符的返回值" class="sidebar-link">|| 和 和 &amp;&amp; 操作符的返回值</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#symbol-值的强制类型转换" title="Symbol 值的强制类型转换" class="sidebar-link">Symbol 值的强制类型转换</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#操作符的强制类型转换规则" title="== 操作符的强制类型转换规则" class="sidebar-link">== 操作符的强制类型转换规则</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何将字符串转化为数字-例如-12-3b" title="如何将字符串转化为数字，例如 '12.3b'" class="sidebar-link">如何将字符串转化为数字，例如 '12.3b'</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何将浮点数点左边的数每三位添加一个逗号-如何将浮点数点左边的数每三位添加一个逗号-如-12000000-11-转化为-转化为-12-000-000-11" title="如何将浮点数点左边的数每三位添加一个逗号 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为 转化为 12,000,000.11" class="sidebar-link">如何将浮点数点左边的数每三位添加一个逗号 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为 转化为 12,000,000.11</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#常用正则表达式" title="常用正则表达式" class="sidebar-link">常用正则表达式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何实现数组的随机排序" title="如何实现数组的随机排序" class="sidebar-link">如何实现数组的随机排序</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-创建对象的几种方式" title="javascript 创建对象的几种方式" class="sidebar-link">javascript 创建对象的几种方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-继承的几种实现方式" title="JavaScript 继承的几种实现方式" class="sidebar-link">JavaScript 继承的几种实现方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#寄生式组合继承的实现" title="寄生式组合继承的实现" class="sidebar-link">寄生式组合继承的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#es5-es6-的继承除了写法以外还有什么区别" title="ES5/ES6 的继承除了写法以外还有什么区别？" class="sidebar-link">ES5/ES6 的继承除了写法以外还有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-的作用域链" title="Javascript 的作用域链？" class="sidebar-link">Javascript 的作用域链？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是原型链" title="什么是原型链？" class="sidebar-link">什么是原型链？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#谈谈-this-对象的理解。" title="谈谈 This 对象的理解。" class="sidebar-link">谈谈 This 对象的理解。</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何正确判断与使用-this-箭头函数有没有自己的-this-指针" title="如何正确判断与使用 this，箭头函数有没有自己的 this 指针" class="sidebar-link">如何正确判断与使用 this，箭头函数有没有自己的 this 指针</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#eval-是做什么的" title="eval 是做什么的" class="sidebar-link">eval 是做什么的</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是-dom-和-和-bom" title="什么是 DOM 和 和 BOM" class="sidebar-link">什么是 DOM 和 和 BOM</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#写一个通用的事件侦听器函数。" title="写一个通用的事件侦听器函数。" class="sidebar-link">写一个通用的事件侦听器函数。</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#事件是什么-ie-与火狐的事件机制有什么区别" title="事件是什么？IE 与火狐的事件机制有什么区别？" class="sidebar-link">事件是什么？IE 与火狐的事件机制有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#_3-种事件模型是什么" title="3 种事件模型是什么？" class="sidebar-link">3 种事件模型是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#事件委托是什么" title="事件委托是什么" class="sidebar-link">事件委托是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#_1-2-3-map-parseint-答案是多少" title="[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少" class="sidebar-link">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是闭包-为什么要用它" title="什么是闭包，为什么要用它" class="sidebar-link">什么是闭包，为什么要用它</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#你对闭包的理解-优缺点" title="你对闭包的理解？优缺点？" class="sidebar-link">你对闭包的理解？优缺点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-的-代码中的-use-strict" title="javascript 的 代码中的 &quot;use strict&quot;;" class="sidebar-link">javascript 的 代码中的 &quot;use strict&quot;;</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何判断一个对象是否属于某个类" title="如何判断一个对象是否属于某个类？" class="sidebar-link">如何判断一个对象是否属于某个类？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#instanceof-的作用" title="instanceof 的作用？" class="sidebar-link">instanceof 的作用？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#new-操作符具体干了什么呢-如何实现" title="new 操作符具体干了什么呢？如何实现" class="sidebar-link">new 操作符具体干了什么呢？如何实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-中-有一个函数-执行时对象查找时-永远不会去查找原型" title="Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型" class="sidebar-link">Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#对于-json-的了解" title="对于 JSON 的了解" class="sidebar-link">对于 JSON 的了解</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-延迟加载的方式有哪些" title="js 延迟加载的方式有哪些" class="sidebar-link">js 延迟加载的方式有哪些</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ajax-是什么-个-如何创建一个-ajax" title="Ajax 是什么? 个 如何创建一个 Ajax？" class="sidebar-link">Ajax 是什么? 个 如何创建一个 Ajax？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ajax-的概念-手写一下原生实现的思路" title="Ajax 的概念，手写一下原生实现的思路" class="sidebar-link">Ajax 的概念，手写一下原生实现的思路</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#fetch-和-xmlhttprequest-的区别在哪" title="fetch 和 XMLHttpRequest 的区别在哪" class="sidebar-link">fetch 和 XMLHttpRequest 的区别在哪</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#谈一谈浏览器的缓存机制" title="谈一谈浏览器的缓存机制" class="sidebar-link">谈一谈浏览器的缓存机制</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ajax-解决浏览器缓存问题" title="Ajax 解决浏览器缓存问题" class="sidebar-link">Ajax 解决浏览器缓存问题</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#同步和异步的区别" title="同步和异步的区别？" class="sidebar-link">同步和异步的区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是浏览器的同源政策" title="什么是浏览器的同源政策" class="sidebar-link">什么是浏览器的同源政策</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何解决跨域问题" title="如何解决跨域问题？" class="sidebar-link">如何解决跨域问题？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#iframe-跨域通信和不跨域通信" title="iframe 跨域通信和不跨域通信" class="sidebar-link">iframe 跨域通信和不跨域通信</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#有关-jsonp" title="有关 JSONP" class="sidebar-link">有关 JSONP</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#jsonp-优缺点" title="jsonp 优缺点？" class="sidebar-link">jsonp 优缺点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#简单谈一下-cookie" title="简单谈一下 cookie" class="sidebar-link">简单谈一下 cookie</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么要使用模块化-都有哪几种方式可以实现模块化-各有什么特点" title="为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？" class="sidebar-link">为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#模块化开发怎么做" title="模块化开发怎么做？" class="sidebar-link">模块化开发怎么做？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-的几种模块规范" title="js 的几种模块规范" class="sidebar-link">js 的几种模块规范</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#amd-和-和-cmd-规范的区别" title="AMD 和 和 CMD 规范的区别" class="sidebar-link">AMD 和 和 CMD 规范的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#es6-与-模块与-commonjs-模块" title="ES6 与 模块与 CommonJS 模块" class="sidebar-link">ES6 与 模块与 CommonJS 模块</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#requirejs-的核心原理是什么-如何动态加载的-如何避免多次加载-的核心原理是什么" title="requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载 的核心原理是什么？)" class="sidebar-link">requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载 的核心原理是什么？)</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#require-与-import-的区别" title="require 与 import 的区别" class="sidebar-link">require 与 import 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ecmascript6-怎么写-class-现-为什么会出现-class-这种东西" title="ECMAScript6 怎么写 class 现 ，为什么会出现 class 这种东西" class="sidebar-link">ECMAScript6 怎么写 class 现 ，为什么会出现 class 这种东西</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#documen-write-和-innerhtml-的区别" title="documen.write 和 innerHTML 的区别？" class="sidebar-link">documen.write 和 innerHTML 的区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#dom-操作-怎样添加、移除、移动、复制、创建和查找节点" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点" class="sidebar-link">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#innerhtml-与-与-outerhtml-的区别" title="innerHTML 与 与 outerHTML 的区别？" class="sidebar-link">innerHTML 与 与 outerHTML 的区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#call-和-apply-的区别" title=".call() 和.apply() 的区别" class="sidebar-link">.call() 和.apply() 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#在-javascript-中什么是伪数组-如何将伪数组转化为标准数组" title="在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？" class="sidebar-link">在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-类数组对象的定义" title="JavaScript 类数组对象的定义" class="sidebar-link">JavaScript 类数组对象的定义</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#字符串常用操作" title="字符串常用操作" class="sidebar-link">字符串常用操作</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#数组有哪些原生方法-列举一下" title="数组有哪些原生方法，列举一下" class="sidebar-link">数组有哪些原生方法，列举一下</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#数组中常用的方法" title="数组中常用的方法" class="sidebar-link">数组中常用的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-数组的函数-map-foreach-reduce-filter" title="JavaScript 数组的函数 map/forEach/reduce/filter" class="sidebar-link">JavaScript 数组的函数 map/forEach/reduce/filter</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#对数组方法-map-和-reduce-方法的理解-区别在哪里" title="对数组方法 map 和 reduce 方法的理解，区别在哪里" class="sidebar-link">对数组方法 map 和 reduce 方法的理解，区别在哪里</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#对-map-和-reduce-实现的理解-能手写一下嘛" title="对 map 和 reduce 实现的理解，能手写一下嘛" class="sidebar-link">对 map 和 reduce 实现的理解，能手写一下嘛</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#数组的-fill-方法" title="数组的 fill 方法？" class="sidebar-link">数组的 fill 方法？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#的长度" title="[,,,] 的长度？" class="sidebar-link">[,,,] 的长度？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何判断一个对象是否为数组" title="如何判断一个对象是否为数组" class="sidebar-link">如何判断一个对象是否为数组</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#object-prototype-tostring-call-和-instanceof-和-array-isarray-区别好坏" title="Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏" class="sidebar-link">Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#split-join-的区别" title="split() join()的区别" class="sidebar-link">split() join()的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#数组和对象有哪些原生方法-列举一下" title="数组和对象有哪些原生方法，列举一下？" class="sidebar-link">数组和对象有哪些原生方法，列举一下？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#delete-数组的-item-数组的-length-是否会-1" title="delete 数组的 item，数组的 length 是否会 -1" class="sidebar-link">delete 数组的 item，数组的 length 是否会 -1</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#数组降维" title="数组降维" class="sidebar-link">数组降维</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何编写高性能的-javascript" title="如何编写高性能的 Javascript" class="sidebar-link">如何编写高性能的 Javascript</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#简单介绍一下-v8-引擎的垃圾回收机制" title="简单介绍一下 V8 引擎的垃圾回收机制" class="sidebar-link">简单介绍一下 V8 引擎的垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-的垃圾回收机制" title="js 的垃圾回收机制" class="sidebar-link">js 的垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#哪些操作会造成内存泄漏" title="哪些操作会造成内存泄漏" class="sidebar-link">哪些操作会造成内存泄漏</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#实现一个页面操作不会整页刷新的网站-0-并且能在浏览器前进、后退时正确响应" title="实现一个页面操作不会整页刷新的网站 0，并且能在浏览器前进、后退时正确响应" class="sidebar-link">实现一个页面操作不会整页刷新的网站 0，并且能在浏览器前进、后退时正确响应</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何判断当前脚本运行在浏览器还是-node-环境中" title="如何判断当前脚本运行在浏览器还是 node 环境中" class="sidebar-link">如何判断当前脚本运行在浏览器还是 node 环境中</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么不把-script-标签放在-body-结束标签之后-html-结束标签之前" title="为什么不把 Script 标签放在 body 结束标签之后 html 结束标签之前" class="sidebar-link">为什么不把 Script 标签放在 body 结束标签之后 html 结束标签之前</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#移动端的点击事件的有延迟-时间是多久-为什么会有-移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时" class="sidebar-link">移动端的点击事件的有延迟，时间是多久，为什么会有？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#移动端点透现象" title="移动端点透现象" class="sidebar-link">移动端点透现象</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#zepto-的点透问题如何解决" title="Zepto 的点透问题如何解决？" class="sidebar-link">Zepto 的点透问题如何解决？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#移动端最小触控区域是多大" title="移动端最小触控区域是多大？" class="sidebar-link">移动端最小触控区域是多大？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时" title="移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？" class="sidebar-link">移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#移动端-click-事件、touch-事件、tap-事件的区别" title="移动端 click 事件、touch 事件、tap 事件的区别" class="sidebar-link">移动端 click 事件、touch 事件、tap 事件的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何测试前端代码-bdd-tdd-unit-test-怎么测试你的前端工程-mocha-sinon-jasmin-qunit" title="如何测试前端代码 BDD, TDD, Unit Test 怎么测试你的前端工程(mocha, sinon, jasmin, qUnit..)" class="sidebar-link">如何测试前端代码 BDD, TDD, Unit Test 怎么测试你的前端工程(mocha, sinon, jasmin, qUnit..)</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#检测浏览器版本版本有哪些方式" title="检测浏览器版本版本有哪些方式" class="sidebar-link">检测浏览器版本版本有哪些方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是-polyfil" title="什么是 Polyfil" class="sidebar-link">什么是 Polyfil</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#使用-js-实现获取文件扩展名" title="使用 JS 实现获取文件扩展名？" class="sidebar-link">使用 JS 实现获取文件扩展名？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#介绍一下-js-的节流与防抖" title="介绍一下 js 的节流与防抖" class="sidebar-link">介绍一下 js 的节流与防抖</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#object-is-符-与原来的比较操作符-、-的区别" title="Object.is() 符 与原来的比较操作符 “===” 、“==” 的区别" class="sidebar-link">Object.is() 符 与原来的比较操作符 “===” 、“==” 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#escape-encodeuri-encodeuricomponent-有什么区别" title="escape,encodeURI,encodeURIComponent 有什么区别？" class="sidebar-link">escape,encodeURI,encodeURIComponent 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#unicode-和-和-utf-8-之间的关系" title="Unicode 和 和 UTF-8 之间的关系" class="sidebar-link">Unicode 和 和 UTF-8 之间的关系</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#执行上下文与执行栈" title="执行上下文与执行栈" class="sidebar-link">执行上下文与执行栈</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#执行上下文" title="执行上下文" class="sidebar-link">执行上下文</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-的事件循环是什么" title="js 的事件循环是什么？" class="sidebar-link">js 的事件循环是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#对-eventloop-事件循环机制的了解" title="对 eventloop 事件循环机制的了解" class="sidebar-link">对 eventloop 事件循环机制的了解</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-单线程还是多线程-如何显示异步操作" title="JS 单线程还是多线程，如何显示异步操作" class="sidebar-link">JS 单线程还是多线程，如何显示异步操作</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#对宏任务和微任务的理解-微任务有哪些" title="对宏任务和微任务的理解，微任务有哪些" class="sidebar-link">对宏任务和微任务的理解，微任务有哪些</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#微任务和宏任务" title="微任务和宏任务" class="sidebar-link">微任务和宏任务</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中的深浅拷贝实现" title="js 中的深浅拷贝实现" class="sidebar-link">js 中的深浅拷贝实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#深拷贝的实现" title="深拷贝的实现" class="sidebar-link">深拷贝的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#手写-call-、apply-及-bind-函数" title="手写 call 、apply 及 bind 函数" class="sidebar-link">手写 call 、apply 及 bind 函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#函数柯里化的实现" title="函数柯里化的实现" class="sidebar-link">函数柯里化的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么-0-1-0-2-0-3-如何解决这个问题" title="为什么 0.1 + 0.2 != 0.3？如何解决这个问题" class="sidebar-link">为什么 0.1 + 0.2 != 0.3？如何解决这个问题</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#原码、反码和补码的介绍" title="原码、反码和补码的介绍" class="sidebar-link">原码、反码和补码的介绍</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#toprecision-和-和-tofixed-和-和-math-round-的区别" title="toPrecision 和 和 toFixed 和 和 Math.round 的区别" class="sidebar-link">toPrecision 和 和 toFixed 和 和 Math.round 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别" title="offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别" class="sidebar-link">offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#函数式编程" title="函数式编程" class="sidebar-link">函数式编程</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#异步编程的实现方式" title="异步编程的实现方式" class="sidebar-link">异步编程的实现方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-异步解决方案的发展历程以及优缺点" title="JS 异步解决方案的发展历程以及优缺点" class="sidebar-link">JS 异步解决方案的发展历程以及优缺点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-与-动画与-css-动画区别及相应实现" title="Js 与 动画与 CSS 动画区别及相应实现" class="sidebar-link">Js 与 动画与 CSS 动画区别及相应实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#mouseover-和-和-mouseenter-的区别" title="mouseover 和 和 mouseenter 的区别" class="sidebar-link">mouseover 和 和 mouseenter 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-拖拽功能的实现" title="js 拖拽功能的实现" class="sidebar-link">js 拖拽功能的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#兼容各种浏览器版本的事件绑定" title="兼容各种浏览器版本的事件绑定" class="sidebar-link">兼容各种浏览器版本的事件绑定</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么使用-settimeout-实现-setinterval-怎么模拟" title="为什么使用 setTimeout 实现 setInterval？怎么模拟？" class="sidebar-link">为什么使用 setTimeout 实现 setInterval？怎么模拟？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#settimeout-用作倒计时为什么会产生误差" title="setTimeout 用作倒计时为什么会产生误差" class="sidebar-link">setTimeout 用作倒计时为什么会产生误差</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何检测浏览器所支持的最小字体大小" title="如何检测浏览器所支持的最小字体大小？" class="sidebar-link">如何检测浏览器所支持的最小字体大小？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#怎么做-js-码-代码-error-统计" title="怎么做 JS 码 代码 Error 统计" class="sidebar-link">怎么做 JS 码 代码 Error 统计</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何封装一个-javascript-的类型判断函数" title="如何封装一个 javascript 的类型判断函数" class="sidebar-link">如何封装一个 javascript 的类型判断函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何判断一个对象是否为空对象" title="如何判断一个对象是否为空对象？" class="sidebar-link">如何判断一个对象是否为空对象？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#使用闭包实现每隔一秒打印-1-2-3-4" title="使用闭包实现每隔一秒打印 1,2,3,4" class="sidebar-link">使用闭包实现每隔一秒打印 1,2,3,4</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#自执行函数-用于什么场景-好处" title="自执行函数?用于什么场景？好处?" class="sidebar-link">自执行函数?用于什么场景？好处?</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#手写一个-jsonp" title="手写一个 jsonp" class="sidebar-link">手写一个 jsonp</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#手写一个观察者模式" title="手写一个观察者模式" class="sidebar-link">手写一个观察者模式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#eventemitter-实现" title="EventEmitter 实现" class="sidebar-link">EventEmitter 实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#一道常被人轻视的前端-js-面试题" title="一道常被人轻视的前端 JS 面试题" class="sidebar-link">一道常被人轻视的前端 JS 面试题</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何确定页面的可用性时间-什么是-performance-api" title="如何确定页面的可用性时间，什么是 Performance API" class="sidebar-link">如何确定页面的可用性时间，什么是 Performance API</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中的命名规则" title="js 中的命名规则" class="sidebar-link">js 中的命名规则</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-语句末尾分号是否可以省略" title="js 语句末尾分号是否可以省略？" class="sidebar-link">js 语句末尾分号是否可以省略？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#自动分号" title="自动分号" class="sidebar-link">自动分号</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#object-assign" title="Object.assign()" class="sidebar-link">Object.assign()</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#math-ceil-和-math-floor" title="Math.ceil 和 Math.floor" class="sidebar-link">Math.ceil 和 Math.floor</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-for-循环注意点" title="js for 循环注意点" class="sidebar-link">js for 循环注意点</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#for-in-和-for-of" title="for in 和 for of" class="sidebar-link">for in 和 for of</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#for-in、object-keys-和-object-getownpropertynames-对属性遍历有什么区别" title="for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？" class="sidebar-link">for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#一个列表-假设有-100000-个数据-这个该怎么办" title="一个列表，假设有 100000 个数据，这个该怎么办" class="sidebar-link">一个列表，假设有 100000 个数据，这个该怎么办</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#列表无限滚动曾经有遇到过嘛" title="列表无限滚动曾经有遇到过嘛" class="sidebar-link">列表无限滚动曾经有遇到过嘛</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中倒计时的纠偏实现" title="js 中倒计时的纠偏实现" class="sidebar-link">js 中倒计时的纠偏实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#进程间通信的方式" title="进程间通信的方式？" class="sidebar-link">进程间通信的方式？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何查找一篇英文文章中出现频率最高的单词" title="如何查找一篇英文文章中出现频率最高的单词" class="sidebar-link">如何查找一篇英文文章中出现频率最高的单词</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#document-load-和-document-ready-的区别" title="document load 和 document ready 的区别" class="sidebar-link">document load 和 document ready 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#h5-与-native-如何交互" title="H5 与 Native 如何交互" class="sidebar-link">H5 与 Native 如何交互</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#script-标签的-defer-和-asnyc-属性的作用以及二者的区别" title="&lt;script&gt;标签的 defer 和 asnyc 属性的作用以及二者的区别？" class="sidebar-link">&lt;script&gt;标签的 defer 和 asnyc 属性的作用以及二者的区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是面向对象" title="什么是面向对象？" class="sidebar-link">什么是面向对象？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#你对松散类型的理解" title="你对松散类型的理解" class="sidebar-link">你对松散类型的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-严格模式和正常模式" title="JS 严格模式和正常模式" class="sidebar-link">JS 严格模式和正常模式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#sort-排序原理" title="sort 排序原理" class="sidebar-link">sort 排序原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何实现文件断点续传" title="如何实现文件断点续传" class="sidebar-link">如何实现文件断点续传</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何做到修改-url-参数页面不刷新" title="如何做到修改 url 参数页面不刷新" class="sidebar-link">如何做到修改 url 参数页面不刷新</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#事件绑定与普通事件有什么区别" title="事件绑定与普通事件有什么区别" class="sidebar-link">事件绑定与普通事件有什么区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ie-和-dom-事件流的区别" title="IE 和 DOM 事件流的区别" class="sidebar-link">IE 和 DOM 事件流的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ie-和标准下有哪些兼容性的写法" title="IE 和标准下有哪些兼容性的写法" class="sidebar-link">IE 和标准下有哪些兼容性的写法</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何阻止冒泡与默认行为" title="如何阻止冒泡与默认行为" class="sidebar-link">如何阻止冒泡与默认行为</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#javascript-的本地对象-内置对象和宿主对象" title="javascript 的本地对象，内置对象和宿主对象" class="sidebar-link">javascript 的本地对象，内置对象和宿主对象</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#foo-foo-bar-这行代码是什么意思-为什么要这样写" title="foo = foo||bar ，这行代码是什么意思？为什么要这样写？" class="sidebar-link">foo = foo||bar ，这行代码是什么意思？为什么要这样写？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#正则表达式构造函数-var-reg-new-regexp-xxx-与正则表达字面量-var-reg-有什么不同" title="正则表达式构造函数 var reg = new RegExp('xxx')与正则表达字面量 var reg = // 有什么不同？" class="sidebar-link">正则表达式构造函数 var reg = new RegExp('xxx')与正则表达字面量 var reg = // 有什么不同？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中-callee-与-caller-的作用" title="js 中 callee 与 caller 的作用" class="sidebar-link">js 中 callee 与 caller 的作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#异步加载-js-的方法" title="异步加载 js 的方法" class="sidebar-link">异步加载 js 的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#js-中-文档碎片的理解和使用" title="JS 中 文档碎片的理解和使用" class="sidebar-link">JS 中 文档碎片的理解和使用</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#ie-与火狐的事件机制有什么区别-如何阻止冒泡" title="IE 与火狐的事件机制有什么区别？如何阻止冒泡" class="sidebar-link">IE 与火狐的事件机制有什么区别？如何阻止冒泡</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#列举浏览器对象模型-bom-里常用的至少-4-个对象-并列举-window-对象的常用方法至少-5-个" title="列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？" class="sidebar-link">列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#class-forname-的作用-为什么要用" title="class.forname 的作用?为什么要用?" class="sidebar-link">class.forname 的作用?为什么要用?</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#外部-js-文件出现中文字符-会出现什么问题-怎么解决" title="外部 JS 文件出现中文字符，会出现什么问题，怎么解决？" class="sidebar-link">外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#定时器-setinterval-有一个有名函数-fn1-setinterval-fn1-500-与-setinterval-fn1-500-有什么区别" title="定时器 setInterval 有一个有名函数 fn1，setInterval（fn1,500）与 setInterval（fn1(),500）有什么区别？" class="sidebar-link">定时器 setInterval 有一个有名函数 fn1，setInterval（fn1,500）与 setInterval（fn1(),500）有什么区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#documen-write-和-innerhtml-的区别-2" title="documen.write 和 innerHTML 的区别?" class="sidebar-link">documen.write 和 innerHTML 的区别?</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#简述创建函数的几种方式" title="简述创建函数的几种方式" class="sidebar-link">简述创建函数的几种方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#window-location-search-返回的是什么" title="window.location.search() 返回的是什么？" class="sidebar-link">window.location.search() 返回的是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#window-location-hash-返回什么" title="window.location.hash 返回什么？" class="sidebar-link">window.location.hash 返回什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#window-location-reload-作用" title="window.location.reload() 作用？" class="sidebar-link">window.location.reload() 作用？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#bom-对象有哪些-列举-window-对象" title="BOM 对象有哪些，列举 window 对象？" class="sidebar-link">BOM 对象有哪些，列举 window 对象？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#前端-templating-mustache-underscore-handlebars-是干嘛的-怎么用" title="前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?" class="sidebar-link">前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#知道什么是-webkit-么-知道怎么用浏览器的各种工具来调试和-debug-代码么" title="知道什么是 webkit 么? 知道怎么用浏览器的各种工具来调试和 debug 代码么?" class="sidebar-link">知道什么是 webkit 么? 知道怎么用浏览器的各种工具来调试和 debug 代码么?</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#事件绑定的方式" title="事件绑定的方式" class="sidebar-link">事件绑定的方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#事件模型" title="事件模型" class="sidebar-link">事件模型</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何自定义事件" title="如何自定义事件" class="sidebar-link">如何自定义事件</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#target-和-currenttarget-区别" title="target 和 currentTarget 区别" class="sidebar-link">target 和 currentTarget 区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#prototype-和proto的关系是什么" title="prototype 和proto的关系是什么" class="sidebar-link">prototype 和proto的关系是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#什么是属性搜索原则" title="什么是属性搜索原则？" class="sidebar-link">什么是属性搜索原则？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#说下函数式编程的理解" title="说下函数式编程的理解" class="sidebar-link">说下函数式编程的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么-for-循环嵌套顺序会影响性能" title="为什么 for 循环嵌套顺序会影响性能？" class="sidebar-link">为什么 for 循环嵌套顺序会影响性能？</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#轮播图实现原理" title="轮播图实现原理" class="sidebar-link">轮播图实现原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#如何设计一个轮播图组件" title="如何设计一个轮播图组件" class="sidebar-link">如何设计一个轮播图组件</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#script-引入方式" title="script 引入方式" class="sidebar-link">script 引入方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#为什么普通-r-for-于-循环的性能远远高于-h-foreach-的性能-请解释其中的原因" title="为什么普通 r for 于 循环的性能远远高于 h forEach 的性能，请解释其中的原因" class="sidebar-link">为什么普通 r for 于 循环的性能远远高于 h forEach 的性能，请解释其中的原因</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#es6-成-代码转成-5-es5-代码的实现思路是什么" title="ES6 成 代码转成 5 ES5 代码的实现思路是什么" class="sidebar-link">ES6 成 代码转成 5 ES5 代码的实现思路是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/js.html#d-a-b-c-d-和-和-a-b-c-d-哪个性能更高" title="d a.b.c.d 和 和 a['b']['c']['d'] ，哪个性能更高？" class="sidebar-link">d a.b.c.d 和 和 a['b']['c']['d'] ，哪个性能更高？</a></li></ul></li><li><a href="/mian/base/Ajax.html" title="Ajax" class="sidebar-link">Ajax</a></li><li><a href="/mian/base/es6.html" title="ES6" class="sidebar-link">ES6</a></li><li><a href="/mian/base/nodejs.html" title="nodejs" class="sidebar-link">nodejs</a></li><li><a href="/mian/base/ts.html" title="TypeScript" class="sidebar-link">TypeScript</a></li><li><a href="/mian/base/vue.html" title="vue" class="sidebar-link">vue</a></li><li><a href="/mian/base/react.html" title="react" class="sidebar-link">react</a></li><li><a href="/mian/base/wx.html" title="微信小程序" class="sidebar-link">微信小程序</a></li><li><a href="/mian/base/project.html" title="工程化" class="sidebar-link">工程化</a></li><li><a href="/mian/base/network.html" title="网络" class="sidebar-link">网络</a></li><li><a href="/mian/base/db.html" title="数据库" class="sidebar-link">数据库</a></li><li><a href="/mian/base/design.html" title="设计模式" class="sidebar-link">设计模式</a></li><li><a href="/mian/base/safe.html" title="安全" class="sidebar-link">安全</a></li><li><a href="/mian/base/better.html" title="性能优化" class="sidebar-link">性能优化</a></li><li><a href="/mian/base/tools.html" title="工具" class="sidebar-link">工具</a></li><li><a href="/mian/base/datastruct.html" title="数据结构" class="sidebar-link">数据结构</a></li><li><a href="/mian/base/jstimu.html" title="js相关题目" class="sidebar-link">js相关题目</a></li><li><a href="/mian/base/suanfa.html" title="算法" class="sidebar-link">算法</a></li><li><a href="/mian/base/select.html" title="选择题" class="sidebar-link">选择题</a></li><li><a href="/mian/base/shim.html" title="兼容性问题" class="sidebar-link">兼容性问题</a></li><li><a href="/mian/base/niu.html" title="牛客刷题" class="sidebar-link">牛客刷题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面经（校招）</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="js-是一门怎样的语言-它有什么特点"><a href="#js-是一门怎样的语言-它有什么特点" class="header-anchor">#</a> js 是一门怎样的语言，它有什么特点</h2> <p>1.脚本语言。JavaScript 是一种解释型的脚本语言,C、C++等语言先编译后执行,而 JavaScript 是在程序的运行过程中逐行进行解释。</p> <p>2.基于对象。JavaScript 是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。</p> <p>3.简单。JavaScript 语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于 Java 基本语句和控制的脚本语言,其设计简单紧凑。</p> <p>4.动态性。JavaScript 是一种采用事件驱动的脚本语言,它不需要经过 Web 服务器就可以对用户的输入做出响应。</p> <p>5.跨平台性。JavaScript 脚本语言不依赖于操作系统,仅需要浏览器的支持。</p> <h2 id="js-的基本数据类型"><a href="#js-的基本数据类型" class="header-anchor">#</a> js 的基本数据类型</h2> <p>js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 类型，代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题</p> <h2 id="javascript-的-typeof-返回哪些数据类型"><a href="#javascript-的-typeof-返回哪些数据类型" class="header-anchor">#</a> javascript 的 typeof 返回哪些数据类型</h2> <p>7 种分别为 string、boolean、number、Object、Function、undefined、symbol(ES6)</p> <h2 id="typeof原理"><a href="#typeof原理" class="header-anchor">#</a> typeof原理</h2> <p>typeof(null) === 'object'，关于原因，在小黄书《你不知道的JavaScript》中有这么一段解释：</p> <p>原理是这样的， 不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。</p> <p><a href="https://cloud.tencent.com/developer/article/1362660" target="_blank" rel="noopener noreferrer">typeof最新原理解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/xuzishuai/p/9081944.html" target="_blank" rel="noopener noreferrer">typeof的原理？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="如何判断-js-变量的一个类型-至少三种方式"><a href="#如何判断-js-变量的一个类型-至少三种方式" class="header-anchor">#</a> 如何判断 JS 变量的一个类型（至少三种方式）</h2> <p>typeof、instanceof、 constructor、 prototype</p> <h2 id="值类型和引用类型有哪些区别"><a href="#值类型和引用类型有哪些区别" class="header-anchor">#</a> 值类型和引用类型有哪些区别</h2> <ol><li>值类型： 字符串 string  ，数值 number  ，布尔值 boolean  ， null  , undefined</li> <li>引用类型： 对象 Object  ，数组 Array  ，函数 Function</li></ol> <p>值类型：</p> <ul><li>占用空间固定，保存在 栈 中：当一个方法执行时，每个方法都会建立自己的内存栈，也就是所谓的函数作用域，基础变量的值是存储在栈中的，而引用类型变量存储在栈中的是指向堆中的数组或者对象的&quot;地址&quot;</li> <li>保存与复制的是值本身</li> <li>可以用 typeof 检测值类型</li> <li>基本数据类型是值类型</li></ul> <p>引用类型：</p> <ul><li>占用空间不固定，保存在 堆 中：由于对象的创建成本比较大，在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用，这个运行时数据区就是堆内存</li> <li>保存与复制的是指向对象的一个指针</li> <li>使用 instanceof（） 检测数据类型</li> <li>使用 new()  方法构造出的对象是引用型</li></ul> <h2 id="javascript-有几种类型的值-画内存图"><a href="#javascript-有几种类型的值-画内存图" class="header-anchor">#</a> JavaScript 有几种类型的值，画内存图</h2> <p>涉及知识点：</p> <p>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</p> <p>堆：引用数据类型（对象、数组和函数）</p> <p>两种类型的区别是：存储位置不同。原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p> <p>回答：</p> <p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。基本数据类型....复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p> <h2 id="什么是堆-什么是栈-它们之间有什么区别和联系"><a href="#什么是堆-什么是栈-它们之间有什么区别和联系" class="header-anchor">#</a> 什么是堆？什么是栈？它们之间有什么区别和联系</h2> <p>堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收</p> <h2 id="内部属性-class-是什么-是什么"><a href="#内部属性-class-是什么-是什么" class="header-anchor">#</a> 内部属性[[Class]]是什么？是什么</h2> <p>所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 <code>[[Class]]</code>（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 <code>Object.prototype.toString(..)</code> 来查看。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;[object Array]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">regex-literal</span><span class="token regex-delimiter">/</span><span class="token regex-flags">i</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;[object RegExp]&quot;</span>
</code></pre></div><h2 id="介绍-js-有哪些内置对象"><a href="#介绍-js-有哪些内置对象" class="header-anchor">#</a> 介绍 js 有哪些内置对象</h2> <p>涉及知识点：</p> <p><strong>全局的对象</strong>（ global objects ）或称标准内置对象，不要和 &quot;<strong>全局对象</strong>（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。标准内置对象的分类</p> <p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p> <p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p> <p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p> <p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p> <p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p> <p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p> <p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元。例如 Map、Set、WeakMap、WeakSet</p> <p>（8）<strong>矢量集合</strong>，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</p> <p>（9）**结构化数据，**这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p> <p>（10）<strong>控制抽象对象例如 Promise、Generator 等</strong></p> <p>（11）<strong>反射</strong>，例如 Reflect、Proxy</p> <p>（12）<strong>国际化</strong>，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p> <p>（13）<strong>WebAssembly</strong></p> <p>（14）其他例如 <strong>arguments</strong></p> <p>回答：</p> <p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p> <h2 id="undefined-与-undeclared-的区别"><a href="#undefined-与-undeclared-的区别" class="header-anchor">#</a> undefined 与 undeclared 的区别</h2> <p>已在作用域中<strong>声明但还没有赋值的变量</strong>，是 undefined 的。相反，还<strong>没有在作用域中声明过的变量</strong>，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</p> <h2 id="null-和-和-undefined-的区别"><a href="#null-和-和-undefined-的区别" class="header-anchor">#</a> null 和 和 undefined 的区别</h2> <p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。<strong>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”</strong>，这是一个历史遗留的问题。当我们<strong>使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false</strong>。</p> <p>null： Null 类型，代表“空值&quot;，代表一个空对象指针，使用 typeof 运算得到 “object&quot;，所以你可以认为它是一个特殊的对象值。</p> <p>undefined： Undefined 类型，当一个声明了一个变量未初始化时，得到的就是 undefined。</p> <h2 id="如何获取安全的-undefined-值"><a href="#如何获取安全的-undefined-值" class="header-anchor">#</a> 如何获取安全的 undefined 值</h2> <p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。按惯例我们<strong>用 void 0 来获得 undefined</strong>。</p> <h2 id="说几条写-javascript-的基本规范"><a href="#说几条写-javascript-的基本规范" class="header-anchor">#</a> 说几条写 JavaScript 的基本规范</h2> <p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p> <p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p> <p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p> <p>（3）在进行比较的时候吧，尽量使用'===', '!=='代替'==', '!='。</p> <p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p> <p>（5）switch 语句必须带有 default 分支。</p> <p>（6）for 循环必须使用大括号。</p> <p>（7）if 语句必须使用大括号。</p> <h2 id="javascript-原型-原型链-有什么特点"><a href="#javascript-原型-原型链-有什么特点" class="header-anchor">#</a> JavaScript 原型，原型链,有什么特点</h2> <p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 <code>__proto__</code> 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个<strong>Object.getPrototypeOf</strong>() 方法，我们可以通过这个方法来获取对象的原型。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString()等方法的原因。</p> <p>特点：</p> <p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p> <h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="header-anchor">#</a> js 获取原型的方法</h2> <ul><li><code>p.__proto__</code></li> <li><code>p.constructor.prototype</code></li> <li><code>Object.getPrototypeOf(p)</code></li></ul> <h2 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="header-anchor">#</a> 在 js 中不同进制数字的表示方式</h2> <ul><li>以 0X、0x 开头的表示为十六进制</li> <li>以 0、0O、0o 开头的表示为八进制</li> <li>以 0B、0b 开头的表示为二进制格式</li></ul> <h2 id="js-中整数的安全范围是多少"><a href="#js-中整数的安全范围是多少" class="header-anchor">#</a> js 中整数的安全范围是多少</h2> <p>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，即 <code>9007199254740991</code>，在 ES6 中被定义为<code>Number.MAX_SAFE_INTEGER</code>。最小整数是<code>-9007199254740991</code>，在 ES6 中被定义为<code>Number.MIN_SAFE_INTEGER</code>。如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p> <h2 id="typeof-nan-的结果是什么"><a href="#typeof-nan-的结果是什么" class="header-anchor">#</a> typeof NaN 的结果是什么</h2> <p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p> <div class="language- extra-class"><pre class="language-text"><code>typeof NaN; // &quot;number&quot;
</code></pre></div><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN 为 true。</p> <h2 id="isnan-和-和-number-isnan-函数的区别"><a href="#isnan-和-和-number-isnan-函数的区别" class="header-anchor">#</a> isNaN 和 和 Number.isNaN 函数的区别？</h2> <p>函数 isNaN 接收参数后，会<strong>尝试将这个参数转换为数值</strong>，任何<strong>不能被转换为数值的的值都会返回 true</strong>，因此<strong>非数字值传入也会返回 true</strong> ，会影响 NaN 的判断。函数 Number.isNaN 会首先<strong>判断传入参数是否为数字</strong>，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断<strong>更为准确</strong>。</p> <h2 id="array-构造函数只有一个参数值时的表现"><a href="#array-构造函数只有一个参数值时的表现" class="header-anchor">#</a> Array 构造函数只有一个参数值时的表现？</h2> <p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</p> <h2 id="使用构造函数的注意点"><a href="#使用构造函数的注意点" class="header-anchor">#</a> 使用构造函数的注意点</h2> <ul><li>一般情况下构造函数的首字母需要大写，因为我们在看到一个函数首字母大写的情况，就认定这是一个构造函数，需要跟 new 关键字进行搭配使用，创建一个新的实例（对象）</li> <li>构造函数在被调用的时候需要跟 new 关键字搭配使用。</li> <li>在构造函数内部通过 this+属性名的形式为实例添加一些属性和方法。</li> <li>构造函数一般不需要返回值，如果有返回值
<ul><li>如果返回值是一个基本数据类型，那么调用构造函数，返回值仍旧是那么创建出来的对象。</li> <li>如果返回值是一个复杂数据类型，那么调用构造函数的时候，返回值就是这个 return 之后的那个复杂数据类型。</li></ul></li></ul> <h2 id="javascript-中如何检测一个变量是一个-string-类型"><a href="#javascript-中如何检测一个变量是一个-string-类型" class="header-anchor">#</a> JavaScript 中如何检测一个变量是一个 String 类型？</h2> <p>三种方法（typeof、constructor、Object.prototype.toString.call()）</p> <p>解析：</p> <p>①typeof</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token string">&quot;123&quot;</span> <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">typeof</span> <span class="token string">&quot;123&quot;</span> <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>②constructor</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;123&quot;</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>③Object.prototype.toString.call()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;[object String]&quot;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h2 id="列举-3-种强制类型转换和-2-种隐式类型转换"><a href="#列举-3-种强制类型转换和-2-种隐式类型转换" class="header-anchor">#</a> 列举 3 种强制类型转换和 2 种隐式类型转换</h2> <p>强制（parseInt,parseFloat,Number）、隐式（+ -）</p> <h2 id="其他值到字符串的转换规则"><a href="#其他值到字符串的转换规则" class="header-anchor">#</a> 其他值到字符串的转换规则</h2> <p>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。</p> <p>（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</p> <p>（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</p> <p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p> <p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p> <p>（3）对普通对象来说，除非自行定义 <code>toString()</code> 方法，否则会调用 <code>toString()（Object.prototype.toString()）</code>来返回内部属性 <code>[[Class]]</code> 的值，如<code>&quot;[objectObject]&quot;</code>。如果对象有自己的 <code>toString()</code> 方法，字符串化时就会调用该方法并使用其返回值</p> <h2 id="在-js-中哪些会被隐式转换为-false"><a href="#在-js-中哪些会被隐式转换为-false" class="header-anchor">#</a> 在 js 中哪些会被隐式转换为 false</h2> <p>Undefined、null、关键字 false、NaN、零、空字符串</p> <h2 id="复杂数据类型如何转变为字符串"><a href="#复杂数据类型如何转变为字符串" class="header-anchor">#</a> 复杂数据类型如何转变为字符串</h2> <ul><li>首先，会调用 valueOf 方法，如果方法的返回值是一个基本数据类型，就返回这个值，</li> <li>如果调用 valueOf 方法之后的返回值仍旧是一个复杂数据类型，就会调用该对象的 toString 方法，</li> <li>如果 toString 方法调用之后的返回值是一个基本数据类型，就返回这个值，</li> <li>如果 toString 方法调用之后的返回值是一个复杂数据类型，就报一个错误。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'1'</span>
<span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'[object Object]';</span>
<span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'1';</span>
<span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 Uncaught TypeError: Cannot convert object to primitive value</span>
</code></pre></div><p>拓展：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">]</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 9</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">valueOf</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
	<span class="token punctuation">}</span>
	arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">'toString'</span>
	<span class="token punctuation">}</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="其他值到数字值的转换规则"><a href="#其他值到数字值的转换规则" class="header-anchor">#</a> 其他值到数字值的转换规则？</h2> <p>有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</p> <p>（1）Undefined 类型的值转换为 NaN。</p> <p>（2）Null 类型的值转换为 0。</p> <p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p> <p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p> <p>（5）Symbol 类型的值不能转换为数字，会报错。</p> <p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。为了将值转换为相应的基本类型值，抽象操作<code>ToPrimitive</code> 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。<strong>如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换</strong>。<strong>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误</strong>。</p> <h2 id="其他值到布尔类型的值的转换规则"><a href="#其他值到布尔类型的值的转换规则" class="header-anchor">#</a> 其他值到布尔类型的值的转换规则</h2> <p>ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。</p> <p>以下这些是假值：</p> <ul><li>undefined</li> <li>null</li> <li>false</li> <li>+0、-0 和 NaN</li> <li>&quot;&quot;</li></ul> <p>假值的布尔强制类型转换结果为 false。从逻辑上说，<strong>假值列表以外的都应该是真值</strong>。</p> <h2 id="和-和-的-的-valueof-和-和-tostring-的结果是什么"><a href="#和-和-的-的-valueof-和-和-tostring-的结果是什么" class="header-anchor">#</a> {} 和 和 [] 的 的 valueOf 和 和 toString 的结果是什么</h2> <p><code>{}</code> 的 <code>valueOf</code> 结果为 {} ，<code>toString</code> 的结果为 <code>&quot;[object Object]&quot;</code></p> <p><code>[]</code> 的<code>valueOf</code> 结果为 [] ，<code>toString</code> 的结果为 <code>&quot;&quot;</code></p> <h2 id="什么是假值对象"><a href="#什么是假值对象" class="header-anchor">#</a> 什么是假值对象</h2> <p>浏览器在某些特定情况下，<strong>在常规 JavaScript 语法基础上自己创建了一些外来值</strong>，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将<strong>它们强制类型转换为布尔值时结果为 false</strong> 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用</p> <h2 id="操作符的作用"><a href="#操作符的作用" class="header-anchor">#</a> ~ 操作符的作用</h2> <p>~ 返回 2 的<strong>补码</strong>，并且 ~ 会<strong>将数字转换为 32 位整数</strong>，因此我们可以使用 ~ 来进行取整操作。<strong>~x 大致等同于 -(x+1)</strong></p> <h2 id="解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字-它们之间的区别是什么"><a href="#解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字-它们之间的区别是什么" class="header-anchor">#</a> 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么</h2> <p>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而<strong>转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN</strong></p> <h2 id="操作符什么时候用于字符串的拼接"><a href="#操作符什么时候用于字符串的拼接" class="header-anchor">#</a> + 操作符什么时候用于字符串的拼接？</h2> <p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用<code>ToPrimitive</code> 抽象操作，该抽象操作再调用<code>[[DefaultValue]]</code>，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。那么<strong>对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</strong>。</p> <h2 id="什么情况下会发生布尔值的隐式强制类型转换"><a href="#什么情况下会发生布尔值的隐式强制类型转换" class="header-anchor">#</a> 什么情况下会发生布尔值的隐式强制类型转换</h2> <p>（1） if (..) 语句中的条件判断表达式。</p> <p>（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</p> <p>（3） while (..) 和 do..while(..) 循环中的条件判断表达式。</p> <p>（4） ? : 中的条件判断表达式。</p> <p>（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）</p> <h2 id="和-和-操作符的返回值"><a href="#和-和-操作符的返回值" class="header-anchor">#</a> || 和 和 &amp;&amp; 操作符的返回值</h2> <p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。<strong>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</strong></p> <h2 id="symbol-值的强制类型转换"><a href="#symbol-值的强制类型转换" class="header-anchor">#</a> Symbol 值的强制类型转换</h2> <p>ES6 允许<strong>从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误</strong>。Symbol 值<strong>不能够被强制类型转换为数字</strong>（显式和隐式都会产生错误），但可<strong>以被强制类型转换为布尔值（显式和隐式结果都是 true ）</strong>。</p> <h2 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="header-anchor">#</a> == 操作符的强制类型转换规则</h2> <p>（1）字符串和数字之间的相等比较，将<strong>字符串转换为数字之后</strong>再进行比较。</p> <p>（2）其他类型和布尔类型之间的相等比较，<strong>先将布尔值转换为数字后</strong>，再应用其他规则进行比较。</p> <p>（3）null 和 undefined 之间的相等比较，<strong>结果为真</strong>。其他值和它们进行比较都返回假值。</p> <p>（4）对象和非对象之间的相等比较，<strong>对象先调用 ToPrimitive 抽象操作后</strong>，再进行比较。</p> <p>（5）<strong>如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）</strong>。</p> <p>（6）如果两个操作值都是对象，则<strong>比较它们是不是指向同一个对象</strong>。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p> <h2 id="如何将字符串转化为数字-例如-12-3b"><a href="#如何将字符串转化为数字-例如-12-3b" class="header-anchor">#</a> 如何将字符串转化为数字，例如 '12.3b'</h2> <p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p> <p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p> <p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p> <p>（4）使用 + 操作符的隐式转换。</p> <h2 id="如何将浮点数点左边的数每三位添加一个逗号-如何将浮点数点左边的数每三位添加一个逗号-如-12000000-11-转化为-转化为-12-000-000-11"><a href="#如何将浮点数点左边的数每三位添加一个逗号-如何将浮点数点左边的数每三位添加一个逗号-如-12000000-11-转化为-转化为-12-000-000-11" class="header-anchor">#</a> 如何将浮点数点左边的数每三位添加一个逗号 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为 转化为 12,000,000.11</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> number <span class="token operator">&amp;&amp;</span> number<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?!^)(?=(\d{3})+\.)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="常用正则表达式"><a href="#常用正则表达式" class="header-anchor">#</a> 常用正则表达式</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// （1）匹配 16 进制颜色值</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token comment">// （3）匹配 qq 号</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[1-9][0-9]{4,10}$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token comment">// （4）手机号码正则</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^1[34578]\d{9}$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token comment">// （5）用户名正则</span>
<span class="token keyword">var</span> regex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^[a-zA-Z\$][a-zA-Z0-9_\$]{4,16}$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
</code></pre></div><h2 id="如何实现数组的随机排序"><a href="#如何实现数组的随机排序" class="header-anchor">#</a> 如何实现数组的随机排序</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span>
<span class="token keyword">function</span> <span class="token function">randomSort</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0.5</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span>
<span class="token comment">// （2）随机从原数组抽取一个元素，加入到新数组</span>
<span class="token keyword">function</span> <span class="token function">randomSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> randomIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>randomIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// （3）随机交换数组内的元素（洗牌算法类似）</span>
<span class="token keyword">function</span> <span class="token function">randomSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> index<span class="token punctuation">,</span>
    randomIndex<span class="token punctuation">,</span>
    temp<span class="token punctuation">,</span>
    len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    randomIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> index<span class="token punctuation">;</span>
    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">randomSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">||</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> randomIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> index<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="javascript-创建对象的几种方式"><a href="#javascript-创建对象的几种方式" class="header-anchor">#</a> javascript 创建对象的几种方式</h2> <p>Object 构造函数创建</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nike&quot;</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
</code></pre></div><p>使用对象字面量表示法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//相当于 var Person = new Object();</span>
<span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>
	name<span class="token operator">:</span> <span class="token string">'Nike'</span><span class="token punctuation">;</span>
	age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：</p> <p>（1）第一种是<strong>工厂模式</strong>，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就创建出来的对象无法和某个类型联系起来，<strong>它只是简单的封装了复用代码，而没有建立起对象和类型间的关系</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Nike&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;teacher&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Arvin&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&quot;student&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（2）第二种是<strong>构造函数模式</strong>。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所<strong>创建的对象和构造函数建立起了联系</strong>，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，<strong>造成了不必要的函数对象的创建</strong>，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nike&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;teacher&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Arvin&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">&quot;student&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（3）第三种模式是<strong>原型模式</strong>，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是<strong>没有办法通过传入参数来初始化值</strong>，另一个是如果存在一个引用类型如 Array 这样的值，那么<strong>所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nike&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>jbo <span class="token operator">=</span> <span class="token string">&quot;teacher&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（4）第四种模式是<strong>组合使用构造函数模式和原型模式</strong>，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为<strong>使用了两种不同的模式，所以对于代码的封装性不够好</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
	constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
	<span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nike'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'teacher'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（5）第五种模式是<strong>动态原型模式</strong>，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。<strong>这一种方式很好地对上面的混合模式进行了封装</strong>。</p> <p>（6）第六种模式是<strong>寄生构造函数模式</strong>，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是<strong>基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别</strong></p> <h2 id="javascript-继承的几种实现方式"><a href="#javascript-继承的几种实现方式" class="header-anchor">#</a> JavaScript 继承的几种实现方式</h2> <p>我了解的 js 中实现继承的几种方式有：</p> <p>（1）第一种是<strong>以原型链的方式来实现继承</strong>，但是这种实现方式存在的缺点是，在包含有引用型的数据时，会被所有的实例对象所共享，<strong>容易造成修改的混乱</strong>。还有就是<strong>在创建子类型的时不能向超类型传递参数</strong>。</p> <p>（2）第二种方式是使用<strong>借用构造函数</strong>的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是<strong>无法实现函数方法的复用</strong>，并且<strong>超类型原型定义的方法子类型也没有办法访问到</strong>。</p> <p>（3）第三种方式是<strong>组合继承</strong>，组合继承是将<strong>原型链和借用构造函数</strong>组合起来使用的一种方式。通过<strong>借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承</strong>。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以<strong>调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性</strong>。</p> <p>（4）第四种方式是<strong>原型式继承</strong>，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 <strong>Object.create</strong>() 方法就是原型式继承的实现。缺点与原型链方式相同。</p> <p>（5）第五种方式是<strong>寄生式继承</strong>，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p> <p>（6）第六种方式是<strong>寄生式组合继承</strong>，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是<strong>使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性</strong></p> <hr> <p>一、原型链继承</p> <p>缺点：</p> <ol><li>引用类型的属性被所有实例共享</li> <li>在创建 Child 的实例时，不能向 Parent 传参</li></ol> <p>二、借用构造函数(经典继承)</p> <p>优点：</p> <ol><li>避免了引用类型的属性被所有实例共享</li> <li>可以在 Child 中向 Parent 传参
缺点：</li> <li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ol> <p>三、组合继承</p> <p>优点：</p> <ol><li>融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</li></ol> <p>四、原型式继承</p> <p>缺点：</p> <ol><li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li></ol> <p>五、寄生式继承</p> <p>缺点：</p> <ol><li>跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</li></ol> <p>六、寄生组合式继承</p> <p>优点：</p> <ol><li>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。</li> <li>与此同时，原型链还能保持不变；</li> <li>因此，还能够正常使用 instanceof 和 isPrototypeOf。</li> <li>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式</li></ol> <h2 id="寄生式组合继承的实现"><a href="#寄生式组合继承的实现" class="header-anchor">#</a> 寄生式组合继承的实现</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;My name is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Student<span class="token punctuation">;</span>
<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayMyGrade</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;My grade is &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="es5-es6-的继承除了写法以外还有什么区别"><a href="#es5-es6-的继承除了写法以外还有什么区别" class="header-anchor">#</a> ES5/ES6 的继承除了写法以外还有什么区别？</h2> <ol><li>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）.</li> <li>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。</li> <li>ES5 的继承时通过原型或构造函数机制来实现。</li> <li>ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。</li> <li>子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</li> <li>注意 super 关键字指代父类的实例，即父类的 this 对象。</li> <li>注意：在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</li></ol> <p><strong>function 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错</span>
</code></pre></div><p><strong>class 声明内部会启用严格模式</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 引用一个未声明的变量</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  baz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token comment">// it's ok</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fol <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token comment">// ReferenceError: fol is not defined</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>class 的所有方法（包括静态方法和实例方法）都是不可枚举的。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 引用一个未声明的变量</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Bar<span class="token punctuation">.</span><span class="token function-variable function">answer</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> barKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ['answer']</span>
<span class="token keyword">const</span> barProtoKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ['print']</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">answer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> fooKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// []</span>
<span class="token keyword">const</span> fooProtoKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// []</span>
</code></pre></div><p><strong>class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 new 来调用</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> barPrint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bar<span class="token punctuation">.</span>print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// it's ok</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fooPrint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo<span class="token punctuation">.</span>print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: foo.print is not a constructor</span>
<span class="token comment">// 必须使用 new 调用 class。</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// it's ok</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span>
<span class="token comment">// class 内部无法重写类名。</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Bar <span class="token operator">=</span> <span class="token string">&quot;Baz&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">// it's ok this.bar = 42;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Bar: 'Baz'</span>
<span class="token comment">// bar: Bar {bar: 42}</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    Foo <span class="token operator">=</span> <span class="token string">&quot;Fol&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">// TypeError: Assignment to constant variable</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Foo <span class="token operator">=</span> <span class="token string">&quot;Fol&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// it's ok</span>
</code></pre></div><h2 id="javascript-的作用域链"><a href="#javascript-的作用域链" class="header-anchor">#</a> Javascript 的作用域链？</h2> <p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p> <p>作用域链的本质上是一个<strong>指向变量对象的指针列表</strong>。变量对象是一个包含了执行环境中所有变量和函数的对象。<strong>作用域链的前端始终都是当前执行上下文的变量对象</strong>。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p> <p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。作用域链的创建过程跟执行上下文的建立有关....</p> <h2 id="什么是原型链"><a href="#什么是原型链" class="header-anchor">#</a> 什么是原型链？</h2> <p>通过一个对象的<strong>proto</strong>可以找到它的原型对象，原型对象也是一个对象，就可以通过原型对象的<strong>proto</strong>，最后找到了我们的 Object.prototype,从实例的原型对象开始一直到 Object.prototype 就是我们的原型链</p> <h2 id="谈谈-this-对象的理解。"><a href="#谈谈-this-对象的理解。" class="header-anchor">#</a> 谈谈 This 对象的理解。</h2> <p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断</p> <p>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象</p> <p>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象</p> <p>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象</p> <p>第四种是 <strong>apply 、 call 和 bind 调用模</strong>式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变</p> <p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p> <h2 id="如何正确判断与使用-this-箭头函数有没有自己的-this-指针"><a href="#如何正确判断与使用-this-箭头函数有没有自己的-this-指针" class="header-anchor">#</a> 如何正确判断与使用 this，箭头函数有没有自己的 this 指针</h2> <div class="custom-block tip"><p class="custom-block-title">this 的四种绑定</p> <p>this 有四种绑定规则，默认绑定、隐式绑定、显示绑定、new 绑定，优先级由低到高在 ECMA 内，this 会调用原生方法 ResolveThisBinding()  原生方法，该方法使用正在运行的执行上下文的 LexicalEnvironment  确定关键字 this 的绑定可以简单总结为：谁直接调用产生这个 this 指针的函数，this 就指向谁</p></div> <ul><li>this 在一般模式下指向全局对象；严格模式下 this 默认为 undefined</li> <li><strong>箭头函数没有自己的 this 指针，它的 this 绑定取决于外层（函数或全局）作用域）</strong></li> <li>call，apply，bind 在非箭头函数下修改 this 值（箭头函数下只传递参数），不管 call ,bind, apply 多少次，函数的 this 永远由第一次的决定</li></ul> <h2 id="eval-是做什么的"><a href="#eval-是做什么的" class="header-anchor">#</a> eval 是做什么的</h2> <p>它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用 eval，不安全，非常耗性能（2 次，一次解析成 js 语句，一次执行）</p> <h2 id="什么是-dom-和-和-bom"><a href="#什么是-dom-和-和-bom" class="header-anchor">#</a> 什么是 DOM 和 和 BOM</h2> <p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了<strong>处理网页内容的方法和接口</strong>。BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。<strong>BOM 的核心是 window</strong>，而 window 对象具有双重角色，它<strong>既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象</strong>。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<strong>window 对象含有 location 对象、navigator 对象、screen 对象等子对象</strong>，并且 <strong>DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象</strong>。</p> <h2 id="写一个通用的事件侦听器函数。"><a href="#写一个通用的事件侦听器函数。" class="header-anchor">#</a> 写一个通用的事件侦听器函数。</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> EventUtils <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 视能力分别使用 dom0||dom2||IE 方式 来绑定事件</span>
  <span class="token comment">// 添加事件</span>
  <span class="token function-variable function">addEvent</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">[</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> type<span class="token punctuation">]</span> <span class="token operator">=</span> handler<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 移除事件</span>
  <span class="token function-variable function">removeEvent</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> type<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>removeEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>detachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">.</span><span class="token function">detachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      element<span class="token punctuation">[</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 获取事件目标</span>
  <span class="token function-variable function">getTarget</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> event<span class="token punctuation">.</span>target <span class="token operator">||</span> event<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span>
  <span class="token function-variable function">getEvent</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> event <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span>
  <span class="token function-variable function">stopPropagation</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>stopPropagation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span>cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 取消事件的默认行为</span>
  <span class="token function-variable function">preventDefault</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>preventDefault<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="事件是什么-ie-与火狐的事件机制有什么区别"><a href="#事件是什么-ie-与火狐的事件机制有什么区别" class="header-anchor">#</a> 事件是什么？IE 与火狐的事件机制有什么区别？</h2> <p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。<strong>事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）</strong>。</p> <p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p> <p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble =true;</p> <h2 id="_3-种事件模型是什么"><a href="#_3-种事件模型是什么" class="header-anchor">#</a> 3 种事件模型是什么？</h2> <p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p> <p>第一种事件模型是最早的 <strong>DOM0 级模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p> <p>第二种事件模型是 <strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，<strong>事件处理阶段，和事件冒泡阶段</strong>。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p> <p>第三种是 <strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是<strong>事件捕获阶段</strong>。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。<strong>后面两个阶段和 IE 事件模型的两个阶段相同</strong>。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p> <h2 id="事件委托是什么"><a href="#事件委托是什么" class="header-anchor">#</a> 事件委托是什么</h2> <p>利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p> <p>1、那什么样的事件可以用事件委托，什么样的事件不可以用呢？</p> <ul><li>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</li> <li>值得注意的是，mouseover 和 mouseout 虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</li> <li>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说 focus，blur 之类的，本身就没用冒泡的特性，自然就不用事件委托了。</li></ul> <p>2、为什么要用事件委托</p> <p>1.提高性能</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>苹果<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>香蕉<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>凤梨<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token comment">// good</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;ul&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> target <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> <span class="token string">&quot;LI&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// bad</span>
document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>2.新添加的元素还会有之前的事件。</p> <p>3、事件冒泡与事件委托的对比</p> <ul><li>事件冒泡：box 内部无论是什么元素，点击后都会触发 box 的点击事件</li> <li>事件委托：可以对 box 内部的元素进行筛选
4、事件委托怎么取索引？</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ul<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>aaaaaaaa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>事件委托了 点击当前，如何获取 这个点击的下标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>cccccccc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;ul&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    oUl<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ev</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
      <span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;li&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> that <span class="token operator">=</span> target<span class="token punctuation">;</span>
        <span class="token keyword">var</span> index<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;我的下标是第&quot;</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">&quot;个&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>拓展：</p> <p>键盘事件：keydown keypress keyup
鼠标事件：mousedown mouseup mousemove mouseout mouseover</p> <p>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把<strong>子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理</strong>。使用事件代理我们可以不<strong>必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗</strong>。<strong>并且使用事件代理我们还可以实现事件的动态绑定</strong>，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理</p> <h2 id="_1-2-3-map-parseint-答案是多少"><a href="#_1-2-3-map-parseint-答案是多少" class="header-anchor">#</a> [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少</h2> <p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;因为字符串的值不能大于基数，<strong>因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1</strong></p> <h2 id="什么是闭包-为什么要用它"><a href="#什么是闭包-为什么要用它" class="header-anchor">#</a> 什么是闭包，为什么要用它</h2> <p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是<strong>在一个函数内创建另一个函数</strong>，创建的函数可以访问到当前函数的局部变量。闭包有两个常用的用途。</p> <p>闭包的第一个用途是<strong>使我们在函数外部能够访问到函数内部的变量</strong>。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p> <p>函数的另一个用途是<strong>使已经运行结束的函数上下文中的变量对象继续留在内存中</strong>，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。其实<strong>闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理</strong></p> <p>具体有以下几个应用场景：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//经典案例：斐波那契数列 ：1, 1, 2, 3, 5, 8, 13, … 1</span>
<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fib <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> arr<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//通过闭包特性，模拟私有变量</span>
<span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> page <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>auther <span class="token operator">=</span> <span class="token string">&quot;okaychen&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">_page</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>auther<span class="token punctuation">;</span> <span class="token comment">// &quot;okaychen&quot;</span>
a<span class="token punctuation">.</span><span class="token function">_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>
a<span class="token punctuation">.</span>page<span class="token punctuation">;</span> <span class="token comment">// undefined</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 经典老问题，输出结果：6 6 6 6 6</span>
<span class="token comment">// js执行的时候首先会先执行主线程,异步相关的(setTimeout)会存到异步队列里,</span>
<span class="token comment">// 当主线程执行完毕开始执行异步队列,主线程执行完毕后,此时 i 的值为 6,</span>
<span class="token comment">// 所以在执行异步队列的时候,打印出来的都是 6</span>

<span class="token comment">// 利用闭包来取正确值</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>
    i <span class="token operator">*</span> <span class="token number">1000</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方案二：或者使用ES6的let，这里let本质也是形成了一个闭包</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="你对闭包的理解-优缺点"><a href="#你对闭包的理解-优缺点" class="header-anchor">#</a> 你对闭包的理解？优缺点？</h2> <p>概念：闭包就是能够读取其他函数内部变量的函数。</p> <p>三大特性：</p> <ul><li>函数嵌套函数。</li> <li>函数内部可以引用外部的参数和变量。</li> <li>参数和变量不会被垃圾回收机制回收。</li></ul> <p>优点：</p> <ul><li>希望一个变量长期存储在内存中。</li> <li>避免全局变量的污染。</li> <li>私有成员的存在。</li></ul> <p>缺点：</p> <ul><li>常驻内存，增加内存使用量。</li> <li>使用不当会很容易造成内存泄露。</li></ul> <p>示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;jack&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> inner<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jack</span>
<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token string">&quot;xiaoming&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi! xiaoming</span>
</code></pre></div><p>虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。
但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。</p> <p>解析：</p> <p>由于在 ECMA2015 中，只有函数才能分割作用域，函数内部可以访问当前作用域的变量，但是外部无法访问函数内部的变量，所以闭包可以理解成“定义在一个函数内部的函数，外部可以通过内部返回的函数访问内部函数的变量“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p> <h2 id="javascript-的-代码中的-use-strict"><a href="#javascript-的-代码中的-use-strict" class="header-anchor">#</a> javascript 的 代码中的 &quot;use strict&quot;;</h2> <p>相关知识点：</p> <p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立&quot;严格模式&quot;的目的，主要有以下几个：</p> <ul><li><p>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</p></li> <li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p></li> <li><p>提高编译器效率，增加运行速度；</p></li> <li><p>为未来新版本的 Javascript 做好铺垫。</p></li> <li><p>区别：</p></li> <li><p>禁止使用 with 语句。</p></li> <li><p>禁止 this 关键字指向全局对象。</p></li> <li><p>对象不能有重名的属性。</p></li> <li><p>回答：</p></li></ul> <p>use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了<strong>消除代码使用中的一些不安全的使用方式</strong>，也是为了<strong>消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为</strong>。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</p> <h2 id="如何判断一个对象是否属于某个类"><a href="#如何判断一个对象是否属于某个类" class="header-anchor">#</a> 如何判断一个对象是否属于某个类？</h2> <p>第一种方式是使用 <strong>instanceof</strong> 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p> <p>第二种方式可以通过对象的 <strong>constructor 属性</strong>来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p> <p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用** Object.prototype.toString()** 方法来打印对象的<code>[[Class]]</code> 属性来进行判断。</p> <h2 id="instanceof-的作用"><a href="#instanceof-的作用" class="header-anchor">#</a> instanceof 的作用？</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。// 实现：</span>
<span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 获取对象的原型</span>
    prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 获取构造函数的 prototype 对象</span>
  <span class="token comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="new-操作符具体干了什么呢-如何实现"><a href="#new-操作符具体干了什么呢-如何实现" class="header-anchor">#</a> new 操作符具体干了什么呢？如何实现</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// （1）首先创建了一个新的空对象// （2）设置原型，将对象的原型设置为函数的 prototype对象。// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span>
<span class="token comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span>
<span class="token comment">// 实现:</span>
<span class="token keyword">function</span> <span class="token function">objectFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    constructor <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">,</span>
    result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 参数判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;type error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span>
  newObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将 this 指向新建对象，并执行函数</span>
  result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObject<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断返回对象</span>
  <span class="token keyword">let</span> flag <span class="token operator">=</span>
    result <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断返回结果</span>
  <span class="token keyword">return</span> flag <span class="token operator">?</span> result <span class="token operator">:</span> newObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用方法// objectFactory(构造函数, 初始化参数);</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// new构造函数的模拟实现</span>
<span class="token keyword">const</span> <span class="token function-variable function">_new</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> _constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 使用中间函数来维护原型关系</span>
  <span class="token keyword">const</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">_constructor</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">_constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">?</span> res <span class="token operator">||</span> obj <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="javascript-中-有一个函数-执行时对象查找时-永远不会去查找原型"><a href="#javascript-中-有一个函数-执行时对象查找时-永远不会去查找原型" class="header-anchor">#</a> Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型</h2> <p>hasOwnProperty 所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</p> <h2 id="对于-json-的了解"><a href="#对于-json-的了解" class="header-anchor">#</a> 对于 JSON 的了解</h2> <p>相关知识点：</p> <p>JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。<strong>文本可以被任何编程语言读取及作为数据格式传递</strong>。</p> <p>回答：</p> <p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 <strong>JSON 和 js 中的对象不是一回事</strong>，<strong>JSON 中对象格式更加严格</strong>，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此<strong>大多数的 js 对象是不符合 JSON 对象的格式的</strong>。在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是<strong>JSON.stringify 函数</strong>，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。另一个函数 <strong>JSON.parse()</strong> 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">.</span>style<span class="token punctuation">.</span>outline <span class="token operator">=</span>
    <span class="token string">&quot;1px solid #&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>能解释一下这段代码的意 能解释一下这段代码的意思吗？</p> <p>（1）选取页面所有 DOM 元素。在浏览器的控制台中可以<strong>使用$$()方法来获取页面中相应的元素</strong>，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</p> <p>（2）循环遍历 DOM 元素</p> <p>（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</p> <p>（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</p> <h2 id="js-延迟加载的方式有哪些"><a href="#js-延迟加载的方式有哪些" class="header-anchor">#</a> js 延迟加载的方式有哪些</h2> <p>相关知识点：</p> <p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p> <p>一般有以下几种方式：</p> <ul><li>defer 属性</li> <li>async 属性</li> <li>动态创建 DOM 方式</li> <li>使用 setTimeout 延迟方法</li> <li>让 JS 最后加载</li></ul> <p>回答：</p> <p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。我了解到的几种方式是：</p> <p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p> <p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p> <p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p> <p>第四种方式是<strong>动态创建 DOM 标签的方式</strong>，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p> <h2 id="ajax-是什么-个-如何创建一个-ajax"><a href="#ajax-是什么-个-如何创建一个-ajax" class="header-anchor">#</a> Ajax 是什么? 个 如何创建一个 Ajax？</h2> <p>相关知识点：</p> <p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 AsynchronousJavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。具体来说，AJAX 包括以下几个步骤。</p> <ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li> <li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li> <li>3.设置响应 HTTP 请求状态变化的函数</li> <li>4.发送 HTTP 请求</li> <li>5.获取异步调用返回的数据</li> <li>6.使用 JavaScript 和 DOM 实现局部刷新</li> <li>一般实现：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">SERVER_URL</span> <span class="token operator">=</span> <span class="token string">&quot;/server&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建 Http 请求</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> <span class="token constant">SERVER_URL</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置状态监听函数</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 当请求成功时</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 设置请求失败时的监听函数</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 设置请求头信息</span>
xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">&quot;json&quot;</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Accept&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 发送 Http 请求 xhr.send(null);</span>
<span class="token comment">// promise 封装实现：</span>
<span class="token keyword">function</span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个 promise 对象</span>
  <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 新建一个 http 请求</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置状态的监听函数</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token comment">// 当请求成功或失败时，改变 promise 的状态</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置错误监听函数</span>
    xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置响应的数据类型</span>
    xhr<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">&quot;json&quot;</span><span class="token punctuation">;</span>
    <span class="token comment">// 设置请求头信息</span>
    xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Accept&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送 http 请求</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>回答：</p> <p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。创建一个 ajax 有这样几个步骤</p> <p>首先是创建一个 XMLHttpRequest 对象。然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 <strong>5 个状态</strong>，当它的状态变化时会触发 onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p> <h2 id="ajax-的概念-手写一下原生实现的思路"><a href="#ajax-的概念-手写一下原生实现的思路" class="header-anchor">#</a> Ajax 的概念，手写一下原生实现的思路</h2> <p>首先需要知道的是 Ajax 主要是通过 XMLHttpRequest  对象向服务器提出请求并处理响应，进行页面的局部更新，XMLHttpRequest 对象常用的三大属性： onreadystatechange  ，readyState  ， status</p> <table><thead><tr><th>Tables</th> <th style="text-align:center;">Are</th></tr></thead> <tbody><tr><td>onreadystatechange</td> <td style="text-align:center;">readyState  属性的值发生改变，就会触发 readystatechange 事件</td></tr> <tr><td>readyState</td> <td style="text-align:center;">存有 XMLHttpRequest 的状态 0：请求未初始化 1：服务器连接已建立 2：请求已接收 3：请求处理中 4：请求已完成，且响应已就绪</td></tr> <tr><td>status</td> <td style="text-align:center;">status  属性为只读属性，表示本次请求所得到的 HTTP 状态码 200, OK，访问正常 301, Moved Permanently，永久移动 302,Move temporarily，暂时移动 304, Not Modified，未修改 307,Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误</td></tr></tbody></table> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Ajax原生简单实现 1</span>
<span class="token keyword">let</span> xhr <span class="token operator">=</span> XMLHttpRequest<span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/EndPonint&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="fetch-和-xmlhttprequest-的区别在哪"><a href="#fetch-和-xmlhttprequest-的区别在哪" class="header-anchor">#</a> fetch 和 XMLHttpRequest 的区别在哪</h2> <p>XMLHttpRequest 历史悠久，因为其 API 设计其实并不是很好，输入，输出，状态都在同一个接口管理，容易写出非常非常混乱的代码，Fetch API 采取了一种新规范，用来取代 XMLHttpReques，Fetch 更现代化，更接近于未来，内部使用了 Promise，用起来也更加简洁</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'./api/demo.json'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="谈一谈浏览器的缓存机制"><a href="#谈一谈浏览器的缓存机制" class="header-anchor">#</a> 谈一谈浏览器的缓存机制</h2> <p>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。<strong>强缓存策略可以通过两种方式来设置</strong>，分别是 http 头信息中的 <strong>Expires 属性</strong>和<strong>Cache-Control 属性</strong>。服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过<strong>设置 max-age 来指定资源能够被缓存的时间的大小</strong>，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires 来说，这种方式更加有效一些。常用的还有比如 <strong>private</strong> ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 <strong>no-store</strong> ，用来指定资源不能够被缓存，<strong>no-cache</strong>代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<strong>Cache-Control 的优先级要高于 Expires</strong> 。</p> <p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。</p> <p>服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间<strong>Last-Modified 属性来指出资源最后一次修改的时间</strong>，当浏览器下一次发起请求时，会在请求头中添加一个 <strong>If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值</strong>。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 <strong>Last-Modified 标注的最后修改时间只能精确到秒级</strong>，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。因为 <strong>Last-Modified 的这种可能发生的不准确性</strong>，http 中提供了另外一种方式，那就是 <strong>Etag 属性</strong>。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 <strong>If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值</strong>。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，<strong>比 Last-Modified 的方式更加精确</strong>。</p> <p>当 Last-Modified 和 Etag 属性同时出现的时候，<strong>Etag 的优先级更高</strong>。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此<strong>在考虑负载平衡时，最好不要设置 Etag 属性</strong>。<strong>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求</strong>。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p> <h2 id="ajax-解决浏览器缓存问题"><a href="#ajax-解决浏览器缓存问题" class="header-anchor">#</a> Ajax 解决浏览器缓存问题</h2> <ul><li>在 ajax 发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。</code></li> <li>在 ajax 发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code></li> <li>在 URL 后面加上一个随机数：<code>&quot;fresh=&quot; + Math.random();</code></li> <li>在 URL 后面加上时间戳：<code>&quot;nowtime=&quot; + new Date().getTime()</code></li> <li>如果是使用 jQuery，直接这样就可以了<code>$.ajaxSetup({cache:false})</code>。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</li></ul> <h2 id="同步和异步的区别"><a href="#同步和异步的区别" class="header-anchor">#</a> 同步和异步的区别？</h2> <p>相关知识点：</p> <p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p> <p>回答：</p> <p>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p> <h2 id="什么是浏览器的同源政策"><a href="#什么是浏览器的同源政策" class="header-anchor">#</a> 什么是浏览器的同源政策</h2> <p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。同源政策主要限制了三个方面:</p> <ul><li>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li> <li>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li> <li>第三个是当前域下 ajax 无法发送跨域请求。</li></ul> <p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，<strong>对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作</strong>。</p> <h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="header-anchor">#</a> 如何解决跨域问题？</h2> <p>相关知识点：</p> <p>之所以需要跨域，是因为浏览器同源策略的约束，面对不同源的请求，我们无法完成，这时候就需要用到跨域。同源策略拦截的是跨源请求，原因：CORS 缺少<code>Access-Control-Allow-Origin</code>  头</p> <ul><li>通过 jsonp 跨域</li> <li>document.domain + iframe 跨域</li> <li>location.hash + iframe</li> <li>window.name + iframe 跨域</li> <li>postMessage 跨域</li> <li>跨域资源共享（CORS)</li> <li>nginx 代理跨域</li> <li>nodejs 中间件代理跨域</li> <li>WebSocket 协议跨域</li></ul> <p>回答：</p> <p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p> <p>首先我们如果只是想要实现<strong>主域名下的不同子域名的跨域操作</strong>，我们可以使用设置 <strong>document.domain</strong> 来解决。</p> <p>（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</p> <p>**
如果是想要解决<strong>不同跨域窗口间的通信问题</strong>，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 <strong>location.hash</strong> 或者 <strong>window.name</strong> 或者 **postMessage** 来解决。</p> <p>（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p> <p>（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p> <p>（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p> <p>如果是像<strong>解决 ajax 无法提交跨域请求的问题</strong>，我们可以使用 <strong>jsonp、cors、websocket 协议、服务器代理</strong>来解决问题。</p> <p>（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求,如果想传给后台一个 json 格式的数据,此时问题就来了,浏览器会报一个 http 状态码 415 错误，请求格式不正确;JSONP 本质是一种代码注入，存在安全问题</p> <p>（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p> <p>（7）使用 websocket 协议，这个协议没有同源限制。</p> <p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p> <h2 id="iframe-跨域通信和不跨域通信"><a href="#iframe-跨域通信和不跨域通信" class="header-anchor">#</a> iframe 跨域通信和不跨域通信</h2> <p><strong>不跨域通信</strong></p> <p>主页面</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span>
      <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myIframe<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>iframe<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>flexible.html<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>500px<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>500px<span class="token punctuation">&quot;</span></span>
    <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">function</span> <span class="token function">fullscreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子页面 flexible.html</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    我是子页面
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token comment">// window.parent.fullScreens()</span>
    <span class="token keyword">function</span> <span class="token function">showalert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>1、主页面要是想要调取子页面的 showalert 方法</p> <p><code>myIframe.window.showalert();</code></p> <p>2、子页面要掉主页面的 fullscreen 方法</p> <p><code>window.parent.fullScreens();</code></p> <p>3、js 在 iframe 子页面获取父页面元素:</p> <p><code>window.parent.document.getElementById(&quot;元素id&quot;);</code></p> <p>4、js 在父页面获取 iframe 子页面元素代码如下:</p> <p><code>window.frames[&quot;iframe_ID&quot;].document.getElementById(&quot;元素id&quot;);</code></p> <p><strong>跨域通信</strong></p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener noreferrer">用<code>postMessage</code>(官方用法）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>子页面</p> <p>window.parent.postMessage(&quot;hello&quot;, &quot;http://127.0.0.1:8089&quot;);
父页面接收</p> <p>window.addEventListener(&quot;message&quot;, function(event) {
alert(123);
});</p> <h2 id="有关-jsonp"><a href="#有关-jsonp" class="header-anchor">#</a> 有关 JSONP</h2> <p>JSONP 主要是因为 script  标签的 src  属性不被同源策略所约束，同时在没有阻塞的情况下资源加载到页面后会立即执行</p> <p>缺点：</p> <ul><li>JSONP 只支持 get 请求而不支持 post 请求，如果想传给后台一个 json 格式的数据,此时问题就来了,浏览器会报一个 http 状态码 415 错误，请求格式不正确</li> <li>JSONP 本质是一种代码注入，存在安全问题</li></ul> <p>实际项目中 JSONP 通常用来获取 json  格式的数据，这时候前后端通常约定一个参数 callback ，该参数的值，就是处理返回数据的函数名称</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">alert</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> _script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
_script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:8888/jsonp?callback=f'</span>
document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendCild</span><span class="token punctuation">(</span>_script<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//node处理</span>
<span class="token keyword">var</span> query <span class="token operator">=</span> _scr<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
<span class="token keyword">var</span> params <span class="token operator">=</span> qs<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

f <span class="token operator">=</span> params<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>

res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span><span class="token string">'text/javascript'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>f <span class="token operator">+</span> <span class="token string">&quot;({name:'hello world'})&quot;</span><span class="token punctuation">)</span>
res<span class="token punctuation">.</span>end
<span class="token comment">//php处理(注意输出格式)</span>
$data <span class="token operator">=</span> <span class="token function">array</span><span class="token punctuation">(</span>
<span class="token string">'rand'</span> <span class="token operator">=&gt;</span> $_GET<span class="token punctuation">[</span><span class="token string">'random'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token string">'msg'</span> <span class="token operator">=&gt;</span> <span class="token string">'Success'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

echo $_GET<span class="token punctuation">[</span><span class="token string">'callback'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token string">'('</span><span class="token punctuation">.</span><span class="token function">json_encode</span><span class="token punctuation">(</span>$data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">')'</span><span class="token punctuation">;</span>
</code></pre></div><p>补充：cors 是一种现代浏览器支持跨域资源请求的一种方式，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'Access-Control-Allow-Origin'</span><span class="token operator">:</span><span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token comment">// *通配，或者安全考虑替换为指定域名</span>
</code></pre></div><h2 id="jsonp-优缺点"><a href="#jsonp-优缺点" class="header-anchor">#</a> jsonp 优缺点？</h2> <ol><li>优点</li></ol> <ul><li>它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略；</li> <li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持</li> <li>在请求完毕后可以通过调用 callback 的方式回传结果。将回调方法的权限给了调用方。这个就相当于将 controller 层和 view 层终于分 开了。我提供的 jsonp 服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续 view 操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个 jsonp 服务。</li></ul> <ol><li>缺点</li></ol> <ul><li>它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求</li> <li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题。</li> <li>jsonp 在调用失败的时候不会返回各种 HTTP 状态码。</li> <li>缺点是安全性。万一假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。那么结果是什么？所有调用这个 jsonp 的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用 jsonp 的时候必须要保证使用的 jsonp 服务必须是安全可信的</li></ul> <h2 id="简单谈一下-cookie"><a href="#简单谈一下-cookie" class="header-anchor">#</a> 简单谈一下 cookie</h2> <p>我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</p> <p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 <strong>expires、domain、path、secure、HttpOnly</strong>。其中 expires 指定了 cookie 失效的时间，domain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。<strong>secure 规定了 cookie 只能在确保安全的情况下传输</strong>，<strong>HttpOnly 规定了这个 cookie 只能被服务器访问</strong>，不能使用 js 脚本访问。在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p> <h2 id="为什么要使用模块化-都有哪几种方式可以实现模块化-各有什么特点"><a href="#为什么要使用模块化-都有哪几种方式可以实现模块化-各有什么特点" class="header-anchor">#</a> 为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</h2> <p>模块化解决了命名冲突问题，可以提高代码的复用率，提高代码的可维护性。</p> <p>模块化的好处:</p> <ul><li>避免命名冲突(减少命名空间污染)</li> <li>更好的分离, 按需加载</li> <li>更高复用性</li> <li>高可维护性</li></ul> <p><strong>方式一：函数</strong></p> <p>最起初，实现模块化的方式使用函数进行封装。将不同功能的代码实现封装到不同的函数中。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p> <p>缺陷：容易发生命名冲突或者数据的不安全性。</p> <p><strong>方式二：立即执行函数</strong></p> <p>立即执行函数中的匿名函数中有独立的词法作用域，避免了外界访问此作用域的变量。通过函数作用域解决了命名冲突、污染全局作用域的问题</p> <p>缺陷：不能直接访问到内部的变量</p> <p><strong>方式三：CommonJS 规范</strong></p> <p>CommonJS 的规范主要用在 Node.js 中，为模块提供了四个接口： module、exports、require、global ， CommonJS 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块</p> <p>CommonJS 的特点</p> <ul><li>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li> <li>所有代码都运行在模块作用域，不会污染全局作用域。</li> <li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li> <li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul> <p><strong>方式四：AMD 和 CMD</strong></p> <blockquote><p>上边有我们的 CommonJS 规范了，为什么还出 AMD 规范，因为 CommonJS 是同步加载代码的，我们在浏览器中会发生堵塞问题，造成页面的无响应。所以浏览器不太适合使用 CommonJS 来加载。</p></blockquote> <p>CommonJS 规范对浏览器和服务器端的不同之处。</p> <ul><li>服务器端所有的模块都存放在本地硬盘中，可以同步加载完成，等待时间就是硬盘的读取时间。</li> <li>浏览器，所有的模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态</li></ul> <p>AMD （ Asynchronous Module Definition ） ，即 &quot;异步模块定义&quot; 。它主要采用异步方式加载模块， 模块的加载不影响它后边语句的运行。所加载的模块，都会定义在回调函数中，加载完成，再执行回调 函数</p> <p>CMD (Common Module Definition) ，主要是 seajs 的规范。</p> <p>AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同，二者皆为异步加载模块</p> <ul><li>AMD 依赖前置， js 很方便的就知道要加载的是哪个模块了，因为已经在 define 的 dependencies 参数中就定义好了，会立即加载它。</li> <li>CMD 是就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。只有在用到某个模块的时候再去 require 。</li></ul> <p><strong>方式五：ES6 Moudle</strong></p> <p>ES6 实现的模块非常简单，用于浏览器和服务器端。 import 命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码</p> <p><strong>ES6 和 CommonJS 的区别</strong></p> <ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
<ul><li>所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。</li> <li>ES6 模块是动态引用，不缓存值，模块内外是绑定的，而且是只读引用，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 import ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取</li></ul></li> <li>CommonJS 模块是运行时加载， ES6 模块是编译时加载输出接口。</li> <li>运行时加载： CommonJS 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个 对象上面读取方法，这种加载称为“运行时加载”。</li> <li>编译时加载： ES6 模块不是对象，而是通过 export 命令「显式指定输出的代码」。 import 时采用静态命令的形式，即在 import 指定「加载某个输出值」，而「不是加载整个 模块」，这种加载称为“编译时加载”。</li> <li>CommonJs 导入的模块路径可以是一个表达式，因为它使用的是 require() 方法；而 ES6Modules 只能是字符串</li> <li>CommonJS this 指向当前模块， ES6 Modules this 指向 undefined</li></ul> <h2 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="header-anchor">#</a> 模块化开发怎么做？</h2> <p>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p> <p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p> <h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="header-anchor">#</a> js 的几种模块规范</h2> <p>js 中现在比较成熟的有四种模块加载方案。</p> <p>第一种是 <strong>CommonJS</strong> 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p> <p>第二种是 <strong>AMD</strong> 方案，这种方案采用<strong>异步加载的方式来加载模块</strong>，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p> <p>第三种是 <strong>CMD</strong> 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。<strong>它和 require.js 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同</strong>。</p> <p>第四种方案是 <strong>ES6 提出的方案</strong>，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。</p> <h2 id="amd-和-和-cmd-规范的区别"><a href="#amd-和-和-cmd-规范的区别" class="header-anchor">#</a> AMD 和 和 CMD 规范的区别</h2> <p>它们之间的主要区别有两个方面。</p> <p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇<strong>依赖前置</strong>，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇 <strong>就近依赖</strong>，只有在用到某个模块的时候再去 require。</p> <p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，<strong>AMD 在依赖模块加载完成后就直接执行依赖模块</strong>，依赖模块的执行顺序和我们书写的<strong>顺序不一定一致</strong>。而 <strong>CMD 在依赖模块加载完成后并不执行</strong>，只是下载而已，等<strong>到所有的依赖模块都加载好后，进入回调函数逻辑</strong>，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的<strong>顺序保持一致</strong>了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// CMDdefine(function(require, exports, module) {</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 此处略去 100 行</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 依赖可以就近书写</span>
b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...});</span>
<span class="token comment">// AMD 默认推荐 define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) {</span>
<span class="token comment">// 依赖必须一开始就写好</span>
a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 此处略去 100 行</span>
b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...});</span>
</code></pre></div><h2 id="es6-与-模块与-commonjs-模块"><a href="#es6-与-模块与-commonjs-模块" class="header-anchor">#</a> ES6 与 模块与 CommonJS 模块</h2> <p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用,CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p> <p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“<strong>运行时加载</strong>”。而 <strong>ES6 模块不是对象，它的对外接口只是一种静态定义</strong>，<strong>在代码静态解析阶段就会生成</strong>。</p> <h2 id="requirejs-的核心原理是什么-如何动态加载的-如何避免多次加载-的核心原理是什么"><a href="#requirejs-的核心原理是什么-如何动态加载的-如何避免多次加载-的核心原理是什么" class="header-anchor">#</a> requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载 的核心原理是什么？)</h2> <p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p> <p><strong>特性</strong></p> <p>（1）实现 js 文件的异步加载，避免网页失去响应； （2）管理模块之间的依赖性，便于代码的编写和维护。</p> <h2 id="require-与-import-的区别"><a href="#require-与-import-的区别" class="header-anchor">#</a> require 与 import 的区别</h2> <p>两者的加载方式不同、规范不同</p> <p>第一、两者的加载方式不同，require 是在运行时加载，而 import 是在编译时加载</p> <div class="language- extra-class"><pre class="language-text"><code>require('./a')(); // a 模块是一个函数，立即执行 a 模块函数

var data = require('./a').data; // a 模块导出的是一个对象

var a = require('./a')[0]; // a 模块导出的是一个数组 ======&gt; 哪都行

import $ from 'jquery';

import * as _ from '_';

import {a,b,c} from './a';

import {default as alias, a as a_a, b, c} from './a'; ======&gt;用在开头
</code></pre></div><p>第二、规范不同，require 是 CommonJS/AMD 规范，import 是 ESMAScript6+规范</p> <p>第三、require 特点：社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。</p> <p>import 特点：语言规格层面支持模块功能。支持编译时静态分析，便于 JS 引入宏和类型检验。动态绑定。</p> <h2 id="ecmascript6-怎么写-class-现-为什么会出现-class-这种东西"><a href="#ecmascript6-怎么写-class-现-为什么会出现-class-这种东西" class="header-anchor">#</a> ECMAScript6 怎么写 class 现 ，为什么会出现 class 这种东西</h2> <p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。</p> <h2 id="documen-write-和-innerhtml-的区别"><a href="#documen-write-和-innerhtml-的区别" class="header-anchor">#</a> documen.write 和 innerHTML 的区别？</h2> <p>document.write 的内容会代替整个文档内容，会重写整个页面。</p> <p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</p> <h2 id="dom-操作-怎样添加、移除、移动、复制、创建和查找节点"><a href="#dom-操作-怎样添加、移除、移动、复制、创建和查找节点" class="header-anchor">#</a> DOM 操作——怎样添加、移除、移动、复制、创建和查找节点</h2> <p>（1）创建新节点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个 DOM 片段</span>
<span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个具体的元素</span>
<span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个文本节点</span>
</code></pre></div><p>（2）添加、移除、替换、插入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//添加</span>
<span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//移除</span>
<span class="token function">replaceChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//替换</span>
<span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//插入</span>
</code></pre></div><p>（3）查找</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（4）属性操作</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">hasAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">removeAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（1）创建新节点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">createElement</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">createTextNode</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（2）添加、移除、替换、插入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token function">removeChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token function">replaceChild</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">,</span>old<span class="token punctuation">)</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">,</span>old<span class="token punctuation">)</span>
</code></pre></div><p>（3）查找</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>（4）属性操作</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">hasAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">removeAttribute</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="innerhtml-与-与-outerhtml-的区别"><a href="#innerhtml-与-与-outerhtml-的区别" class="header-anchor">#</a> innerHTML 与 与 outerHTML 的区别？</h2> <p>对于这样一个 HTML 元素：<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>。</p> <p>innerHTML：内部 HTML，<code>content&lt;br/&gt;</code></p> <p>outerHTML：外部 HTML，<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code></p> <p>innerText：内部文本，content</p> <p>outerText：内部文本，content</p> <h2 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="header-anchor">#</a> .call() 和.apply() 的区别</h2> <p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p> <p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数</p> <h2 id="在-javascript-中什么是伪数组-如何将伪数组转化为标准数组"><a href="#在-javascript-中什么是伪数组-如何将伪数组转化为标准数组" class="header-anchor">#</a> 在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h2> <p>伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用 getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。</p> <p>假设我们要给每个 log 方法添加一个&quot;(app)&quot;前缀，比如'hello world!' -&gt;'(app)hello world!'。方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//为了使用unshift数组方法，将argument转化为真正的数组</span>
  args<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token string">&quot;(app)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>console<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="javascript-类数组对象的定义"><a href="#javascript-类数组对象的定义" class="header-anchor">#</a> JavaScript 类数组对象的定义</h2> <p>一个<strong>拥有 length 属性和若干索引属性的对象</strong>就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。<strong>常见的类数组对象有 arguments 和 DOM 方法的返回结果</strong>，还有一个<strong>函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数</strong>。</p> <p>常见的类数组转换为数组的方法有这样几种：</p> <ul><li>通过 call 调用数组的 slice 方法来实现转换 Array.prototype.slice.call(arrayLike);</li> <li>通过 call 调用数组的 splice 方法来实现转换 Array.prototype.splice.call(arrayLike, 0);</li> <li>通过 apply 调用数组的 concat 方法来实现转换 Array.prototype.concat.apply([], arrayLike);</li> <li>通过 Array.from 方法来实现转换 Array.from(arrayLike);</li></ul> <h2 id="字符串常用操作"><a href="#字符串常用操作" class="header-anchor">#</a> 字符串常用操作</h2> <ul><li>charAt(index):返回指定索引处的字符串</li> <li>charCodeAt(index):返回指定索引处的字符的 Unicode 的值</li> <li>concat(str1,str2,...):连接多个字符串，返回连接后的字符串的副本</li> <li>fromCharCode():将 Unicode 值转换成实际的字符串</li> <li>indexOf(str):返回 str 在父串中第一次出现的位置，若没有则返回-1</li> <li>lastIndexOf(str):返回 str 在父串中最后一次出现的位置，若没有则返回-1</li> <li>match(regex):搜索字符串，并返回正则表达式的所有匹配</li> <li>replace(str1,str2):str1 也可以为正则表达式，用 str2 替换 str1</li> <li>search(regex):基于正则表达式搜索字符串，并返回第一个匹配的位置</li> <li>slice(start,end)：返回字符索引在 start 和 end（不含）之间的子串</li> <li>split(sep，limit)：将字符串分割为字符数组，limit 为从头开始执行分割的最大数量</li> <li>substr(start，length)：从字符索引 start 的位置开始，返回长度为 length 的子串</li> <li>substring(from,to)：返回字符索引在 from 和 to（不含）之间的子串</li> <li>toLowerCase()：将字符串转换为小写</li> <li>toUpperCase()：将字符串转换为大写</li> <li>valueOf()：返回原始字符串值</li></ul> <h2 id="数组有哪些原生方法-列举一下"><a href="#数组有哪些原生方法-列举一下" class="header-anchor">#</a> 数组有哪些原生方法，列举一下</h2> <p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p> <ul><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li> <li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li> <li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li> <li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul> <h2 id="数组中常用的方法"><a href="#数组中常用的方法" class="header-anchor">#</a> 数组中常用的方法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 改变原数组的方法：</span>
<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除数组中的最后一个元素，把数组长度减 1，并且返回它删除的元素的值</span>
<span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 该方法可把它的参数顺序添加到数组的尾部。它直接修改数组，返回后修改数组的长</span>
<span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数组元素倒序，改变原数组</span>
<span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以向数组开头增加一个或多个元素，并返回新的长度</span>
<span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数组的第一个元素从其中删除，并返回第一个元素的值，减少数组的长度</span>
<span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在原数组上进行排序，不生成副本</span>
<span class="token function">splice</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> 删除的个数<span class="token punctuation">,</span> 插入的元素<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可删除从index处开始的零个或多个元素，并且用参</span>
<span class="token comment">// 不改变原数组：</span>
<span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于连接两个或多个数组，不改变原数组，返回一个新的数组</span>
<span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数组中的所有元素都转化为字符串并拼接在一起，默认使用逗号，返回最终生成的</span>
<span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组，不改变原数组</span>
<span class="token function">indexof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回指定位置的元素值或字符串，通过搜索值与下标寻找</span>
<span class="token function">every</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果每一项都为true，则返回true</span>
<span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 某一项返回true，则返回true</span>
<span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对数组的每一项运行给定函数，没有返回值</span>
</code></pre></div><p><strong>Array.map()</strong></p> <p>此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//arr= [1, 2, 3, 4, 5]   原数组保持不变</span>
<span class="token comment">//newArr = [2, 4, 6, 8, 10] 返回新数组</span>
</code></pre></div><p><strong>Array.forEach()</strong></p> <p>此方法是将数组中的每个元素执行传进提供的函数，没有返回值，直接改变原数组，注意和 map 方法区分</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
num<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分</span>
</code></pre></div><p><strong>Array.filter()</strong></p> <p>此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> <span class="token parameter">isBigEnough</span> <span class="token operator">=&gt;</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value <span class="token operator">&gt;=</span> <span class="token number">3</span>
    <span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>isBigEnough <span class="token punctuation">)</span>
    <span class="token comment">//newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组</span>
</code></pre></div><p><strong>Array.every()</strong></p> <p>此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回 true，否则为 false：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> <span class="token parameter">isLessThan4</span> <span class="token operator">=&gt;</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value <span class="token operator">&lt;</span> <span class="token number">4</span>
    <span class="token keyword">const</span> <span class="token parameter">isLessThan6</span> <span class="token operator">=&gt;</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value <span class="token operator">&lt;</span> <span class="token number">6</span>
    arr<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>isLessThan4 <span class="token punctuation">)</span> <span class="token comment">//false</span>
    arr<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>isLessThan6 <span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><p><strong>Array.some()</strong></p> <p>此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回 true，若所有元素都不满足判断条件，则返回 false：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> <span class="token parameter">isLessThan4</span> <span class="token operator">=&gt;</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value <span class="token operator">&lt;</span> <span class="token number">4</span>
    <span class="token keyword">const</span> <span class="token parameter">isLessThan6</span> <span class="token operator">=&gt;</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value <span class="token operator">&gt;</span> <span class="token number">6</span>
    arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>isLessThan4 <span class="token punctuation">)</span> <span class="token comment">//true</span>
    arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>isLessThan6 <span class="token punctuation">)</span> <span class="token comment">//false</span>
</code></pre></div><p><strong>Array.reduce()</strong></p> <p>此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token keyword">let</span> sum <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//sum = 15  相当于累加的效果</span>
</code></pre></div><p>与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的</p> <p><strong>Array.push()</strong></p> <p>此方法是在数组的后面添加新加元素，此方法改变了数组的长度：</p> <p><strong>Array.pop()</strong></p> <p>此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[1, 2, 3, 4]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//4</span>
Array<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[2, 3, 4, 5]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//4</span>
Array<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[6, 7, 2, 3, 4, 5]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//7</span>
</code></pre></div><p><strong><code>Array.isArray()</code></strong></p> <p>判断一个对象是不是数组，返回的是布尔值</p> <p><strong><code>Array.concat()</code></strong></p> <p>此方法是一个可以将多个数组拼接成一个数组：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//[1, 2, 3, 4, 5]</span>


<span class="token comment">// Array.toString()</span>

此方法将数组转化为字符串：

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">// 1,2,3,4,5</span>


<span class="token comment">// **`Array.join()`**</span>

此方法也是将数组转化为字符串：


<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> str1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> str2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> str3 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'##'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token comment">// 12345</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token comment">// 1,2,3,4,5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token comment">// 1##2##3##4##5</span>
</code></pre></div><p>通过例子可以看出和 toString 的区别，可以设置元素之间的间隔~</p> <p><strong>Array.splice(开始位置， 删除的个数，元素)</strong></p> <p>万能方法，可以实现增删改：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token string">'haha'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> arr1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token string">'haha'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token comment">//[1, 2, 'haha', 3, 4, 5]新增一个元素</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token comment">//[1, 2] 删除三个元素</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span> <span class="token comment">//[1, 2, 'haha', 4, 5] 替换一个元素</span>
</code></pre></div><h2 id="javascript-数组的函数-map-foreach-reduce-filter"><a href="#javascript-数组的函数-map-foreach-reduce-filter" class="header-anchor">#</a> JavaScript 数组的函数 map/forEach/reduce/filter</h2> <p>map</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// map</span>
<span class="token comment">//作用：对数组进行遍历</span>
<span class="token comment">//返回值：新的数组</span>
<span class="token comment">// 是否改变：否</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ret <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[3,6,4,5]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[2,5,3,4]</span>
forEach<span class="token punctuation">;</span>
<span class="token comment">// forEach 方法</span>
<span class="token comment">// 作用：遍历数组的每一项</span>
<span class="token comment">// 返回值：undefined</span>
<span class="token comment">// 是否改变：否</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ret <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 5, 3, 4</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[2,5,3,4]</span>
</code></pre></div><p>reduce</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// reduce 方法</span>
<span class="token comment">// 作用：对数组进行迭代，然后两两进行操作，最后返回一个值</span>
<span class="token comment">// 返回值：return出来的结果</span>
<span class="token comment">// 是否改变：不会</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ret <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 24</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4]</span>
</code></pre></div><p>filter</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// filter 过滤</span>
<span class="token comment">// 作用： 筛选一部分元素</span>
<span class="token comment">// 返回值： 一个满足筛选条件的新数组</span>
<span class="token comment">// 是否改变原有数组：不会</span>

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ret <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[5,4]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[2,5,3,4]</span>
</code></pre></div><h2 id="对数组方法-map-和-reduce-方法的理解-区别在哪里"><a href="#对数组方法-map-和-reduce-方法的理解-区别在哪里" class="header-anchor">#</a> 对数组方法 map 和 reduce 方法的理解，区别在哪里</h2> <p>map 方法的调用者一般是数组，参数是一个 callback 函数，返回值是一个由原数组中每个元素执行 callback 函数得到的返回值组成的新数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 接口数据映射</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> item<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    age<span class="token operator">:</span> item<span class="token punctuation">.</span>age<span class="token punctuation">,</span>
    sex<span class="token operator">:</span> item<span class="token punctuation">.</span>sex <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token string">&quot;男&quot;</span> <span class="token operator">:</span> item<span class="token punctuation">.</span>sex <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">&quot;女&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;保密&quot;</span><span class="token punctuation">,</span>
    avatar<span class="token operator">:</span> item<span class="token punctuation">.</span>img<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>reduce 方法调用者也一般为数组，参数是 callback 和一个可选的 initialValue，为数组中每个元素执行 callback 函数，返回一个具体的结果，如果给定 initialValue 可以作为第一次调用 callback 的第一个参数，可以控制返回值的格式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 求一个字符串中每个字母出现的次数</span>
<span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&quot;abcabdaac&quot;</span><span class="token punctuation">;</span>
str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">?</span> res<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">:</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// {a: 4, b: 2, c: 2, d: 1}</span>
</code></pre></div><h2 id="对-map-和-reduce-实现的理解-能手写一下嘛"><a href="#对-map-和-reduce-实现的理解-能手写一下嘛" class="header-anchor">#</a> 对 map 和 reduce 实现的理解，能手写一下嘛</h2> <p>数组方法 map 模拟实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_map</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> me <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> me<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>me<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newArr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>数组方法 reduce 模拟实现：方法类似核心是数组的遍历，因为 reduce 有第二个可选参数 initialValue 做起始值，所以要判断是否有可选参数作为遍历的起始值，并将得到的参数传入回调函数中执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_reduce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> initialValue</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> base <span class="token operator">=</span> <span class="token keyword">typeof</span> initialValue <span class="token operator">==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> initialValue<span class="token punctuation">;</span>
  <span class="token keyword">let</span> startPoint <span class="token operator">=</span> <span class="token keyword">typeof</span> initialValue <span class="token operator">===</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
  arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>startPoint<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    base <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> val<span class="token punctuation">,</span> index <span class="token operator">+</span> startPoint<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> base<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="数组的-fill-方法"><a href="#数组的-fill-方法" class="header-anchor">#</a> 数组的 fill 方法？</h2> <p>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p> <p>fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</p> <h2 id="的长度"><a href="#的长度" class="header-anchor">#</a> [,,,] 的长度？</h2> <p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p> <p>JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。<strong>稀疏数组的长度为逗号的数量</strong>。</p> <h2 id="如何判断一个对象是否为数组"><a href="#如何判断一个对象是否为数组" class="header-anchor">#</a> 如何判断一个对象是否为数组</h2> <ul><li><p>第一种方法：使用 instanceof 操作符。</p></li> <li><p>第二种方法：使用 ECMAScript 5 新增的 Array.isArray()方法。</p></li> <li><p>第三种方法：使用使用 Object.prototype 上的原生 toString()方法判断。</p></li></ul> <h2 id="object-prototype-tostring-call-和-instanceof-和-array-isarray-区别好坏"><a href="#object-prototype-tostring-call-和-instanceof-和-array-isarray-区别好坏" class="header-anchor">#</a> Object.prototype.toString.call() 和 instanceOf 和 Array.isArray() 区别好坏</h2> <ul><li>Object.prototype.toString.call()
<ul><li>优点：这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</li> <li>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]</li></ul></li> <li>instanceOf
<ul><li>优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。</li> <li>缺点： instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。</li></ul></li> <li>Array.isArray()
<ul><li>优点：当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes</li> <li>缺点：只能判别数组</li></ul></li></ul> <p><strong>Object.prototype.toString.call()</strong></p> <p>每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> an <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;An&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
an<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello,An&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>an<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Array]&quot;</span>
</code></pre></div><p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;An&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object String]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Number]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Symbol]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Null]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Undefined]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Function]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;An&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Object]&quot;</span>
</code></pre></div><p>缺点：不能精准判断自定义对象，对于自定义对象只会返回[object Object]</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token string">&quot;martin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[object Object]</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 常用于判断浏览器内置对象。</span>
</code></pre></div><p><strong>instanceof</strong></p> <p>instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p> <p>使用 instanceof 判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。</p> <p><code>[] instanceof Array; // true</code></p> <p>但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p> <p><code>[] instanceof Object; // true</code></p> <p>优点：instanceof 可以弥补 Object.prototype.toString.call()不能判断自定义实例化对象的缺点。</p> <p>缺点：instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出 iframes。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token string">&quot;martin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1 <span class="token keyword">instanceof</span> <span class="token class-name">f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span>
xArray <span class="token operator">=</span> window<span class="token punctuation">.</span>frames<span class="token punctuation">[</span>window<span class="token punctuation">.</span>frames<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Array<span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">xArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">//[object Array]</span>
</code></pre></div><p><strong>Array.isArray()</strong></p> <ul><li><p>功能：用来判断对象是否为数组</p></li> <li><p>instanceof 与 isArray</p></li></ul> <p>当检测 Array 实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;iframe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
xArray <span class="token operator">=</span> window<span class="token punctuation">.</span>frames<span class="token punctuation">[</span>window<span class="token punctuation">.</span>frames<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Array<span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">xArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>

<span class="token comment">// Correctly checking for Array</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// Considered harmful, because doesn't work though iframes</span>
arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>缺点：只能判别数组</p> <div class="language-js extra-class"><pre class="language-js"><code>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 与 <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是 <span class="token constant">ES5</span> 新增的方法，当不存在 Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ，可以用 <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 实现。

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span>isArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Array<span class="token punctuation">.</span><span class="token function-variable function">isArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;[object Array]&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="split-join-的区别"><a href="#split-join-的区别" class="header-anchor">#</a> split() join()的区别</h2> <p>join()：用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串</p> <p>split()：用于把一个字符串通过指定的分隔符进行分隔成数组</p> <h2 id="数组和对象有哪些原生方法-列举一下"><a href="#数组和对象有哪些原生方法-列举一下" class="header-anchor">#</a> 数组和对象有哪些原生方法，列举一下？</h2> <p>Array.concat( ) 连接数组</p> <p>Array.join( ) 将数组元素连接起来以构建一个字符串</p> <p>Array.length 数组的大小</p> <p>Array.pop( ) 删除并返回数组的最后一个元素</p> <p>Array.push( ) 给数组添加元素</p> <p>Array.reverse( ) 颠倒数组中元素的顺序</p> <p>Array.shift( ) 将元素移出数组</p> <p>Array.slice( ) 返回数组的一部分</p> <p>Array.sort( ) 对数组元素进行排序</p> <p>Array.splice( ) 插入、删除或替换数组的元素</p> <p>Array.toLocaleString( ) 把数组转换成局部字符串</p> <p>Array.toString( ) 将数组转换成一个字符串</p> <p>Array.unshift( ) 在数组头部插入一个元素</p> <p>Object.hasOwnProperty( ) 检查属性是否被继承</p> <p>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</p> <p>Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性</p> <p>Object.toLocaleString( ) 返回对象的本地字符串表示</p> <p>Object.toString( ) 定义一个对象的字符串表示</p> <p>Object.valueOf( ) 指定对象的原始值</p> <h2 id="delete-数组的-item-数组的-length-是否会-1"><a href="#delete-数组的-item-数组的-length-是否会-1" class="header-anchor">#</a> delete 数组的 item，数组的 length 是否会 -1</h2> <p>不会</p> <p>解析：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">delete</span> Array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;e&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">delete</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['a', undefined, 'c', 'd', 'e']</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>使用 delete 删除元素，返回 true 和 false,true 表示删除成功，false 表示删除失败。使用 delete 删除数组元素并不会改变原数组的长度，只是把被删除元素的值变为 undefined。</p> <h2 id="数组降维"><a href="#数组降维" class="header-anchor">#</a> 数组降维</h2> <p>1.数组字符串化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">222</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">444</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr <span class="token operator">+=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;222&quot;, &quot;333&quot;, &quot;444&quot;, &quot;55&quot;, &quot;66&quot;, &quot;77&quot;, &quot;[object Object]&quot;]</span>
</code></pre></div><p>这也是比较简单的一种方式，从以上例子中也能看到问题，所有的元素会转换为字符串，且元素为对象类型会被转换为 &quot;[object Object]&quot; ，对于同一种类型数字或字符串还是可以的。</p> <p>2.利用 apply 和 concat 转换</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reduceDimension</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">reduceDimension</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">123</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [123, 4, 7, 8, 9, Array(1)]</span>
</code></pre></div><p>3.递归</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reduceDimension</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> <span class="token function-variable function">toArr</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      item <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token function">toArr</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">:</span> ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">toArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4.Array​.prototype​.flat()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr1<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4]</span>

<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr2<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4, [5, 6]]</span>

<span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4, 5, 6]</span>

<span class="token comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span>
arr3<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 4, 5, 6]</span>
</code></pre></div><p>5.使用 reduce、concat 和递归无限反嵌套多层嵌套的数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">flattenDeep</span><span class="token punctuation">(</span><span class="token parameter">arr1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr1<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
      Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">?</span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">flattenDeep</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">flattenDeep</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]</span>
</code></pre></div><h2 id="如何编写高性能的-javascript"><a href="#如何编写高性能的-javascript" class="header-anchor">#</a> 如何编写高性能的 Javascript</h2> <ul><li>使用位运算代替一些简单的四则运算。</li> <li>避免使用过深的嵌套循环。</li> <li>不要使用未定义的变量。</li> <li>当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul> <ul><li>使用 DocumentFragment 优化多次 append</li> <li>通过模板元素 clone ，替代 createElement</li> <li>使用一次 innerHTML 赋值代替构建 dom 元素</li> <li>使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</li> <li>使用 Array 做为 StringBuffer ，代替字符串拼接的操作</li> <li>将循环控制量保存到局部变量</li> <li>顺序无关的遍历时，用 while 替代 for</li> <li>将条件分支，按可能性顺序从高到低排列</li> <li>在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</li> <li>使用三目运算符替代条件分支</li> <li>需要不断执行的时候，优先考虑使用 setInterval</li></ul> <h2 id="简单介绍一下-v8-引擎的垃圾回收机制"><a href="#简单介绍一下-v8-引擎的垃圾回收机制" class="header-anchor">#</a> 简单介绍一下 V8 引擎的垃圾回收机制</h2> <p>v8 的垃圾回收机制<strong>基于分代回收机制</strong>，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，<strong>v8 引擎将内存分为了新生代和老生代</strong>。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p> <p><strong>新生代被分为 From 和 To 两个空间</strong>，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。<strong>当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行</strong>。这个算法分为三步：</p> <p>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。
（2）如果对象不存活，则释放对象的空间。
（3）最后将 From 空间和 To 空间角色进行交换。</p> <p>新生代对象晋升到老生代有两个条件：</p> <p>（1）第一个是判断是对象否<strong>已经经过一次 Scavenge 回收</strong>。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。
（2）第二个是 <strong>To 空间的内存使用占比是否超过限制</strong>。当对象从 From 空间复制到 To 空间时，若 <strong>To 空间使用超过 25%</strong>，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p> <p>老生代采用了<strong>标记清除法</strong>和<strong>标记压缩法</strong>。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于<strong>标记清除后会造成很多的内存碎片，不便于后面的内存分配</strong>。所以了解决内存碎片的问题引入了标记压缩法。由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但<strong>对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响</strong>。 为了解决这个问题 V8 引入了<strong>增量标记的方法</strong>，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p> <h2 id="js-的垃圾回收机制"><a href="#js-的垃圾回收机制" class="header-anchor">#</a> js 的垃圾回收机制</h2> <p>JavaScript 内存管理有一个主要概念是可达性，“可达性” 值是那些以某种方式可访问或可用的值，它们被保证存储在内存中。有一组基本的固有可达值，由于显而易见的原因无法删除，比如：本地函数的局部变量和参数，全局变量，当前嵌套调用链上的其他函数的变量和参数，这些值被称为&quot;根&quot;，如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的</p> <p>JavaScript 在创建变量时自动进行了内存分配，并且在它们不使用时&quot;自动&quot;释放，释放的过程就被称为垃圾回收</p> <p>现在各大浏览器通常采用的垃圾回收有两种方法：标记清除、引用计数</p> <ul><li>引用计数垃圾收集：把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。但是有一个限制是&quot;无法处理循环引用问题</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;some_element&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myObj<span class="token punctuation">.</span>element <span class="token operator">=</span> element<span class="token punctuation">;</span>
element<span class="token punctuation">.</span>someObject <span class="token operator">=</span> myObj<span class="token punctuation">;</span>
<span class="token comment">// 变量myObj有一个element属性执行element，而变量element有一个名为someObject属性指</span>

<span class="token comment">// 我们需要手动切断它们的循环引用，防止内存泄露</span>
myObj<span class="token punctuation">.</span>element <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>someObject <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>标记清除：是 js 中最常用的垃圾回收方式，把“对象是否不再需要”简化定义为“对象是否可以获得”，定期会执行以下的&quot;垃圾回收&quot;步骤（这正是标记清除算法垃圾收集的工作原理）
<ul><li>首先垃圾回收器获取根并“标记”它们</li> <li>然后它访问并“标记”所有来自它们的引用</li> <li>接着它访问标记的对象并标记它们的引用(子孙代的引用)</li> <li>以此类推，直至有未访问的引用，此时进程中不能访问的对象将被认为是不可访问的</li> <li>除标记的对象外，其余对象将被删除</li></ul></li></ul> <h2 id="哪些操作会造成内存泄漏"><a href="#哪些操作会造成内存泄漏" class="header-anchor">#</a> 哪些操作会造成内存泄漏</h2> <p>相关知识点：</p> <ul><li>意外的全局变量</li> <li>被遗忘的计时器或回调函数</li> <li>脱离 DOM 的引用</li> <li>闭包</li></ul> <p>回答：</p> <p>第一种情况是我们由于使用<strong>未声明的变量</strong>，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p> <p>第二种情况是我们设置了 <strong>setInterval 定时器</strong>，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p> <p>第三种情况是我们获取一个 <strong>DOM 元素的引用</strong>，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p> <p>第四种情况是不合理的使用<strong>闭包</strong>，从而导致某些变量一直被留在内存当中。</p> <hr> <p>1）意外的全局变量引起的内存泄露</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  leak <span class="token operator">=</span> <span class="token string">&quot;xxx&quot;</span><span class="token punctuation">;</span> <span class="token comment">//leak成为一个全局变量，不会被回收</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2）闭包引起的内存泄露</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bindEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;XXX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">οnclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//Even if it's a empty function</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>闭包可以维持函数内局部变量，使其得不到释放。 上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调的引用外暴了，形成了闭包。 解决之道，将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//将事件处理函数定义在外部</span>
<span class="token keyword">function</span> <span class="token function">onclickHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//do something</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bindEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;XXX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span>οnclick <span class="token operator">=</span> onclickHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//在定义事件处理函数的外部函数中，删除对dom的引用</span>
<span class="token keyword">function</span> <span class="token function">bindEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;XXX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">οnclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//Even if it's a empty function</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3）没有清理的 DOM 元素引用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> elements<span class="token operator">=</span><span class="token punctuation">{</span>
    button<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    image<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;image&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    text<span class="token operator">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;text&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    image<span class="token punctuation">.</span>src<span class="token operator">=</span><span class="token string">&quot;http://some.url/image&quot;</span><span class="token punctuation">;</span>
    button<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">removeButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4）被遗忘的定时器或者回调</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> someResouce <span class="token operator">=</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;Node&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>someResouce<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样的代码很常见, 如果 id 为 Node 的元素从 DOM 中移除, 该定时器仍会存在, 同时, 因为回调函数中包含对 someResource 的引用, 定时器外面的 someResource 也不会被释放。</p> <p>5）子元素存在引起的内存泄露</p> <p><img src="/assets/img/memy.87ad545f.png" alt=""></p> <p>黄色是指直接被 js 变量所引用，在内存里，红色是指间接被 js 变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除。</p> <p>6）IE7/8 引用计数使用循环引用产生的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span>pro <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b<span class="token punctuation">.</span>pro <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 a 和 b 的引用次数不为 0，所以不会被垃圾回收器回收内存，如果 fn 函数被大量调用，就会造成内存泄漏。在 IE7 与 IE8 上，内存直线上升。 IE 中有一部分对象并不是原生 js 对象。例如，其内存泄漏 DOM 和 BOM 中的对象就是使用 C++以 COM 对象的形式实现的，而 COM 对象的垃圾回收机制采用的就是引用计数策略。因此，即使 IE 的 js 引擎采用标记清除策略来实现，但 js 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;some_element&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>e <span class="token operator">=</span> element<span class="token punctuation">;</span>
element<span class="token punctuation">.</span>o <span class="token operator">=</span> myObject<span class="token punctuation">;</span>
</code></pre></div><p>上面的例子在一个 DOM 元素（element)与一个原生 js 对象（myObject)之间创建了循环引用。其中，变量 myObject 有一个名为 e 的属性指向 element 对象；而变量 element 也有一个属性名为 o 回指 myObject。由于存在这个循环引用，即使例子中的 DOM 从页面中移除，它也永远不会被回收。</p> <p>看上面的例子，有人会觉得太弱了，谁会做这样无聊的事情，但是其实我们经常会这样做</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">οnlοad</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;element&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">οnclick</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码看起来没什么问题，但是 obj 引用了 document.getElementById(“element”)，而 document.getElementById(“element”)的 onclick 方法会引用外部环境中的变量，自然也包括 obj，是不是很隐蔽啊。</p> <p>最简单的解决方式就是自己手工解除循环引用，比如刚才的函数可以这样</p> <div class="language-js extra-class"><pre class="language-js"><code>myObject<span class="token punctuation">.</span>element<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>o<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function-variable function">οnlοad</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;element&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span>
  obj<span class="token punctuation">.</span><span class="token function-variable function">οnclick</span><span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  obj<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致 Dom 内存泄漏问题，可能是微软做了优化，或者 Dom 的回收方式已经改变</p> <p>解析：</p> <p>1、JS 的回收机制</p> <p>JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收系统（GC）会按照固定的时间间隔,周期性的执行。</p> <p>到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p> <p>2、标记清除（mark and sweep）</p> <p>js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//被标记，进入环境</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//被标记，进入环境</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行完毕之后a、b又被标记离开环境，被回收</span>
</code></pre></div><p>3、引用计数(reference counting)</p> <p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值（function object array）赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//a的引用次数为0</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//a的引用次数加1，为1</span>
  <span class="token keyword">var</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//a的引用次数加1，为2</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//a的引用次数减1，为1</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4、如何分析内存的使用情况</p> <p>Google Chrome 浏览器提供了非常强大的 JS 调试工具，Memory 视图 profiles 视图让你可以对 JavaScript 代码运行时的内存进行快照，并且可以比较这些内存快照。它还让你可以记录一段时间内的内存分配情况。在每一个结果视图中都可以展示不同类型的列表，但是对我们最有用的是 summary 列表和 comparison 列表。 summary 视图提供了不同类型的分配对象以及它们的合计大小：shallow size （一个特定类型的所有对象的总和）和 retained size （shallow size 加上保留此对象的其它对象的大小）。distance 显示了对象到达 GC 根（校者注：最初引用的那块内存，具体内容可自行搜索该术语）的最短距离。 comparison 视图提供了同样的信息但是允许对比不同的快照。这对于找到泄漏很有帮助。</p> <p>5、怎样避免内存泄露</p> <p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p> <p>2）注意程序逻辑，避免“死循环”之类的 ；</p> <p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p> <h2 id="实现一个页面操作不会整页刷新的网站-0-并且能在浏览器前进、后退时正确响应"><a href="#实现一个页面操作不会整页刷新的网站-0-并且能在浏览器前进、后退时正确响应" class="header-anchor">#</a> 实现一个页面操作不会整页刷新的网站 0，并且能在浏览器前进、后退时正确响应</h2> <p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history</p> <p>对象中。<strong>一条 state 记录包含了 url、title 和 content 属性</strong>，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 <strong>window.onpopstate 事件监听来响应浏览器的前进后退操作</strong>。</p> <p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面</p> <h2 id="如何判断当前脚本运行在浏览器还是-node-环境中"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中" class="header-anchor">#</a> 如何判断当前脚本运行在浏览器还是 node 环境中</h2> <p><code>this === window ? 'browser' : 'node';</code></p> <p>通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。</p> <h2 id="为什么不把-script-标签放在-body-结束标签之后-html-结束标签之前"><a href="#为什么不把-script-标签放在-body-结束标签之后-html-结束标签之前" class="header-anchor">#</a> 为什么不把 Script 标签放在 body 结束标签之后 html 结束标签之前</h2> <p>第一，这是不合标准的行为，而且从有 HTML 标准以来都是不合标准的，因此浏览器实现不一致或者在这种情况下有 bug 的风险显然更大。</p> <p>第二，虽然将<code>&lt;script&gt;写在&lt;/body&gt;</code>之后，但最终的 DOM 树里，<code>&lt;script&gt;</code>元素还是会成为 body 的子节点，这一点很容易在 firebug 等调试器里验证。既然如此，如果将<code>&lt;script&gt;</code>写在<code>&lt;/body&gt;</code>之前会有问题，你又如何保证写在之后（并在 DOM 里又变成了和写在之前一样的结构）就没有问题？</p> <h2 id="移动端的点击事件的有延迟-时间是多久-为什么会有-移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时"><a href="#移动端的点击事件的有延迟-时间是多久-为什么会有-移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时" class="header-anchor">#</a> 移动端的点击事件的有延迟，时间是多久，为什么会有？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时</h2> <p>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p> <p>有三种办法来解决这个问题：</p> <ul><li>通过 meta 标签<strong>禁用网页的缩放</strong>。</li> <li>通过 meta 标签将网页的 viewport 设置为 <strong>ideal viewport</strong>。</li> <li>调用一些 js 库，比如 <strong>FastClick</strong></li></ul> <p>click 延时问题还可能引起<strong>点击穿透</strong>的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p> <h2 id="移动端点透现象"><a href="#移动端点透现象" class="header-anchor">#</a> 移动端点透现象</h2> <p>首先需要了解的是，移动端在 touch 上一共有 4 个事件，执行顺序为 touchstart -&gt; touchmove -&gt; touchend -&gt; touchcancel</p> <p>当用户点击屏幕时，会触发 touch 和 click 事件，touch 事件会优先处理，touch 事件经过捕获，目标，冒泡一系列流程处理完成之后，才会触发 click，所有我们经常会谈到移动端点击事件 300ms 延迟的问题,动端点击事件 300ms 问题，常见的解决方案：</p> <ul><li>阻止用户双击缩放，并限制视口大小`</li> <li>设置 css touch-action  用于指定某个给定的区域是否允许用户操作，以及如何相应用户操作</li> <li>fastclick.js 来解决，其原理是在检测到 touchend 事件的时候，会通过自定义事件立即触发模拟一个 click 事件，并在 300ms 之后把真正的 click 事件阻止掉</li></ul> <p><strong>点透现象：</strong></p> <p>发生条件：1.按钮 A 和按钮 B 不是后代继承关系，2.A 发生 touch，A touch 后立即消失，B 绑定 click，3.A z-index 大于 B，即 A 显示在 B 浮层之上</p> <p>发生原因：当点击屏幕时，系统生成 touch 和 click 两个事件，touch 先执行，touch 执行完之后 A 消失，然后要执行 click 的时候，就会发现用户点击的是 B，所以就执行了 B 的 click</p> <p>解决方法：1.阻止默认事件，在 touch 的某个时间段执行 event.preventDefault，去取消系统生成的 click 事件，一半在 touchend 中执行。2.要消失的元素延迟 300ms 后在消失</p> <h2 id="zepto-的点透问题如何解决"><a href="#zepto-的点透问题如何解决" class="header-anchor">#</a> Zepto 的点透问题如何解决？</h2> <p>方案一：来得很直接 github 上有个 fastclick 可以完美解决<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener noreferrer">https://github.com/ftlabs/fastclick<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>引入 fastclick.js，因为 fastclick 源码不依赖其他库所以你可以在原生的 js 前直接加上</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;load&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    FastClick<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者有 zepto 或者 jqm 的 js 里面加上</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  FastClick<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当然 require 的话就这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> FastClick <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fastclick&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
FastClick<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>方案二：用 touchend 代替 tap 事件并阻止掉 touchend 的默认行为 preventDefault()</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;#cbFinish&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;touchend&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//很多处理比如隐藏什么的</span>
  event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>方案三：延迟一定的时间(300ms+)来处理事件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;#cbFinish&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;tap&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//很多处理比如隐藏什么的</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种方法其实很好，可以和 fadeInIn/fadeOut 等动画结合使用，可以做出过渡效果</p> <p>理论上上面的方法可以完美的解决 tap 的点透问题，如果真的不行，用 click</p> <p><strong>“点透”是什么？</strong></p> <p>你可能碰到过在列表页面上创建一个弹出层，弹出层有个关闭的按钮，你点了这个按钮关闭弹出层后后，这个按钮正下方的内容也会执行点击事件（或打开链接）。这个被定义为这是一个“点透”现象。</p> <h2 id="移动端最小触控区域是多大"><a href="#移动端最小触控区域是多大" class="header-anchor">#</a> 移动端最小触控区域是多大？</h2> <p>苹果推荐是 44pt x 44pt</p> <h2 id="移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时"><a href="#移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时" class="header-anchor">#</a> 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h2> <ul><li>300 毫秒</li> <li>因为浏览器捕获第一次单击后，会先等待一段时间，如果在这段时间区间里用户未进行下一次点击，则浏览器会做单击事件的处理。如果这段时间里用户进行了第二次单击操作，则浏览器会做双击事件处理。</li> <li>推荐 fastclick.js</li></ul> <h2 id="移动端-click-事件、touch-事件、tap-事件的区别"><a href="#移动端-click-事件、touch-事件、tap-事件的区别" class="header-anchor">#</a> 移动端 click 事件、touch 事件、tap 事件的区别</h2> <p>click 事件在移动端会有 200-300ms ms 的延迟，主要原因是苹果手机在设计时，考虑到用户在浏览网页时需要放大，所以，在用户点击的 200-300ms 之后，才触发 click，如果 200-300ms 之内还有 click，就会进行放大缩小。</p> <p>touch 事件是针对触屏手机上的触摸事件。现今大多数触屏手机 webkit 内核提供了 touch 事件的监听，让开发者可以获取用户触摸屏幕时的一些信息。其中包括：touchstart,touchmove,touchend,touchcancel 这四个事件，touchstart touchmove touchend 事件可以类比于 mousedown mouseover mouseup 的触发</p> <p>tap 事件在移动端，代替 click 作为点击事件，tap 事件被很多框架（如 zepto）封装，来减少这延迟问题， tap 事件不是原生的，所以是封装的，那么具体是如何实现的呢？</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">function</span> <span class="token function">tap</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录开始时间</span>
    <span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token comment">// 控制允许延迟的时间</span>
      delayTime <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span>
      <span class="token comment">// 记录是否移动，如果移动，则不触发tap事件</span>
      isMove <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 在touchstart时记录开始的时间</span>
    ele<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;touchstart&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      startTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果touchmove事件被触发，则isMove为true</span>
    ele<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;touchmove&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isMove <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果touchmove事件触发或者中间时间超过了延迟时间，则返回，否则，调用回调函数。</span>
    ele<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;touchend&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isMove <span class="token operator">||</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime <span class="token operator">&gt;</span> delayTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">callback</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">tap</span><span class="token punctuation">(</span>btn<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;taped&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>拓展：</p> <p>点透问题</p> <p>如果我们在移动端所有的 click 都替换为了 tap 事件，还是会触发点透问题的，因为实质是： 在同一个 z 轴上，z-index 不同的两个元素，上面的元素是一个绑定了 tap 事件的，下面是一个 a 标签，一旦 tap 触发，这个元素就会 display: none，而从上面的 tap 可以看出，有 touchstart、touchend，所以会 300ms 之后触发 click 事件，而 z-index 已经消失了，所以，触发了下面的 a 的 click 事件，注意： 我们认为 a 标签默认是绑定了 click 事件的。而这种现象不是我们所期待的。</p> <p>解决方案： （1）使用 fastclick。 （2）添加一个延迟。</p> <p>（1）直接引入 fastclick 库。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">&quot;load&quot;</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    FastClick<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样，就可以成功解决问题了。</p> <p>（2）对于上一个 tap 做延迟。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">tap</span><span class="token punctuation">(</span>ele<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">&quot;none&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样，过了 300ms，那么 click 事件就不会触发在下面的 a 标签上了。</p> <h2 id="如何测试前端代码-bdd-tdd-unit-test-怎么测试你的前端工程-mocha-sinon-jasmin-qunit"><a href="#如何测试前端代码-bdd-tdd-unit-test-怎么测试你的前端工程-mocha-sinon-jasmin-qunit" class="header-anchor">#</a> 如何测试前端代码 BDD, TDD, Unit Test 怎么测试你的前端工程(mocha, sinon, jasmin, qUnit..)</h2> <p><a href="https://juejin.cn/post/6844903624301084680" target="_blank" rel="noopener noreferrer">浅谈前端单元测试<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="检测浏览器版本版本有哪些方式"><a href="#检测浏览器版本版本有哪些方式" class="header-anchor">#</a> 检测浏览器版本版本有哪些方式</h2> <p>检测浏览器版本一共有两种方式：</p> <p>一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p> <p>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p> <h2 id="什么是-polyfil"><a href="#什么是-polyfil" class="header-anchor">#</a> 什么是 Polyfil</h2> <p>Polyfill 指的是用于<strong>实现浏览器并不支持的原生 API 的代码</strong>。比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p> <p>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</p> <h2 id="使用-js-实现获取文件扩展名"><a href="#使用-js-实现获取文件扩展名" class="header-anchor">#</a> 使用 JS 实现获取文件扩展名？</h2> <p><code>String.lastIndexOf()</code>方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。
对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1</p> <p>无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</p> <p><code>String.prototype.slice()</code> 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getFileExtension</span><span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> filename<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>filename<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="介绍一下-js-的节流与防抖"><a href="#介绍一下-js-的节流与防抖" class="header-anchor">#</a> 介绍一下 js 的节流与防抖</h2> <p><a href="/mian/base/jstimu.html#手写防抖-debouncing-和节流-throttling">防抖节流代码</a></p> <p><strong>高频率触发事件解决方案</strong></p> <p>相关知识点：</p> <p>函数防抖： 在<strong>事件被触发 n 秒后再执行回调</strong>，如果在这 n 秒内事件又被触发，则重新计时。</p> <p>函数节流： 规定一个单位时间，<strong>在这个单位时间内，只能有一次触发事件的回调函数执行</strong>，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p> <p>函数防抖的实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
      args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
    <span class="token comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 设置定时器，使事件间隔指定事件后执行</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用场景：</p> <ul><li>搜索框请求资源。</li> <li>window 触发 resize 的时候，不断的调整浏览器的窗口大小。</li></ul> <p>函数节流的实现;</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
      args <span class="token operator">=</span> arguments<span class="token punctuation">,</span>
      nowTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nowTime <span class="token operator">-</span> preTime <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      preTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用场景：</p> <ul><li>鼠标不停的点击按钮触发事件。</li> <li>监听滚动事件。</li></ul> <p>回答：</p> <p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，<strong>避免因为用户的多次点击向后端发送多次请求</strong>。函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。<strong>节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率</strong>。</p> <h2 id="object-is-符-与原来的比较操作符-、-的区别"><a href="#object-is-符-与原来的比较操作符-、-的区别" class="header-anchor">#</a> Object.is() 符 与原来的比较操作符 “===” 、“==” 的区别</h2> <p>相关知识点：</p> <p>两等号判等，会在比较时进行类型转换。</p> <p>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回 false）。</p> <p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，<strong>保证 -0 和 +0 不再相同</strong>，但 <strong>Object.is(NaN, NaN) 会返回 true</strong>.<strong>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</strong></p> <p>回答：</p> <p>使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</p> <p>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p> <p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它<strong>处理了一些特殊的情况</strong>，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</p> <h2 id="escape-encodeuri-encodeuricomponent-有什么区别"><a href="#escape-encodeuri-encodeuricomponent-有什么区别" class="header-anchor">#</a> escape,encodeURI,encodeURIComponent 有什么区别？</h2> <p>相关知识点：</p> <p>escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。</p> <p>它们的根本区别在于，<strong>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」</strong>，而 <strong>encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」</strong>；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</p> <p>回答：</p> <p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p> <p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p> <p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，<strong>escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %</strong>。</p> <h2 id="unicode-和-和-utf-8-之间的关系"><a href="#unicode-和-和-utf-8-之间的关系" class="header-anchor">#</a> Unicode 和 和 UTF-8 之间的关系</h2> <p>Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p> <h2 id="执行上下文与执行栈"><a href="#执行上下文与执行栈" class="header-anchor">#</a> 执行上下文与执行栈</h2> <p>执行上下文是一个抽象的概念，可以理解为是代码执行的一个环境。JS 的执行上下文分为三种，全局执行上下文、函数(局部)执行上下文、Eval 执行上下文。</p> <ul><li>全局执行上下文：全局执行上下文指的是全局 this 指向的 window ，可以是外部加载的 JS 文件或者本地 <code>&lt;scripe&gt;&lt;/script&gt;</code> 标签中的代码。</li> <li>函数执行上下文：函数上下文也称为局部上下文，每个函数被调用的时候，都会创建一个新的局部上下文。</li> <li>Eval 执行上下文： 这个不经常用，所以不多讨论</li></ul> <p>执行栈，就是我们数据结构中的“栈”，它具有“先进后出”的特点，正是因为这种特点，在我们代码进行执行的时候，遇到一个执行上下文就将其依次压入执行栈中。</p> <p>当代码执行的时候，先执行位于栈顶的执行上下文中的代码，当栈顶的执行上下文代码执行完毕就会出栈，继续执行下一个位于栈顶的执行上下文</p> <h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <p>执行上下文可以简单理解为一个对象:</p> <p>它包含三个部分:</p> <ul><li>变量对象(VO)</li> <li>作用域链(词法作用域)</li> <li>this 指向</li></ul> <p>它的类型:</p> <ul><li>全局执行上下文</li> <li>函数执行上下文</li> <li>eval 执行上下文</li></ul> <p>代码执行过程:</p> <ul><li>创建 全局上下文 (global EC)</li> <li>全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被 push 到执行栈顶层</li> <li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li> <li>函数执行完后，callee 被 pop 移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li></ul> <h2 id="js-的事件循环是什么"><a href="#js-的事件循环是什么" class="header-anchor">#</a> js 的事件循环是什么？</h2> <p>相关知识点：
事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</p> <p>回答：</p> <p>因为 js 是<strong>单线程</strong>运行的，在代码执行的时候，通过<strong>将不同函数的执行上下文压入执行栈中来保证代码的有序执</strong>行。在执行同步代码的时候，如果遇到了<strong>异步事件</strong>，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。<strong>任务队列</strong>可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p> <p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p> <p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</p> <h2 id="对-eventloop-事件循环机制的了解"><a href="#对-eventloop-事件循环机制的了解" class="header-anchor">#</a> 对 eventloop 事件循环机制的了解</h2> <p>首先，JavaScript 一大特点就是单线程，这样的设计让它在同一时间只做一件事；作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM，避免了复杂性，比如假设 JavaScript 有两个线程，那么在同一时间进行添加删除节点操作，为浏览器分辨以哪个线程为准带来困难，所以单线程是它作为浏览器脚本语言的优势，也是它的核心特征。</p> <div class="custom-block tip"><p class="custom-block-title">注</p> <p>虽然为了利用多核 CPU 的计算能力，HTML5 提出了 web worker 标准，允许 JavaScript 创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM，所以也并没有改变 JavaScript 单线程的本质</p></div> <p>那么，单线程就意味着，所有任务需要排队，前一个任务结束才会执行后一个任务，所以为了提高 CPU 的利用效率，就把所有任务分成了同步任务（synchronous）和异步任务（asynchronous），同步任务在主线程顺序执行，异步任务则不进入主线程而是进入到任务队列（task queue）中。在主线程上会形成一个执行栈，等执行栈中所有任务执行完毕之后，会去任务队列中查看有哪些事件，此时异步任务结束等待状态，进入执行栈中，开始执行。</p> <p>主线程从任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</p> <p><img src="/assets/img/03.355c7bcb.png" alt=""></p> <h2 id="js-单线程还是多线程-如何显示异步操作"><a href="#js-单线程还是多线程-如何显示异步操作" class="header-anchor">#</a> JS 单线程还是多线程，如何显示异步操作</h2> <p>JS 本身是单线程的，他是依靠浏览器完成的异步操作。</p> <p>解析：</p> <p>具体步骤，</p> <p>1、主线程 执行 js 中所有的代码。</p> <p>2、主线程 在执行过程中发现了需要异步的任务任务后扔给浏览器（浏览器创建多个线程执行），并在 callback queque 中创建对应的回调函数（回调函数是一个对象，包含该函数是否执行完毕等）。</p> <p>3、主线程 已经执行完毕所有同步代码。开始监听 callback queque 一旦 浏览器 中某个线程任务完成将会改变回调函数的状态。主线程查看到某个函数的状态为已完成，就会执行该函数。</p> <p><img src="/assets/img/danxiancheng.bd7c3aa1.png" alt=""></p> <h2 id="对宏任务和微任务的理解-微任务有哪些"><a href="#对宏任务和微任务的理解-微任务有哪些" class="header-anchor">#</a> 对宏任务和微任务的理解，微任务有哪些</h2> <table><thead><tr><th>#</th> <th style="text-align:center;">浏览器</th> <th>Node</th></tr></thead> <tbody><tr><td>I/O</td> <td style="text-align:center;">✅</td> <td>✅</td></tr> <tr><td>setTimeout</td> <td style="text-align:center;">✅</td> <td>✅</td></tr> <tr><td>setInterval</td> <td style="text-align:center;">✅</td> <td>✅</td></tr> <tr><td>setImmediate</td> <td style="text-align:center;">❌</td> <td>✅</td></tr> <tr><td>requestAnimationFrame</td> <td style="text-align:center;">✅</td> <td>❌</td></tr></tbody></table> <p>微任务包括：</p> <table><thead><tr><th>#</th> <th style="text-align:center;">浏览器</th> <th>Node</th></tr></thead> <tbody><tr><td>process.nextTick</td> <td style="text-align:center;">❌</td> <td>✅</td></tr> <tr><td>MutationObserver</td> <td style="text-align:center;">✅</td> <td>❌</td></tr> <tr><td>Promise.then catch finally</td> <td style="text-align:center;">✅</td> <td>✅</td></tr></tbody></table> <h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="header-anchor">#</a> 微任务和宏任务</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
 * 宏任务
 *   分类： setTimeout setInterval requrestAnimationFrame
 *   1. 宏任务所处的队列就是宏任务队列
 *   2. 第一个宏任务队列中只有一个任务： 执行主线程的js代码
 *   3. 宏任务队列可以有多个
 *   4. 当宏任务队列的中的任务全部执行完以后会查看是否有微任务队列如果有先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列
 *
 * 微任务
 *   分类： new Promise().then(回调) process.nextTick
 *   1. 微任务所处的队列就是微任务队列
 *   2. 只有一个微任务队列
 *   3. 在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务
 * */</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;----------------- start -----------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;setTimeout&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修改promise实例对象的状态为成功的状态</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;promise实例成功回调执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;----------------- end -----------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="js-中的深浅拷贝实现"><a href="#js-中的深浅拷贝实现" class="header-anchor">#</a> js 中的深浅拷贝实现</h2> <p>浅拷贝的实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 只拷贝对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token keyword">typeof</span> object <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据 object 的类型判断是新建一个数组还是对象</span>
  <span class="token keyword">let</span> newObject <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历 object，并且判断是 object 的属性才拷贝</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newObject<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="header-anchor">#</a> 深拷贝的实现</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>object <span class="token operator">||</span> <span class="token keyword">typeof</span> object <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newObject <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newObject<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span>
        <span class="token keyword">typeof</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">?</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> object<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</p> <p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。<strong>深拷贝对于一些对象可以使用 JSON 的两个函数来实现</strong>，<strong>但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</strong>。</p> <h2 id="手写-call-、apply-及-bind-函数"><a href="#手写-call-、apply-及-bind-函数" class="header-anchor">#</a> 手写 call 、apply 及 bind 函数</h2> <p>call 函数实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;type error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取参数</span>
  <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断 context 是否传入，如果未传入则设置为 window</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token comment">// 将调用函数设为对象的方法</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment">// 调用函数</span>
  result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将属性删除</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>call 函数的实现步骤：</p> <ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>处理传入的参数，截取第一个参数后的所有参数。</li> <li>将函数作为上下文对象的一个属性。</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性。</li> <li>返回结果</li></ul> <p>apply 函数实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象是否为函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 判断 context 是否存在，如果未传入则为 window</span>
  context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  <span class="token comment">// 将函数设为对象的方法</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token comment">// 调用方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将属性删除</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>apply 函数的实现步骤：</p> <ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li> <li>将函数作为上下文对象的一个属性。</li> <li>判断参数值是否传入</li> <li>使用上下文对象来调用这个方法，并保存返回结果。</li> <li>删除刚才新增的属性</li> <li>返回结果</li></ul> <p>bind 函数实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断调用对象是否为函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;Error&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 获取参数</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 根据调用方式，传入不同绑定值</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
      <span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fn</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span>
      args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>bind 函数的实现步骤：</p> <ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li> <li>保存当前函数的引用，获取其余传入参数值。</li> <li>创建一个函数返回</li> <li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul> <h2 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="header-anchor">#</a> 函数柯里化的实现</h2> <p>函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取函数需要的参数长度</span>
  <span class="token keyword">let</span> length <span class="token operator">=</span> fn<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  args <span class="token operator">=</span> args <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> subArgs <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 拼接得到现有的所有参数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subArgs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断参数的长度是否已经满足函数所需参数的长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subArgs<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果满足，执行函数</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> subArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span>
      <span class="token keyword">return</span> <span class="token function">curry</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> fn<span class="token punctuation">,</span> subArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>es6</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> fn<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> args<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">curry</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> fn<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>主要有三个作用：1. 参数复用；2. 提前返回；3. 延迟计算/运行</p> <ul><li>参数复用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 举个栗子：正则验证字符串</span>

<span class="token comment">// 函数封装后</span>
<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token parameter">reg<span class="token punctuation">,</span> txt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">check</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">check</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token comment">// 需要复用第一个reg参数，Currying后，将两个参数分开，可以直接调用hasNumber，hasL</span>
<span class="token keyword">function</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token parameter">reg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> hasNumber <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hasLetter <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">hasNumber</span><span class="token punctuation">(</span><span class="token string">&quot;test1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">hasLetter</span><span class="token punctuation">(</span><span class="token string">&quot;21212&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><ul><li>提前返回</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 比如：解决原生方法在现代浏览器和IE之间的兼容问题</span>

<span class="token comment">// 提前返回: 使用函数立即调用进行了一次兼容判断（部分求值），返回兼容的事件绑定方法</span>
<span class="token comment">// 延迟执行：返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行</span>
<span class="token keyword">const</span> addEvent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> type<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> isCapture</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ele<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> fn<span class="token punctuation">,</span> isCapture<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> type<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ele<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> type<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>延迟计算/运行</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// js中bind实现机制正是Currying</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">_this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="为什么-0-1-0-2-0-3-如何解决这个问题"><a href="#为什么-0-1-0-2-0-3-如何解决这个问题" class="header-anchor">#</a> 为什么 0.1 + 0.2 != 0.3？如何解决这个问题</h2> <p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，<strong>0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况</strong>。<strong>js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字</strong>，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行<strong>对阶的处理</strong>，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在<strong>对齐的过程中，有效数字会向右移动</strong>，<strong>移动后超过有效位数的位会被截取掉</strong>，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行<strong>相加运算后，得到的结果可能会超过 53 位有效数字</strong>，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p> <p><strong>解决：</strong></p> <p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p> <p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON</p> <p><strong>另一种解释：</strong></p> <p>主要是因为 JavaScript 同样采用 IEEE754 标准，在 64 位中存储一个数字的有效数字形式</p> <p><img src="/assets/img/02.dfaaf6e2.png" alt=""></p> <p>第 0 位表示符号位，0 表示整数 1 表示负数，第 1~11 位存储指数部分，第 12~63 位存小数部分</p> <p>由于二进制的有效数字总是表示为 1.xxx...  这样的形式，尾数部分在规约形式下的第一位默认为 1，故存储时第一位省略不写，尾数部分存储有效数字小数点后的 xxx...，最长 52 位，因此，JavaScript 提供的有效数字最长为 53 个二进制位（尾数部分 52 位+被省略的 1 位）</p> <p>由于需要对求和结果规格化(用有效数字表示)，右规导致低位丢失，此时需对丢失的低位进行舍入操作，遵循 IEEE754 舍入规则，会有精度损失</p> <h2 id="原码、反码和补码的介绍"><a href="#原码、反码和补码的介绍" class="header-anchor">#</a> 原码、反码和补码的介绍</h2> <p>原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</p> <p><strong>正数的反码和其原码一样；负数的反码，符号位为 1，数值部分按原码取反</strong>。</p> <p>如<code>[+7]</code>原 = 00000111，<code>[+7]</code>反 = 00000111； <code>[-7]</code>原 = 10000111，<code>[-7]</code>反 = 11111000。
正数的补码和其原码一样；负数的补码为其反码加 1。</p> <p>例如 <code>[+7]</code>原 = 00000111，<code>[+7]</code>反 = 00000111，<code>[+7]</code>补 = 00000111；<code>[-7]</code>原 = 10000111，<code>[-7]</code>反 = 11111000，<code>[-7]</code>补 = 11111001</p> <p>之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</p> <h2 id="toprecision-和-和-tofixed-和-和-math-round-的区别"><a href="#toprecision-和-和-tofixed-和-和-math-round-的区别" class="header-anchor">#</a> toPrecision 和 和 toFixed 和 和 Math.round 的区别</h2> <p>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。</p> <p>toFixed 是对小数点后指定位数取整，从小数点开始数起。</p> <p>Math.round 是将一个数字四舍五入到一个整数。</p> <h2 id="offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别"><a href="#offsetwidth-offsetheight-clientwidth-clientheight与scrollwidth-scrollheight的区别" class="header-anchor">#</a> <code>offsetWidth/offsetHeight</code>,<code>clientWidth/clientHeight</code>与<code>scrollWidth/scrollHeight</code>的区别</h2> <ul><li>clientWidth/clientHeight 返回的是<strong>元素的内部宽度</strong>，它的值只包含 content + padding，如果有滚动条，<strong>不包含滚动条</strong>。</li> <li>clientTop 返回的是<strong>上边框的宽度</strong>。</li> <li>clientLeft 返回的<strong>左边框的宽度</strong>。</li> <li>offsetWidth/offsetHeight 返回的是<strong>元素的布局宽度</strong>，它的值包含 <strong>content + padding +border 包含了滚动条</strong>。</li> <li>offsetTop 返回的是<strong>当前元素相对于其 offsetParent 元素的顶部的距离</strong>。</li> <li>offsetLeft 返回的是<strong>当前元素相对于其 offsetParent 元素的左部的距离</strong>。</li> <li>scrollWidth/scrollHeight 返回值包含 <strong>content + padding + 溢出内容的尺寸</strong>。</li> <li>scrollTop 属性返回的是<strong>一个元素的内容垂直滚动的像素数</strong>。</li> <li>scrollLeft 属性返回的是<strong>元素滚动条到元素左边的距离</strong>。</li></ul> <h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <p>简单说，<strong>&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论</strong>。</p> <p>它具有以下特性：<strong>闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;</strong>。</p> <h2 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="header-anchor">#</a> 异步编程的实现方式</h2> <p>相关资料：</p> <p>回调函数</p> <ul><li>优点：简单、容易理解</li> <li>缺点：不利于维护，代码耦合高</li></ul> <p>事件监听（采用时间驱动模式，取决于某个事件是否发生）：</p> <ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li> <li>缺点：事件驱动型，流程不够清晰</li></ul> <p>发布/订阅（观察者模式）</p> <ul><li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li></ul> <p>Promise 对象</p> <ul><li>优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</li> <li>缺点：编写和理解，相对比较难</li></ul> <p>Generator 函数</p> <ul><li>优点：函数体内外的数据交换、错误处理机制</li> <li>缺点：流程管理不方便</li></ul> <p>async 函数</p> <ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</li> <li>缺点：错误处理机制</li></ul> <p>回答：</p> <p>js 中的异步机制可以分为以下几种：</p> <p>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，<strong>多个回调函数嵌套的时候会造成回调函数地狱</strong>，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p> <p>第二种是 Promise 的方式，使用 Promise 的方式可以<strong>将嵌套的回调函数作为链式调用</strong>。但是使用这种方法，有时会<strong>造成多个 then 的链式调用，可能会造成代码的语义不够明确</strong>。</p> <p>第三种是使用 generator 的方式，它可以在函数的执行过程中，<strong>将函数的执行权转移出去</strong>，<strong>在函数外部我们还可以将执行权转移回</strong>来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我<strong>们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写</strong>。<strong>使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行</strong>。</p> <p>第四种是使用 async 函数的形式，<strong>async 函数是 generator 和 promise 实现的一个自动执行的语法糖</strong>，它<strong>内部自带执行器</strong>，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们<strong>可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行</strong>。</p> <h2 id="js-异步解决方案的发展历程以及优缺点"><a href="#js-异步解决方案的发展历程以及优缺点" class="header-anchor">#</a> JS 异步解决方案的发展历程以及优缺点</h2> <p>1、回调函数（callback）</p> <ul><li>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</li> <li>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</li></ul> <p>2、Promise</p> <ul><li>优点：解决了回调地狱的问题</li> <li>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</li></ul> <p>3、Generator</p> <ul><li>特点：可以控制函数的执行，可以配合 co 函数库使用</li></ul> <p>4、Async/await</p> <ul><li>优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</li> <li>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</li></ul> <h2 id="js-与-动画与-css-动画区别及相应实现"><a href="#js-与-动画与-css-动画区别及相应实现" class="header-anchor">#</a> Js 与 动画与 CSS 动画区别及相应实现</h2> <ul><li>CSS3 的动画的优点:在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单</li> <li>缺点:在动画控制上不够灵活兼容性不好</li></ul> <p>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。<strong>对于一些复杂控制的动画，使用 javascript 会比较靠谱</strong>。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</p> <h2 id="mouseover-和-和-mouseenter-的区别"><a href="#mouseover-和-和-mouseenter-的区别" class="header-anchor">#</a> mouseover 和 和 mouseenter 的区别</h2> <p>当<strong>鼠标移动到元素上时就会触发 mouseenter 事件</strong>，类似 mouseover，它们两者之间的差别是<strong>mouseenter 不会冒泡</strong>。</p> <p>由于 <strong>mouseenter 不支持事件冒泡</strong>，导致在一个元素的子元素上进入或离开的时候<strong>会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件</strong></p> <h2 id="js-拖拽功能的实现"><a href="#js-拖拽功能的实现" class="header-anchor">#</a> js 拖拽功能的实现</h2> <p>相关知识点：</p> <p>首先是三个事件，分别是 mousedown，mousemove，mouseup 当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。</p> <p><strong>clientX，clientY 标识的是鼠标的坐标</strong>，分别标识横坐标和纵坐标，并且我们<strong>用 offsetX 和 offsetY 来表示元素的元素的初始坐标</strong>，移动的举例应该是：鼠标移动时候的坐标-鼠标按下去时候的坐标。也就是说<strong>定位信息为：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft</strong>.</p> <p>回答：</p> <p>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。</p> <p>这三步分别对应了三个事件，<strong>mousedown 事件，mousemove 事件和 mouseup 事件</strong>。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要<strong>在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态</strong>。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后<strong>在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标</strong>。最后 mouseup 事件触发后，清除状态，结束拖拽事件。</p> <h2 id="兼容各种浏览器版本的事件绑定"><a href="#兼容各种浏览器版本的事件绑定" class="header-anchor">#</a> 兼容各种浏览器版本的事件绑定</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
兼容低版本IE，ele为需要绑定事件的元素，
eventName为事件名（保持addEventListener语法，去掉on），fun为事件响应函数
*/</span>

<span class="token keyword">function</span> <span class="token function">addEvent</span><span class="token punctuation">(</span><span class="token parameter">ele<span class="token punctuation">,</span> eventName<span class="token punctuation">,</span> fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ele<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> fun<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    ele<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;on&quot;</span> <span class="token operator">+</span> eventNme<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么使用-settimeout-实现-setinterval-怎么模拟"><a href="#为什么使用-settimeout-实现-setinterval-怎么模拟" class="header-anchor">#</a> 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h2> <p>相关知识点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span>
<span class="token keyword">function</span> <span class="token function">mySetInterval</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> timeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 控制器，控制定时器是否继续执行</span>
  <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token punctuation">{</span>
    flag<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置递归函数，模拟定时器执行。</span>
  <span class="token keyword">function</span> <span class="token function">interval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">.</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 启动定时器</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回控制器</span>
  <span class="token keyword">return</span> timer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>回答：</p> <p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是<strong>每隔一段时间将事件加入事件队列中去</strong>，<strong>只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行</strong>。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p> <p>针对 setInterval 的这个缺点，我们可以<strong>使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题</strong>。</p> <h2 id="settimeout-用作倒计时为什么会产生误差"><a href="#settimeout-用作倒计时为什么会产生误差" class="header-anchor">#</a> setTimeout 用作倒计时为什么会产生误差</h2> <p>因为 setTimeout 属于宏任务，那么如果当前 执行栈 所花费的时间大于 定时器 时间，那么定时器的回调在 宏任务 里，来不及去调用，所有这个时间会有误差</p> <h2 id="如何检测浏览器所支持的最小字体大小"><a href="#如何检测浏览器所支持的最小字体大小" class="header-anchor">#</a> 如何检测浏览器所支持的最小字体大小？</h2> <p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p> <h2 id="怎么做-js-码-代码-error-统计"><a href="#怎么做-js-码-代码-error-统计" class="header-anchor">#</a> 怎么做 JS 码 代码 Error 统计</h2> <p>error 统计使用浏览器的 window.error 事件。</p> <h2 id="如何封装一个-javascript-的类型判断函数"><a href="#如何封装一个-javascript-的类型判断函数" class="header-anchor">#</a> 如何封装一个 javascript 的类型判断函数</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断数据是 null 的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 判断数据是引用类型的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> valueClass <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span>
      type <span class="token operator">=</span> valueClass<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    type<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> type<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断数据是基本数据类型的情况和函数的情况</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="如何判断一个对象是否为空对象"><a href="#如何判断一个对象是否为空对象" class="header-anchor">#</a> 如何判断一个对象是否为空对象？</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkNullObj</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="使用闭包实现每隔一秒打印-1-2-3-4"><a href="#使用闭包实现每隔一秒打印-1-2-3-4" class="header-anchor">#</a> 使用闭包实现每隔一秒打印 1,2,3,4</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用闭包实现</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用 let 块级作用域</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="自执行函数-用于什么场景-好处"><a href="#自执行函数-用于什么场景-好处" class="header-anchor">#</a> 自执行函数?用于什么场景？好处?</h2> <p>自执行函数: 1、声明一个匿名函数 2、马上调用这个匿名函数。</p> <p>作用：创建一个独立的作用域。</p> <p>好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理</p> <p>场景：一般用于框架、插件等场景</p> <h2 id="手写一个-jsonp"><a href="#手写一个-jsonp" class="header-anchor">#</a> 手写一个 jsonp</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 判断是否含有参数</span>
  <span class="token keyword">let</span> queryString <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;?&quot;</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;-1&quot;</span> <span class="token operator">?</span> <span class="token string">&quot;?&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;&amp;&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">// 添加参数</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      queryString <span class="token operator">+=</span> k <span class="token operator">+</span> <span class="token string">&quot;=&quot;</span> <span class="token operator">+</span> params<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;&amp;&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 处理回调函数名</span>
  <span class="token keyword">let</span> random <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    callbackName <span class="token operator">=</span> <span class="token string">&quot;myJsonp&quot;</span> <span class="token operator">+</span> random<span class="token punctuation">;</span>
  <span class="token comment">// 添加回调函数</span>
  queryString <span class="token operator">+=</span> <span class="token string">&quot;callback=&quot;</span> <span class="token operator">+</span> callbackName<span class="token punctuation">;</span>
  <span class="token comment">// 构建请求</span>
  <span class="token keyword">let</span> scriptNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  scriptNode<span class="token punctuation">.</span>src <span class="token operator">=</span> url <span class="token operator">+</span> queryString<span class="token punctuation">;</span>
  window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用回调函数</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除这个引入的脚本</span>
    document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 发起请求</span>
  document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;head&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="手写一个观察者模式"><a href="#手写一个观察者模式" class="header-anchor">#</a> 手写一个观察者模式</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> topics <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token comment">// 注册监听函数</span>
    <span class="token function-variable function">subscribe</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">topic<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topics<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 发布事件，触发观察者回调事件</span>
    <span class="token function-variable function">publish</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">topic<span class="token punctuation">,</span> info</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>topics<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">handler</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 移除主题的一个观察者的回调事件</span>
    <span class="token function-variable function">remove</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">topic<span class="token punctuation">,</span> handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topics<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> handlerIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
      topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">===</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          handlerIndex <span class="token operator">=</span> index<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>handlerIndex <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>handlerIndex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 移除主题的所有观察者的回调事件</span>
    <span class="token function-variable function">removeAll</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">topic</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>topics<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        topics<span class="token punctuation">[</span>topic<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="eventemitter-实现"><a href="#eventemitter-实现" class="header-anchor">#</a> EventEmitter 实现</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> callbacks <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> callbacks<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">off</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> callbacks <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> callbacks <span class="token operator">&amp;&amp;</span> callbacks<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fn <span class="token operator">!==</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> callbacks <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">;</span>
    callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">once</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token function-variable function">wrapFun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> wrapFun<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> wrapFun<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="一道常被人轻视的前端-js-面试题"><a href="#一道常被人轻视的前端-js-面试题" class="header-anchor">#</a> 一道常被人轻视的前端 JS 面试题</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//请写出以下输出结果：</span>
Foo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">new</span> <span class="token class-name">Foo<span class="token punctuation">.</span>getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token keyword">new</span> <span class="token class-name">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><h2 id="如何确定页面的可用性时间-什么是-performance-api"><a href="#如何确定页面的可用性时间-什么是-performance-api" class="header-anchor">#</a> 如何确定页面的可用性时间，什么是 <code>Performance API</code></h2> <p>Performance API 用于<strong>精确度量、控制、增强浏览器的性能表现</strong>。这个 API 为测量网站性能，提供以前没有办法做到的精度。</p> <p>使用 getTime 来计算脚本耗时的缺点，首先，<strong>getTime 方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一）</strong>，想要得到更小的时间差别就无能为力了。其次，<strong>这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度</strong>，比如浏览器用了多少时间从服务器加载网页。</p> <p>为了解决这两个不足之处，ECMAScript 5 引入“<strong>高精度时间戳</strong>”这个 API，部署在 performance 对象上。它的<strong>精度可以达到 1 毫秒的千分之一（1 秒的百万分之一）</strong>。</p> <p>navigationStart：<strong>当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳</strong>。如果没有前一个网页，则等于 fetchStart 属性。</p> <p>loadEventEnd：<strong>返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳</strong>。如果该事件还没有发生，返回 0。</p> <p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p> <p><code>var t = performance.timing;var pageLoadTime = t.loadEventEnd -t.navigationStart;</code></p> <h2 id="js-中的命名规则"><a href="#js-中的命名规则" class="header-anchor">#</a> js 中的命名规则</h2> <p>（1）第一个字符必须是字母、下划线（<code>_</code>）或美元符号（<code>$</code>）</p> <p>（2）余下的字符可以是下划线、美元符号或任何字母或数字字符一般我们推荐使用<strong>驼峰法</strong>来对变量名进行命名，因为这样可以<strong>与 ECMAScript 内置的函数和对象命名格式保持一致</strong>。</p> <h2 id="js-语句末尾分号是否可以省略"><a href="#js-语句末尾分号是否可以省略" class="header-anchor">#</a> js 语句末尾分号是否可以省略？</h2> <p>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为<strong>加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误</strong>。</p> <h2 id="自动分号"><a href="#自动分号" class="header-anchor">#</a> 自动分号</h2> <p>有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic SemicolonInsertion，ASI）。</p> <p>因为如果缺失了必要的 ; ，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的。</p> <p>请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号。</p> <p>如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。</p> <h2 id="object-assign"><a href="#object-assign" class="header-anchor">#</a> <code>Object.assign()</code></h2> <p><code>Object.assign()</code> 方法用于<strong>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</strong>。</p> <h2 id="math-ceil-和-math-floor"><a href="#math-ceil-和-math-floor" class="header-anchor">#</a> Math.ceil 和 Math.floor</h2> <p>Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</p> <p>Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</p> <h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="header-anchor">#</a> js for 循环注意点</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">,</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span>
<span class="token comment">// 当判断语句为空时，循环会一直进行。</span>
</code></pre></div><h2 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="header-anchor">#</a> for in 和 for of</h2> <p>1、for in</p> <ol><li>一般用于<strong>遍历对象的可枚举属性</strong>。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。</li> <li>不建议使用 for in 遍历数组，因为输出的顺序是不固定的。</li> <li>如<strong>果迭代的对象的变量值是 null 或者 undefined, for in 不执行循环体，建议在使用 for in 循环之前，先检查该对象的值是不是 null 或者 undefined</strong></li></ol> <p>2、for of</p> <ol><li>for…of 语句<strong>在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环</strong>，调用自定义迭代钩子，并为每个不同属性的值执行语句</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  c<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> prop <span class="token keyword">in</span> s1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//a b c</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1 2 3</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">of</span> s1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错如下 Uncaught TypeError: s1 is not iterable</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> prop <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a b c</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1 2 3</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="for-in、object-keys-和-object-getownpropertynames-对属性遍历有什么区别"><a href="#for-in、object-keys-和-object-getownpropertynames-对属性遍历有什么区别" class="header-anchor">#</a> for in、Object.keys 和 Object.getOwnPropertyNames 对属性遍历有什么区别？</h2> <ul><li>for in 会遍历自身及原型链上的可枚举属性</li> <li>Object.keys 会将对象自身的可枚举属性的 key 输出</li> <li>会将自身所有的属性的 key 输出</li></ul> <p>解析：</p> <p>ECMAScript 将对象的属性分为两种：数据属性和访问器属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> parent <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// parent继承自Object.prototype，有一个可枚举的属性a（enumerable:true）。</span>

<span class="token keyword">var</span> child <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  b<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  c<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//child 继承自 parent ，b可枚举，c不可枚举</span>
</code></pre></div><p><strong>for in</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// b</span>
<span class="token comment">// a</span>
<span class="token comment">// for in 会遍历自身及原型链上的可枚举属性</span>
</code></pre></div><p><strong>如果只想输出自身的可枚举属性</strong>，可使用 hasOwnProperty 进行判断(数组与对象都可以，此处用数组做例子)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>xxx <span class="token operator">=</span> <span class="token number">1231235</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
</code></pre></div><p><strong>Object.keys</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [&quot;b&quot;]</span>
<span class="token comment">// Object.keys 会将对象自身的可枚举属性的key输出</span>
</code></pre></div><p><strong>Object.getOwnPropertyNames</strong></p> <div class="language-JS extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [&quot;b&quot;,&quot;c&quot;]</span>
<span class="token comment">// 会将自身所有的属性的key输出</span>
</code></pre></div><h2 id="一个列表-假设有-100000-个数据-这个该怎么办"><a href="#一个列表-假设有-100000-个数据-这个该怎么办" class="header-anchor">#</a> 一个列表，假设有 100000 个数据，这个该怎么办</h2> <p>我们需要思考的问题：该处理<strong>是否必须同步</strong>完成？数据<strong>是否必须按顺序</strong>完成？</p> <p>解决办法：</p> <p>（1）将<strong>数据分页</strong>，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</p> <p>（2）使用<strong>懒加载的方法</strong>，每次加载一部分数据，其余数据当需要使用时再去加载。</p> <p>（3）使用<strong>数组分块技术</strong>，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</p> <h2 id="列表无限滚动曾经有遇到过嘛"><a href="#列表无限滚动曾经有遇到过嘛" class="header-anchor">#</a> 列表无限滚动曾经有遇到过嘛</h2> <p>简单列表滚动加载是监听滚动条在满足条件的时候触发回调，然后通过把新的元素加入到页面页尾的方法完成，但是如果用户加载过多列表数据(比如我这一个列表页有一万条数据需要展示)，那么用户不断加载，页面不断增加新的元素，很容易就导致页面元素过多而造成卡顿，所以就提出的列表的无限滚动加载，主要是在删除原有元素并且维持高度的基础上，生成并加载新的数据</p> <h2 id="js-中倒计时的纠偏实现"><a href="#js-中倒计时的纠偏实现" class="header-anchor">#</a> js 中倒计时的纠偏实现</h2> <p>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会<strong>存在时间偏差的问题</strong>，这是由于 <strong>js 的程序执行机制造成</strong>的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</p> <p>一般解决倒计时中的误差的有这样两种办法：</p> <p>（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来<strong>校准倒计时时间</strong>。</p> <p>（2）第二种方法是前端<strong>根据偏差时间来自动调整间隔时间的方式来实现的</strong>。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p> <h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="header-anchor">#</a> 进程间通信的方式？</h2> <ul><li>1.<strong>管道</strong>通信</li> <li>2.<strong>消息队列</strong>通信</li> <li>3.<strong>信号量</strong>通信</li> <li>4.<strong>信号</strong>通信</li> <li>5.<strong>共享内存</strong>通信</li> <li>6.<strong>套接字</strong>通信</li></ul> <h2 id="如何查找一篇英文文章中出现频率最高的单词"><a href="#如何查找一篇英文文章中出现频率最高的单词" class="header-anchor">#</a> 如何查找一篇英文文章中出现频率最高的单词</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">findMostWord</span><span class="token punctuation">(</span><span class="token parameter">article</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 合法性判断</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>article<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token comment">// 参数处理</span>
  article <span class="token operator">=</span> article<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> wordList <span class="token operator">=</span> article<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    maxNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    maxWord <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  article <span class="token operator">=</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> wordList<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历判断单词出现次数</span>
  wordList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 加入 visited</span>
      visited<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> word <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span> <span class="token operator">+</span> item <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;g&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        num <span class="token operator">=</span> article<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> maxNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxNum <span class="token operator">=</span> num<span class="token punctuation">;</span>
        maxWord <span class="token operator">=</span> item<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> maxWord <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> maxNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="document-load-和-document-ready-的区别"><a href="#document-load-和-document-ready-的区别" class="header-anchor">#</a> document load 和 document ready 的区别</h2> <p>页面加载完成有两种事件</p> <ol><li><p>load 是当页面所有资源全部加载完成后（包括 DOM 文档树，css 文件，js 文件，图片资源等），执行一个函数
问题：如果图片资源较多，加载时间较长，onload 后等待执行的函数需要等待较长时间，所以一些效果可能受到影响</p></li> <li><p><code>$(document).ready()</code>是当 DOM 文档树加载完成后执行一个函数 （不包含图片，css 等）所以会比 load 较快执行
在原生的 js 中不包括<code>ready()</code>这个方法，只有 load 方法也就是 onload 事件</p></li></ol> <h2 id="h5-与-native-如何交互"><a href="#h5-与-native-如何交互" class="header-anchor">#</a> H5 与 Native 如何交互</h2> <p>jsBridge</p> <h2 id="script-标签的-defer-和-asnyc-属性的作用以及二者的区别"><a href="#script-标签的-defer-和-asnyc-属性的作用以及二者的区别" class="header-anchor">#</a> <code>&lt;script&gt;</code>标签的 defer 和 asnyc 属性的作用以及二者的区别？</h2> <p>1、defer 和 async 的网络加载过程是一致的，都是异步执行。</p> <p>2、区别在于加载完成之后什么时候执行，可以看出 defer 是文档所有元素解析完成之后才执行的。</p> <p>3、如果存在多个 defer 脚本，那么它们是按照顺序执行脚本的，而 async，无论声明顺序如何，只要加载完成就立刻执行</p> <p>无论<code>&lt;script&gt;</code>标签是嵌入代码还是引用外部文件，只要不包含 defer 属性和 async 属性（这两个属性只对外部文件有效），浏览器会按照<code>&lt;script&gt;</code>的出现顺序对他们依次进行解析，也就是说，只有在第一个<code>&lt;script&gt;</code>中的代码执行完成之后，浏览器才会执行第二个<code>&lt;script&gt;</code>中的代码，并且在解析时，页面的处理会暂时停止。</p> <p>嵌入代码的解析=执行 外部文件的解析=下载+执行</p> <p>script 标签存在两个属性，defer 和 async，这两个属性<strong>只对外部文件有效</strong></p> <p><strong>只有一个脚本的情况</strong></p> <p><code>&lt;script src=&quot;a.js&quot; /&gt;</code></p> <p>没有 defer 或 async 属性，浏览器会立即下载并执行相应的脚本，并且在下载和执行时页面的处理会停止。</p> <p><code>&lt;script defer src=&quot;a.js&quot; /&gt;</code></p> <p>有了 defer 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，等到文档解析完成脚本才会执行。</p> <p><code>&lt;script async src=&quot;a.js&quot; /&gt;</code></p> <p>有了 async 属性，浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，下载完成后立即执行，执行过程中页面处理会停止。</p> <p><code>&lt;script defer async src=&quot;a.js&quot; /&gt;</code></p> <p>如果同时指定了两个属性,则会遵从 async 属性而忽略 defer 属性。</p> <p>下图可以直观的看出三者之间的区别:</p> <p><img src="/assets/img/script.bf5b043e.png" alt=""></p> <p>其中蓝色代表 js 脚本网络下载时间，红色代表 js 脚本执行，绿色代表 html 解析。</p> <p><strong>多个脚本的情况</strong></p> <p>这里只列举两个脚本的情况：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;a.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;b.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>没有 defer 或 async 属性，浏览器会立即下载并执行脚本 a.js，在 a.js 脚本执行完成后才会下载并执行脚本 b.js，在脚本下载和执行时页面的处理会停止。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>有了 defer 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，等到文档解析完成才会执行这两个脚本。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。 在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>b.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>有了 async 属性，浏览器会立即下载相应的脚本 a.js 和 b.js，在下载的过程中页面的处理不会停止，a.js 和 b.js 哪个先下载完成哪个就立即执行，执行过程中页面处理会停止，但是其他脚本的下载不会停止。标记为 async 的脚本并不保证按照制定它们的先后顺序执行。异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p> <h2 id="什么是面向对象"><a href="#什么是面向对象" class="header-anchor">#</a> 什么是面向对象？</h2> <p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p> <p>解析：</p> <ul><li>面向对象和面向过程的异同</li> <li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</li> <li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul> <h2 id="你对松散类型的理解"><a href="#你对松散类型的理解" class="header-anchor">#</a> 你对松散类型的理解</h2> <p>JavaScript 中的变量为松散类型，所谓松散类型就是指当一个变量被申明出来就可以保存任意类型的值，就是不像 SQL 一样申明某个键值为 int 就只能保存整型数值，申明 varchar 只能保存字符串。一个变量所保存值的类型也可以改变，这在 JavaScript 中是完全有效的，只是不推荐。相比较于将变量理解为“盒子“，《JavaScript 编程精解》中提到应该将变量理解为“触手”，它不保存值，而是抓取值。这一点在当变量保存引用类型值时更加明显。</p> <p>JavaScript 中变量可能包含两种不同的数据类型的值：基本类型和引用类型。基本类型是指简单的数据段，而引用类型指那些可能包含多个值的对象。</p> <h2 id="js-严格模式和正常模式"><a href="#js-严格模式和正常模式" class="header-anchor">#</a> JS 严格模式和正常模式</h2> <p>严格模式使用&quot;use strict&quot;;</p> <p>作用：</p> <ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li> <li>消除代码运行的一些不安全之处，保证代码运行的安全；</li> <li>提高编译器效率，增加运行速度；</li> <li>为未来新版本的 Javascript 做好铺垫。</li></ul> <p>表现：</p> <ul><li>严格模式下, delete 运算符后跟随非法标识符(即 delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回 false</li> <li>严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错</li> <li>严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会</li> <li>严格模式不允许八进制整数直接量（如：023）</li> <li>严格模式中，<strong>arguments 对象是传入函数内实参列表的静态副本；非严格模式下，arguments 对象里的元素和对应的实参是指向同一个值的引用</strong></li> <li>严格模式中 eval 和 arguments 当做关键字，它们不能被赋值和用作变量声明</li> <li>严格模式会限制对调用栈的检测能力，<strong>访问 arguments.callee.caller 会抛出异常</strong></li> <li>严格模式 变量必须先声明，直接给变量赋值，<strong>不会隐式创建全局变量</strong>，不能用 with,</li> <li>严格模式中 call apply 传入 null undefined 保持原样不被转换为 window</li></ul> <p>解析：</p> <p>一、概述</p> <p>除了正常运行模式，ECMAscript 5 添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。顾名思义，这种模式使得 Javascript 在更严格的条件下运行。</p> <p>设立&quot;严格模式&quot;的目的，主要有以下几个：</p> <p>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</p> <p>消除代码运行的一些不安全之处，保证代码运行的安全；</p> <p>提高编译器效率，增加运行速度；</p> <p>为未来新版本的 Javascript 做好铺垫。</p> <p>&quot;严格模式&quot;体现了 Javascript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p> <p>另一方面，同样的代码，在&quot;严格模式&quot;中，可能会有不一样的运行结果；一些在&quot;正常模式&quot;下可以运行的语句，在&quot;严格模式&quot;下将不能运行。掌握这些内容，有助于更细致深入地理解 Javascript，让你变成一个更好的程序员。</p> <p>本文将对&quot;严格模式&quot;做详细介绍。</p> <p>二、进入标志</p> <p>进入&quot;严格模式&quot;的标志，是下面这行语句：</p> <p>&quot;use strict&quot;;</p> <p>老版本的浏览器会把它当作一行普通字符串，加以忽略。</p> <p>三、如何调用</p> <p>&quot;严格模式&quot;有两种调用方法，适用于不同的场合。</p> <p>3.1 针对整个脚本文件</p> <p>将&quot;use strict&quot;放在脚本文件的第一行，则整个脚本都将以&quot;严格模式&quot;运行。如果这行语句不在第一行，则无效，整个脚本以&quot;正常模式&quot;运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p> <p>(严格地说，只要前面不是产生实际运行结果的语句，&quot;use strict&quot;可以不在第一行，比如直接跟在一个空的分号后面。)</p> <div class="language-js extra-class"><pre class="language-js"><code>　　<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
　　　　<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;这是严格模式。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
　　<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

　　<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
　　　　console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;这是正常模式。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>kly<span class="token punctuation">,</span> it<span class="token string">'s almost 2 years ago now. I can admit it now - I run it on my school'</span>s network that has about <span class="token number">50</span> computers<span class="token punctuation">.</span>
　　<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>上面的代码表示，一个网页中依次有两段 Javascript 代码。前一个 script 标签是严格模式，后一个不是。</p> <p>3.2 针对单个函数</p> <p>将&quot;use strict&quot;放在函数体的第一行，则整个函数以&quot;严格模式&quot;运行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">strict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">&quot;这是严格模式。&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">notStrict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;这是正常模式。&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3.3 脚本文件的变通写法</p> <p>因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span> <span class="token comment">// some code here</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>四、语法和行为改变</p> <p>严格模式对 Javascript 的语法和行为，都做了一些改变。</p> <p>4.1 全局变量显式声明</p> <p>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 报错，v未声明</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 报错，i未声明</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此，严格模式下，变量都必须先用 var 命令声明，然后再使用。</p> <p>4.2 静态绑定</p> <p>Javascript 语言的一个特点，<strong>就是允许&quot;动态绑定&quot;</strong>，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p> <p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p> <p>具体来说，涉及以下几个方面。</p> <p>（1）禁止使用 with 语句</p> <p>因为 with 语句无法在编译时就确定，属性到底归属哪个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">with</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 语法错误</span>
  v <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>（2）创设 eval 作用域</p> <p>正常模式下，Javascript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval 作用域。</p> <p>正常模式下，eval 语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval 语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于 eval 内部。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">&quot;var x = 5; x&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>

console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>4.3 增强的安全措施</p> <p>（1）禁止 this 关键字指向全局对象</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span>
</code></pre></div><p>因此，使用构造函数时，如果忘了加 new，this 不再指向全局对象，而是报错。</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错，this未定义</span>
</code></pre></div><p>（2）禁止在函数内部遍历调用栈</p> <div class="language-JS extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  f1<span class="token punctuation">.</span>caller<span class="token punctuation">;</span> <span class="token comment">// 报错</span>

  f1<span class="token punctuation">.</span>arguments<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>

<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>4.4 禁止删除变量</p> <p>严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除。</p> <div class="language-JS extra-class"><pre class="language-js"><code>　　<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

　　<span class="token keyword">var</span> x<span class="token punctuation">;</span>

　　<span class="token keyword">delete</span> x<span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>

　　<span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
　　　　　　value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
　　　　　　configurable<span class="token operator">:</span> <span class="token boolean">true</span>
　　<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

　　<span class="token keyword">delete</span> o<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// 删除成功</span>
</code></pre></div><p>4.5 显式报错</p> <p>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;v&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

o<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

o<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>

o<span class="token punctuation">.</span>v <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>严格模式下，删除一个不可删除的属性，会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">delete</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>4.6 重名错误</p> <p>严格模式新增了一些语法错误。</p> <p>（1）对象不能有重名的属性</p> <p>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  p<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  p<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>
</code></pre></div><p>（2）函数不能有重名的参数</p> <p>正常模式下，如果函数有多个重名的参数，可以用 <code>arguments[i]</code>读取。严格模式下，这属于语法错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 语法错误</span>

  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4.7 禁止八进制表示法</p> <p>正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">0100</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>
</code></pre></div><p>4.8 arguments 对象的限制</p> <p>arguments 是函数的参数对象，严格模式对它的使用做了限制。</p> <p>（1）不允许对 arguments 赋值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

arguments<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">set</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token parameter">arguments</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 语法错误</span>

<span class="token keyword">function</span> <span class="token function">arguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 语法错误</span>

<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;arguments&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;'use strict'; return 17;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>
</code></pre></div><p>（2）arguments 不再追踪参数的变化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 正常模式为[2,2]</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 严格模式为[2,1]</span>
</code></pre></div><p>（3）禁止使用 arguments.callee</p> <p>这意味着，你无法在匿名函数内部调用自身了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arguments<span class="token punctuation">.</span>callee<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre></div><p>4.9 函数必须声明在顶层</p> <p>将来 Javascript 的新版本会引入&quot;块级作用域&quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 语法错误</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 语法错误</span>
<span class="token punctuation">}</span>
</code></pre></div><p>4.10 保留字</p> <p>为了向将来 Javascript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</p> <p>使用这些词作为变量名将会报错。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">package</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">protected</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 语法错误</span>

  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> <span class="token keyword">implements</span><span class="token punctuation">;</span> <span class="token comment">// 语法错误</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此外，ECMAscript 第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的 const 保留字，也是不能作为变量名的。</p> <h2 id="sort-排序原理"><a href="#sort-排序原理" class="header-anchor">#</a> sort 排序原理</h2> <p>答案：冒泡排序法</p> <p>解析：</p> <p>冒泡排序法的原理：</p> <ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li> <li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li> <li>针对所有的元素重复以上的步骤，除了最后一个。</li> <li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul> <p>示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// sort()方法的比较逻辑为：</span>
<span class="token comment">// 第一轮：1和5比，1和4比，1和2比</span>
<span class="token comment">// 第二轮：5和4比，5和2比</span>
<span class="token comment">// 第三轮：4和2比</span>
<span class="token comment">// 一.sort排序规则 return大于0则交换数组相邻2个元素的位置</span>
<span class="token comment">// 二.arr.sort(function (a,b) {})中</span>
<span class="token comment">//         a --&gt;代表每一次执行匿名函时候，找到的数组中的当前项；</span>
<span class="token comment">//         b --&gt;代表当前项的后一项；</span>

<span class="token comment">// 1.升序</span>
<span class="token keyword">var</span> apple <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">147</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">74</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// ①默认法,缺点:只根据首位排序</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>apple<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ②指定排序规则法,return可返回任何值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
  apple<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment">//若return返回值大于0(即a＞b),则a,b交换位置</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//2.降序</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">74</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
  apple<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span> <span class="token comment">//若return返回值大于零(即b＞a),则a,b交换位置</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="如何实现文件断点续传"><a href="#如何实现文件断点续传" class="header-anchor">#</a> 如何实现文件断点续传</h2> <p>答案：断点续传最核心的内容就是把**文件“切片”**然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。</p> <p>首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。</p> <p>因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。</p> <p>前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。</p> <p>当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。</p> <p>只要用 slice 方法就可以了</p> <p><code>var packet = file.slice(start, end);</code></p> <p>参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块</p> <p>如:</p> <div class="language-js extra-class"><pre class="language-js"><code>file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ......</span>
</code></pre></div><p>在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。</p> <h2 id="如何做到修改-url-参数页面不刷新"><a href="#如何做到修改-url-参数页面不刷新" class="header-anchor">#</a> 如何做到修改 url 参数页面不刷新</h2> <p>HTML5 引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> stateObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>history.pushState(stateObj, &quot;page 2&quot;, &quot;bar.html&quot;);
假设当前页面为 foo.html，执行上述代码后会变为 bar.html，点击浏览器后退，会变为 foo.html，但浏览器并不会刷新。 pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：</p> <p>状态对象 — 状态对象 state 是一个 JavaScript 对象，通过 pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate 事件就会被触发，且该事件的 state 属性包含该历史记录条目状态对象的副本。 状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 pushState() 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.</p> <p>标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 state 传递一个短标题。</p> <p>URL — 该参数定义了新的历史 URL 记录。注意，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前 URL。</p> <h2 id="事件绑定与普通事件有什么区别"><a href="#事件绑定与普通事件有什么区别" class="header-anchor">#</a> 事件绑定与普通事件有什么区别</h2> <ul><li>用普通事件添加相同事件，下面会覆盖上面的，而事件绑定不会</li> <li>普通事件是针对非 dom 元素，事件绑定是针对 dom 元素的事件</li></ul> <h2 id="ie-和-dom-事件流的区别"><a href="#ie-和-dom-事件流的区别" class="header-anchor">#</a> IE 和 DOM 事件流的区别</h2> <p>1.事件流的区别</p> <p>IE 采用冒泡型事件 Netscape 使用捕获型事件 DOM 使用先捕获后冒泡型事件 示例：</p> <p>复制代码代码如下:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>点击这里<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>冒泡型事件模型： button-&gt;div-&gt;body (IE 事件流)</p> <p>捕获型事件模型： body-&gt;div-&gt;button (Netscape 事件流)</p> <p>DOM 事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)</p> <p>2.事件侦听函数的区别</p> <p>IE 使用:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>Object<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;name_of_event_handler&quot;</span><span class="token punctuation">,</span> fnHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绑定函数</span>
<span class="token punctuation">[</span>Object<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">detachEvent</span><span class="token punctuation">(</span><span class="token string">&quot;name_of_event_handler&quot;</span><span class="token punctuation">,</span> fnHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//移除绑定</span>
</code></pre></div><p>DOM 使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>Object<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;name_of_event&quot;</span><span class="token punctuation">,</span> fnHandler<span class="token punctuation">,</span> bCapture<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//绑定函数</span>
<span class="token punctuation">[</span>Object<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;name_of_event&quot;</span><span class="token punctuation">,</span> fnHandler<span class="token punctuation">,</span> bCapture<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//移除绑定</span>
</code></pre></div><p>bCapture 参数用于设置事件绑定的阶段，true 为捕获阶段，false 为冒泡阶段。</p> <h2 id="ie-和标准下有哪些兼容性的写法"><a href="#ie-和标准下有哪些兼容性的写法" class="header-anchor">#</a> IE 和标准下有哪些兼容性的写法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth <span class="token operator">||</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>
<span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>srcElement <span class="token operator">||</span> ev<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
</code></pre></div><h2 id="如何阻止冒泡与默认行为"><a href="#如何阻止冒泡与默认行为" class="header-anchor">#</a> 如何阻止冒泡与默认行为</h2> <ul><li>阻止冒泡行为：非 IE 浏览器 stopPropagation()，IE 浏览器 window.event.cancelBubble = true</li> <li>阻止默认行为：非 IE 浏览器 preventDefault()，IE 浏览器 window.event.returnValue = false</li></ul> <p>解析：</p> <p>当需要阻止冒泡行为时，可以使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">stopBubble</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果提供了事件对象，则这是一个非IE浏览器</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>stopPropagation<span class="token punctuation">)</span>
    <span class="token comment">//因此它支持W3C的stopPropagation()方法</span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//否则，我们需要使用IE的方式来取消事件冒泡</span>
  <span class="token keyword">else</span> window<span class="token punctuation">.</span>event<span class="token punctuation">.</span>cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当需要阻止默认行为时，可以使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//阻止浏览器的默认行为</span>
<span class="token keyword">function</span> <span class="token function">stopDefault</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//阻止默认浏览器动作(W3C)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>preventDefault<span class="token punctuation">)</span> e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//IE中阻止函数器默认动作的方式</span>
  <span class="token keyword">else</span> window<span class="token punctuation">.</span>event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="javascript-的本地对象-内置对象和宿主对象"><a href="#javascript-的本地对象-内置对象和宿主对象" class="header-anchor">#</a> javascript 的本地对象，内置对象和宿主对象</h2> <ul><li><p>本地对象 ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象&quot;。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</p></li> <li><p>内置对象 JS 中内置了 17 个对象，常用的是 Array 对象、Date 对象、正则表达式对象、string 对象、Global 对象</p></li> <li><p>宿主对象 由 ECMAScript 实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的 BOM 和 DOM 都是宿主对象。</p></li></ul> <h2 id="foo-foo-bar-这行代码是什么意思-为什么要这样写"><a href="#foo-foo-bar-这行代码是什么意思-为什么要这样写" class="header-anchor">#</a> foo = foo||bar ，这行代码是什么意思？为什么要这样写？</h2> <p>这种写法称为短路表达式</p> <p>解析：</p> <p>相当于</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> foo<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常用于函数参数的空判断</p> <h2 id="正则表达式构造函数-var-reg-new-regexp-xxx-与正则表达字面量-var-reg-有什么不同"><a href="#正则表达式构造函数-var-reg-new-regexp-xxx-与正则表达字面量-var-reg-有什么不同" class="header-anchor">#</a> 正则表达式构造函数 var reg = new RegExp('xxx')与正则表达字面量 var reg = // 有什么不同？</h2> <p>使用正则表达字面量的效率更高</p> <p>解析：下面的示例代码演示了两种可用于创建正则表达式以匹配反斜杠的方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//正则表达字面量</span>
<span class="token keyword">var</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gm</span></span><span class="token punctuation">;</span>

<span class="token comment">//正则构造函数</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;\\\\&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;gm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token string">&quot;abc\\123&quot;</span><span class="token punctuation">;</span> <span class="token comment">// foo的值为&quot;abc\123&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><p>如上面的代码中可以看到，使用正则表达式字面量表示法时式子显得更加简短，而且不用按照类似类（class-like）的构造函数方式思考。</p> <p>其次，在当使用构造函数的时候，在这里要使用四个反斜杠才能匹配单个反斜杠。这使得正则表达式模式显得更长，更加难以阅读和修改。正确来说，当使用 RegExp()构造函数的时候，不仅需要转义引号（即&quot;表示&quot;），并且通常还需要双反斜杠（即\表示一个\）。</p> <p><strong>使用 new RegExp()的原因之一在于，某些场景中无法事先确定模式，而只能在运行时以字符串方式创建。</strong></p> <h2 id="js-中-callee-与-caller-的作用"><a href="#js-中-callee-与-caller-的作用" class="header-anchor">#</a> js 中 callee 与 caller 的作用</h2> <p>caller 返回一个调用当前函数的引用 如果是由顶层调用的话 则返回 null
（举个栗子哈 caller 给你打电话的人 谁给你打电话了 谁调用了你 很显然是下面 a 函数的执行 只有在打电话的时候你才能知道打电话的人是谁 所以对于函数来说 只有 caller 在函数执行的时候才存在）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">callerTest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callerTest<span class="token punctuation">.</span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">callerTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出function a() {callerTest();}</span>
<span class="token function">callerTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出null</span>
</code></pre></div><p>callee 返回一个正在被执行函数的引用 （这里常用来递归匿名函数本身 但是在严格模式下不可行）</p> <p>callee 是 arguments 对象的一个成员 表示对函数对象本身的引用 它有个 length 属性（代表形参的长度）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">c</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">,</span> arguments<span class="token punctuation">.</span>callee<span class="token punctuation">.</span>length<span class="token punctuation">,</span> arguments<span class="token punctuation">.</span>callee<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出3 2 function(x,y) {console.log(arguments.length,arguments.callee.length,arguments.callee)}</span>
</code></pre></div><h2 id="异步加载-js-的方法"><a href="#异步加载-js-的方法" class="header-anchor">#</a> 异步加载 js 的方法</h2> <p>方案一：<code>&lt;script&gt;</code>标签的 <code>async=&quot;async&quot;</code>属性（详细参见：script 标签的 async 属性）</p> <p>点评：HTML5 中新增的属性，Chrome、FF、IE9&amp;IE9+均支持（IE6~8 不支持）。此外，这种方法不能保证脚本按顺序执行。</p> <p>方案二：<code>&lt;script&gt;</code>标签的 <code>defer=&quot;defer&quot;</code>属性</p> <p>点评：兼容所有浏览器。此外，这种方法可以确保所有设置 defer 属性的脚本按顺序执行。</p> <p>方案三：动态创建<code>&lt;script&gt;</code>标签</p> <p>示例：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
      <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> s <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement_x</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&quot;text/javascript&quot;</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> tmp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName_r</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        tmp<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://xybtv.com/uploads/allimg/100601/48-100601162913.jpg<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>点评：兼容所有浏览器。</p> <p>方案四：<code>AJAX eval</code>（使用 AJAX 得到脚本内容，然后通过 <code>eval_r(xmlhttp.responseText)</code>来运行脚本）</p> <p>点评：兼容所有浏览器。</p> <p>方案五：<code>iframe</code> 方式（这里可以参照：iframe 异步加载技术及性能 中关于 Meboo 的部分）</p> <p>点评：兼容所有浏览器。</p> <h2 id="js-中-文档碎片的理解和使用"><a href="#js-中-文档碎片的理解和使用" class="header-anchor">#</a> JS 中 文档碎片的理解和使用</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、什么是文档碎片？</span>

document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一个容器，用于暂时存放创建的dom元素</span>

<span class="token comment">// 2、文档碎片有什么用？</span>

<span class="token comment">// 将需要添加的大量元素,先添加到文档碎片中，再将文档碎片添加到需要插入的位置，大大 减少dom操作，提高性能（IE和火狐比较明显）</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 普通方式：（操作了100次dom）</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> elem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//放到body中</span>
<span class="token punctuation">}</span>

<span class="token comment">//  文档碎片：(操作1次dom)</span>
<span class="token keyword">var</span> df <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> elem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  df<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//最后放入到页面上</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ie-与火狐的事件机制有什么区别-如何阻止冒泡"><a href="#ie-与火狐的事件机制有什么区别-如何阻止冒泡" class="header-anchor">#</a> IE 与火狐的事件机制有什么区别？如何阻止冒泡</h2> <ul><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li> <li>事件处理机制：IE 是事件冒泡、火狐是 事件捕获；</li> <li>ev.stopPropagation();</li></ul> <h2 id="列举浏览器对象模型-bom-里常用的至少-4-个对象-并列举-window-对象的常用方法至少-5-个"><a href="#列举浏览器对象模型-bom-里常用的至少-4-个对象-并列举-window-对象的常用方法至少-5-个" class="header-anchor">#</a> 列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 对象的常用方法至少 5 个？</h2> <p>对象：Window，document，location，screen，history，navigator。 方法：Alert()，confirm()，prompt()，open()，close()。</p> <h2 id="class-forname-的作用-为什么要用"><a href="#class-forname-的作用-为什么要用" class="header-anchor">#</a> class.forname 的作用?为什么要用?</h2> <ol><li>获取 Class 对象的方式：类名.class、对象.getClass()、Class.forName(“类名”);</li> <li>通过 Class 对象自审</li> <li>动态调用方法</li></ol> <h2 id="外部-js-文件出现中文字符-会出现什么问题-怎么解决"><a href="#外部-js-文件出现中文字符-会出现什么问题-怎么解决" class="header-anchor">#</a> 外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</h2> <p>会出现乱码，加 charset=&quot;GB2312&quot;;</p> <h2 id="定时器-setinterval-有一个有名函数-fn1-setinterval-fn1-500-与-setinterval-fn1-500-有什么区别"><a href="#定时器-setinterval-有一个有名函数-fn1-setinterval-fn1-500-与-setinterval-fn1-500-有什么区别" class="header-anchor">#</a> 定时器 setInterval 有一个有名函数 fn1，setInterval（fn1,500）与 setInterval（fn1(),500）有什么区别？</h2> <p>第一个是重复执行每 500 毫秒执行一次，后面一个只执行一次。</p> <h2 id="documen-write-和-innerhtml-的区别-2"><a href="#documen-write-和-innerhtml-的区别-2" class="header-anchor">#</a> documen.write 和 innerHTML 的区别?</h2> <ul><li>document.write 是重写整个 document, 写入内容是字符串的 html</li> <li>innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容</li></ul> <h2 id="简述创建函数的几种方式"><a href="#简述创建函数的几种方式" class="header-anchor">#</a> 简述创建函数的几种方式</h2> <div class="language-js extra-class"><pre class="language-js"><code>第一种（函数声明）：
<span class="token keyword">function</span> <span class="token function">sum1</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span>num2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> num1<span class="token operator">+</span>num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
第二种（函数表达式）：
<span class="token keyword">var</span> <span class="token function-variable function">sum2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span>num2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> num1<span class="token operator">+</span>num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
第三种（函数对象方式）：
<span class="token keyword">var</span> sum3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;num1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;num2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;return num1+num2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="window-location-search-返回的是什么"><a href="#window-location-search-返回的是什么" class="header-anchor">#</a> window.location.search() 返回的是什么？</h2> <p>查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用 javascript 来获得相信应的参数值 返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！</p> <h2 id="window-location-hash-返回什么"><a href="#window-location-hash-返回什么" class="header-anchor">#</a> window.location.hash 返回什么？</h2> <p>锚点 ， 返回值：#love ；</p> <h2 id="window-location-reload-作用"><a href="#window-location-reload-作用" class="header-anchor">#</a> window.location.reload() 作用？</h2> <p>刷新当前页面</p> <h2 id="bom-对象有哪些-列举-window-对象"><a href="#bom-对象有哪些-列举-window-对象" class="header-anchor">#</a> BOM 对象有哪些，列举 window 对象？</h2> <ol><li>window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；</li> <li>document 对象，文档对象；</li> <li>location 对象，浏览器当前 URL 信息；</li> <li>navigator 对象，浏览器本身信息；</li> <li>screen 对象，客户端屏幕信息；</li> <li>history 对象，浏览器访问历史信息；</li></ol> <h2 id="前端-templating-mustache-underscore-handlebars-是干嘛的-怎么用"><a href="#前端-templating-mustache-underscore-handlebars-是干嘛的-怎么用" class="header-anchor">#</a> 前端 templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?</h2> <ul><li>Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，</li> <li>Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。</li> <li>Underscore 封装了常用的 JavaScript 对象操作方法，用于提高开发效率。</li> <li>Handlebars 是 JavaScript 一个语义模板库，通过对 view 和 data 的分离来快速构建 Web 模板。</li></ul> <h2 id="知道什么是-webkit-么-知道怎么用浏览器的各种工具来调试和-debug-代码么"><a href="#知道什么是-webkit-么-知道怎么用浏览器的各种工具来调试和-debug-代码么" class="header-anchor">#</a> 知道什么是 webkit 么? 知道怎么用浏览器的各种工具来调试和 debug 代码么?</h2> <p>Webkit 是浏览器引擎，包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用）。 对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率</p> <h2 id="事件绑定的方式"><a href="#事件绑定的方式" class="header-anchor">#</a> 事件绑定的方式</h2> <p>嵌入 dom</p> <p><code>&lt;button onclick=&quot;func()&quot;&gt;按钮&lt;/button&gt;</code></p> <p>直接绑定</p> <p><code>btn.onclick = function() {};</code></p> <p>事件监听</p> <p><code>btn.addEventListener(&quot;click&quot;, function() {});</code></p> <h2 id="事件模型"><a href="#事件模型" class="header-anchor">#</a> 事件模型</h2> <p><strong>DOM0</strong>
直接绑定</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input onclick<span class="token operator">=</span><span class="token string">&quot;sayHi()&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>DOM2</strong></p> <p>DOM2 级事件可以冒泡和捕获 通过 addEventListener 绑定 通过 removeEventListener 解绑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 绑定</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 解绑</span>
btn<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>DOM3</strong></p> <p>DOM3 具有更多事件类型 DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：</p> <ul><li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li> <li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li> <li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</li> <li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li> <li>文本事件，当在文档中输入文本时触发，如：textInput</li> <li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li> <li>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</li> <li>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</li></ul> <h2 id="如何自定义事件"><a href="#如何自定义事件" class="header-anchor">#</a> 如何自定义事件</h2> <ul><li>原生提供了 3 个方法实现自定义事件</li> <li>createEvent，设置事件类型，是 html 事件还是 鼠标事件</li> <li>initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件</li> <li>dispatchEvent 触发事件</li></ul> <h2 id="target-和-currenttarget-区别"><a href="#target-和-currenttarget-区别" class="header-anchor">#</a> target 和 currentTarget 区别</h2> <ul><li>event.target:返回触发事件的元素</li> <li>event.currentTarget:返回绑定事件的元素</li></ul> <h2 id="prototype-和proto的关系是什么"><a href="#prototype-和proto的关系是什么" class="header-anchor">#</a> prototype 和<strong>proto</strong>的关系是什么</h2> <p>所有的对象都拥有<strong>proto</strong>属性，它指向对象构造函数的 prototype 属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
test<span class="token punctuation">.</span>__proto__ <span class="token operator">==</span> <span class="token class-name">Test</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>所有的函数都同时拥有<strong>proto</strong>和 protytpe 属性 函数的<strong>proto</strong>指向自己的函数实现 函数的 protytpe 是一个对象 所以函数的 prototype 也有<strong>proto</strong>属性 指向 Object.prototype</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
func<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__指向 <span class="token keyword">null</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token comment">// null</span>
</code></pre></div><h2 id="什么是属性搜索原则"><a href="#什么是属性搜索原则" class="header-anchor">#</a> 什么是属性搜索原则？</h2> <ul><li>首先会去查找对象本身上面有没有这个属性，有的话，就返回这个属性</li> <li>如果对象本身上面没有这个属性，就到它的原型上面去查找，如果有，就返回</li> <li>就到原型的原型上面去查找有没有这个属性，如果查找到最后一只没有找到，就返回一个 undefined</li></ul> <h2 id="说下函数式编程的理解"><a href="#说下函数式编程的理解" class="header-anchor">#</a> 说下函数式编程的理解</h2> <p>1.什么是函数式编程？</p> <p>函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是 λ 演算（lambda calculus），而且 λ 演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p> <p>2.优势特点</p> <p>代码简洁、开发快速、命令式实现、函数式实现、易于理解，抽象度高、没有副作用，变量无状态</p> <h2 id="为什么-for-循环嵌套顺序会影响性能"><a href="#为什么-for-循环嵌套顺序会影响性能" class="header-anchor">#</a> 为什么 for 循环嵌套顺序会影响性能？</h2> <p>把循环次数大的放在内层，执行时间会比较短</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;first time&quot;</span><span class="token punctuation">,</span> t2 <span class="token operator">-</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>| 变量 | 实例化(次数) | 初始化(次数) |   比较(次数)    |   自增(次数)    |
| ---- | :----------: | :----------: | :-------------: | :-------------: |
| i    |      1       |      1       |       10        |       10        |
| j    |      10      |      10      |    10 \* 100    |    10 \* 100    |
| k    |  10 \* 100   |  10 \* 100   | 10 _ 100 _ 1000 | 10 _ 100 _ 1000 |
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;two time&quot;</span><span class="token punctuation">,</span> t3 <span class="token operator">-</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>| 变量 | 实例化(次数) | 初始化(次数) |   比较(次数)    |   自增(次数)    |
| ---- | :----------: | :----------: | :-------------: | :-------------: |
| i    |      1       |      1       |      1000       |      1000       |
| j    |     1000     |     1000     |   1000 \* 100   |   1000 \* 100   |
| k    | 1000 \* 100  | 1000 \* 100  | 1000 _ 100 _ 10 | 1000 _ 100 _ 10 |
</code></pre></div><h2 id="轮播图实现原理"><a href="#轮播图实现原理" class="header-anchor">#</a> 轮播图实现原理</h2> <p>1.图片移动实现原理：</p> <p>利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制 left 属性，实现照片的移动。</p> <p>2.图片移动动画原理：</p> <p>从 a 位置移动到 b 位置，需要先计算两点之间的差值，通过差值和时间间隔，计算出每次移动的步长，通过添加定时器，每次移动相同的步长，实现动画效果。</p> <p>3.图片定位停止原理：</p> <p>每一张照片都有相同的宽度，每张照片都有一个绝对的定位数值，通过检测定每次移动后，照片当前位置和需要到达位置之间的距离是否小于步长，如果小于，说明已经移动到位，可以将定时器清除，来停止动画。</p> <p>4 图片切换原理：</p> <p>在全局设置一个变量，记录当前图片的位置，每次切换或跳转时，只需要将数值修改，并调用图片页数转像素位置函数，再调用像素运动函数即可。</p> <p>5.自动轮播原理：</p> <p>设置定时器，一定时间间隔后，将照片标记加 1，然后开始切换。</p> <p>6.左右点击切换原理：</p> <p>修改当前位置标记，开始切换。这里需要注意与自动轮播之间的冲突。当点击事件触发之后，停止自动轮播计时器，开始切换。当动画结束后再次添加自动轮播计时器。</p> <p>7.无缝衔接原理：</p> <p>需要无缝衔接，难度在于最后一页向后翻到第一页，和第一页向前翻到最后一页。由于图片的基本移动原理。要想实现无缝衔接，两张图片就必须紧贴在一起。所以在第一张的前面需要添加最后一张，最后一张的后面需要添加第一张。</p> <p>7.预防鬼畜原理：</p> <p>始终保证轮播图的运动动画只有一个，从底层杜绝鬼畜。需要在每次动画开始之前，尝试停止动画定时器，然后开始为新的动画添加定时器。</p> <p>8.预防暴力点击原理：</p> <p>如果用户快速点击触发事件，会在短时间内多次调用切换函数，虽然动画函数可以保证，不会发生鬼畜，但在照片从最后一张到第一张的切换过程，不会按照正常的轮播，而是实现了跳转。所以需要通过添加口令的方式来，限制用户的点击。当用户点击完成后，口令销毁，动画结束后恢复口令。</p> <p>9.小圆点的位置显示原理：</p> <p>每次触发动画时，通过全局变量标记，获取当前页数，操作清除所有小圆点，然后指定一页添加样式。</p> <p>10.点击触发跳转的原理：</p> <p>类似于左右点击触发，只是这是将全局页面标记，直接修改，后执行动画。需要避免与自动轮播定时器的冲突。</p> <h2 id="如何设计一个轮播图组件"><a href="#如何设计一个轮播图组件" class="header-anchor">#</a> 如何设计一个轮播图组件</h2> <ul><li>轮播图功能实现</li> <li>抽出需要传入的变量，如：背景图，文案描述等</li></ul> <h2 id="script-引入方式"><a href="#script-引入方式" class="header-anchor">#</a> script 引入方式</h2> <p>html 静态<code>&lt;script&gt;</code>引入
js 动态插入<code>&lt;script&gt;</code> <code>&lt;script defer&gt;</code>: 延迟加载，元素解析完成后执行
<code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染</p> <h2 id="为什么普通-r-for-于-循环的性能远远高于-h-foreach-的性能-请解释其中的原因"><a href="#为什么普通-r-for-于-循环的性能远远高于-h-foreach-的性能-请解释其中的原因" class="header-anchor">#</a> 为什么普通 r for 于 循环的性能远远高于 h forEach 的性能，请解释其中的原因</h2> <p>for 循环没有任何额外的函数调用栈和上下文；</p> <p>forEach 函数签名实际上是 <code>array.forEach(function(currentValue, index, arr), thisValue)</code></p> <p>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能</p> <h2 id="es6-成-代码转成-5-es5-代码的实现思路是什么"><a href="#es6-成-代码转成-5-es5-代码的实现思路是什么" class="header-anchor">#</a> ES6 成 代码转成 5 ES5 代码的实现思路是什么</h2> <p>ES6 转 ES5 目前行业标配是用 Babel，转换的大致流程如下：</p> <ol><li>解析：解析代码字符串，生成 AST；</li> <li>转换：按一定的规则转换、修改 AST；</li> <li>生成：将修改后的 AST 转换成普通代码。</li></ol> <p>如果不用工具，纯人工的话，就是使用或自己写各种 polyfill 了。</p> <h2 id="d-a-b-c-d-和-和-a-b-c-d-哪个性能更高"><a href="#d-a-b-c-d-和-和-a-b-c-d-哪个性能更高" class="header-anchor">#</a> d a.b.c.d 和 和 a['b']['c']['d'] ，哪个性能更高？</h2> <p>应该是 a.b.c.d 比 <code>a['b']['c']['d']</code> 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4 days ago</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mian/base/css.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        CSS
      </a></span> <span class="next"><a href="/mian/base/Ajax.html">
        Ajax
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"><div></div><!----></div></div>
    <script src="/assets/js/app.19ab200f.js" defer></script><script src="/assets/js/2.e7f3efaa.js" defer></script><script src="/assets/js/5.d521be3c.js" defer></script>
  </body>
</html>