<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>为什么使用 Vue？ | 跌倒的小黄瓜</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="这儿将描述一些东西···💤">
    <link rel="preload" href="/assets/css/0.styles.5251e6d5.css" as="style"><link rel="preload" href="/assets/js/app.3e346258.js" as="script"><link rel="preload" href="/assets/js/2.3070da37.js" as="script"><link rel="preload" href="/assets/js/6.32e6ea72.js" as="script"><link rel="prefetch" href="/assets/js/10.aa6a8251.js"><link rel="prefetch" href="/assets/js/11.720cd900.js"><link rel="prefetch" href="/assets/js/12.0af698d3.js"><link rel="prefetch" href="/assets/js/13.f80fcdd9.js"><link rel="prefetch" href="/assets/js/14.f38269ca.js"><link rel="prefetch" href="/assets/js/15.c49e2e8d.js"><link rel="prefetch" href="/assets/js/16.fb85cb5b.js"><link rel="prefetch" href="/assets/js/17.292cedf8.js"><link rel="prefetch" href="/assets/js/18.2e74b558.js"><link rel="prefetch" href="/assets/js/19.bc50d1fa.js"><link rel="prefetch" href="/assets/js/20.a6178d3a.js"><link rel="prefetch" href="/assets/js/21.1746568e.js"><link rel="prefetch" href="/assets/js/22.c143fa2c.js"><link rel="prefetch" href="/assets/js/23.9b7d74aa.js"><link rel="prefetch" href="/assets/js/24.bb04e80c.js"><link rel="prefetch" href="/assets/js/25.38f2e391.js"><link rel="prefetch" href="/assets/js/26.8772e219.js"><link rel="prefetch" href="/assets/js/27.a34a046c.js"><link rel="prefetch" href="/assets/js/28.271015ac.js"><link rel="prefetch" href="/assets/js/29.e055e747.js"><link rel="prefetch" href="/assets/js/3.4143c721.js"><link rel="prefetch" href="/assets/js/30.19ce39a7.js"><link rel="prefetch" href="/assets/js/31.d2c2de77.js"><link rel="prefetch" href="/assets/js/32.611b57df.js"><link rel="prefetch" href="/assets/js/33.fa854a39.js"><link rel="prefetch" href="/assets/js/34.3e0437cd.js"><link rel="prefetch" href="/assets/js/35.10651ca6.js"><link rel="prefetch" href="/assets/js/36.5da66d68.js"><link rel="prefetch" href="/assets/js/37.77823813.js"><link rel="prefetch" href="/assets/js/38.549acb99.js"><link rel="prefetch" href="/assets/js/39.cc7c2247.js"><link rel="prefetch" href="/assets/js/4.5d193cfb.js"><link rel="prefetch" href="/assets/js/40.b40762e1.js"><link rel="prefetch" href="/assets/js/41.1b9edd5a.js"><link rel="prefetch" href="/assets/js/42.947445d2.js"><link rel="prefetch" href="/assets/js/43.ec7b9009.js"><link rel="prefetch" href="/assets/js/44.2e176b9b.js"><link rel="prefetch" href="/assets/js/45.fb26a112.js"><link rel="prefetch" href="/assets/js/46.e081dd78.js"><link rel="prefetch" href="/assets/js/47.7cc9c477.js"><link rel="prefetch" href="/assets/js/48.25f65bec.js"><link rel="prefetch" href="/assets/js/49.52e7a05e.js"><link rel="prefetch" href="/assets/js/5.0388117f.js"><link rel="prefetch" href="/assets/js/50.340482eb.js"><link rel="prefetch" href="/assets/js/51.a8c99084.js"><link rel="prefetch" href="/assets/js/52.c00a5f26.js"><link rel="prefetch" href="/assets/js/53.f548f94d.js"><link rel="prefetch" href="/assets/js/54.eaa4e200.js"><link rel="prefetch" href="/assets/js/55.d3308c76.js"><link rel="prefetch" href="/assets/js/56.fe5ed8c1.js"><link rel="prefetch" href="/assets/js/57.a70f03ee.js"><link rel="prefetch" href="/assets/js/58.41cfc2f0.js"><link rel="prefetch" href="/assets/js/59.1976b5e9.js"><link rel="prefetch" href="/assets/js/60.feb5b197.js"><link rel="prefetch" href="/assets/js/61.a2a63080.js"><link rel="prefetch" href="/assets/js/62.b01add5a.js"><link rel="prefetch" href="/assets/js/63.bcf9b98a.js"><link rel="prefetch" href="/assets/js/64.67dc61c7.js"><link rel="prefetch" href="/assets/js/65.8e30aabb.js"><link rel="prefetch" href="/assets/js/66.6b2a90dd.js"><link rel="prefetch" href="/assets/js/67.c6ffd84c.js"><link rel="prefetch" href="/assets/js/68.30f3f3c4.js"><link rel="prefetch" href="/assets/js/69.1745ae24.js"><link rel="prefetch" href="/assets/js/7.b64d0317.js"><link rel="prefetch" href="/assets/js/70.492be775.js"><link rel="prefetch" href="/assets/js/8.0669fdc8.js"><link rel="prefetch" href="/assets/js/9.6a49cbdb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5251e6d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">跌倒的小黄瓜</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mian/index.html">
          面试
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/Demo/index.html">
          Demo
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          其他
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><div><div class="ads"><div id="ads_2"><div class="ant-carousel"><div class="slick-slider slick-initialized"><div class="slick-list"><div class="slick-track"><div tabIndex="-1" data-index="-1" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="0" class="slick-slide slick-active slick-current" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="1" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="2" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="3" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="4" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="5" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="6" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="7" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div></div></div><ul class="slick-dots slick-dots-bottom" style="display:block;"><li class="slick-active"><button>1</button></li><li><button>2</button></li><li><button>3</button></li><li><button>4</button></li></ul></div></div></div></div> <div role="separator" id="reset-margin" class="ant-divider ant-divider-horizontal ant-divider-dashed"></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试知识点</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mian/base/browser.html" title="浏览器" class="sidebar-link">浏览器</a></li><li><a href="/mian/base/html2.html" title="HTML" class="sidebar-link">HTML</a></li><li><a href="/mian/base/css.html" title="CSS" class="sidebar-link">CSS</a></li><li><a href="/mian/base/js.html" title="Javascript" class="sidebar-link">Javascript</a></li><li><a href="/mian/base/es6.html" title="ES6" class="sidebar-link">ES6</a></li><li><a href="/mian/base/nodejs.html" title="nodejs" class="sidebar-link">nodejs</a></li><li><a href="/mian/base/ts.html" title="TypeScript" class="sidebar-link">TypeScript</a></li><li><a href="/mian/base/vue.html" aria-current="page" title="vue" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/vue.html#为什么使用-vue" title="为什么使用 Vue？" class="sidebar-link">为什么使用 Vue？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#对-mvvm-的理解" title="对 MVVM 的理解" class="sidebar-link">对 MVVM 的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-双向数据绑定原理" title="vue 双向数据绑定原理" class="sidebar-link">vue 双向数据绑定原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-双向数据绑定的实现" title="vue 双向数据绑定的实现" class="sidebar-link">vue 双向数据绑定的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#object-defineproperty-函数" title="Object.defineProperty 函数" class="sidebar-link">Object.defineProperty 函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#使用-object-defineproperty-来进行数据劫持有什么缺点" title="使用 Object.defineProperty() 来进行数据劫持有什么缺点？" class="sidebar-link">使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#object-defineproperty-和-proxy-的优劣区别" title="Object.defineProperty 和 proxy 的优劣区别" class="sidebar-link">Object.defineProperty 和 proxy 的优劣区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快" title="什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快" class="sidebar-link">什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异" title="除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异" class="sidebar-link">除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何比较两个-dom-树的差异" title="如何比较两个 DOM 树的差异？" class="sidebar-link">如何比较两个 DOM 树的差异？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#对-vue-响应式系统的理解" title="对 vue 响应式系统的理解" class="sidebar-link">对 vue 响应式系统的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的生命周期是什么" title="Vue 的生命周期是什么" class="sidebar-link">Vue 的生命周期是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的各个生命阶段是什么" title="Vue 的各个生命阶段是什么？" class="sidebar-link">Vue 的各个生命阶段是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-组件间的参数传递方式" title="Vue 组件间的参数传递方式" class="sidebar-link">Vue 组件间的参数传递方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#computed-和-和-watch-的差异" title="computed 和 和 watch 的差异" class="sidebar-link">computed 和 和 watch 的差异</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-指令有哪些-v-if-和-v-for-能不能一起使用" title="vue 指令有哪些，v-if 和 v-for 能不能一起使用" class="sidebar-link">vue 指令有哪些，v-if 和 v-for 能不能一起使用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-router-中的导航钩子函数" title="vue-router 中的导航钩子函数" class="sidebar-link">vue-router 中的导航钩子函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#route-和-和-router-的区别" title="$route 和 和 $router 的区别" class="sidebar-link">$route 和 和 $router 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的路由实现" title="vue 的路由实现" class="sidebar-link">vue 的路由实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-路由懒加载的方式有哪些" title="vue 路由懒加载的方式有哪些" class="sidebar-link">vue 路由懒加载的方式有哪些</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-常用的修饰符" title="vue 常用的修饰符" class="sidebar-link">vue 常用的修饰符</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-key-值的作用" title="vue 中 key 值的作用" class="sidebar-link">vue 中 key 值的作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#diff-算法的过程-key-的作用" title="diff 算法的过程(key 的作用)" class="sidebar-link">diff 算法的过程(key 的作用)</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#keep-alive-组件有什么作用" title="keep-alive 组件有什么作用" class="sidebar-link">keep-alive 组件有什么作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-mixin-和-mixins-区别" title="vue 中 mixin 和 mixins 区别？" class="sidebar-link">vue 中 mixin 和 mixins 区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何优化不使用到-vue-数据劫持的长列表" title="如何优化不使用到 Vue 数据劫持的长列表？" class="sidebar-link">如何优化不使用到 Vue 数据劫持的长列表？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#v-for-为什么必须为-item-增加-key-为什么同时避免-v-if" title="v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？" class="sidebar-link">v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#图片资源懒加载" title="图片资源懒加载" class="sidebar-link">图片资源懒加载</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#第三方插件按需引入" title="第三方插件按需引入" class="sidebar-link">第三方插件按需引入</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#服务器端渲染" title="服务器端渲染" class="sidebar-link">服务器端渲染</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vuex" title="Vuex" class="sidebar-link">Vuex</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/vue.html#为什么使用-vuex" title="为什么使用 Vuex" class="sidebar-link">为什么使用 Vuex</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#四种状态" title="四种状态" class="sidebar-link">四种状态</a></li></ul></li></ul></li><li><a href="/mian/base/project.html" title="工程化" class="sidebar-link">工程化</a></li><li><a href="/mian/base/network.html" title="计算机网络" class="sidebar-link">计算机网络</a></li><li><a href="/mian/base/design.html" title="设计模式" class="sidebar-link">设计模式</a></li><li><a href="/mian/base/safe.html" title="安全" class="sidebar-link">安全</a></li><li><a href="/mian/base/better.html" title="性能优化" class="sidebar-link">性能优化</a></li><li><a href="/mian/base/tools.html" title="工具" class="sidebar-link">工具</a></li><li><a href="/mian/base/datastruct.html" title="数据结构" class="sidebar-link">数据结构</a></li><li><a href="/mian/base/jstimu.html" title="js相关题目" class="sidebar-link">js相关题目</a></li><li><a href="/mian/base/suanfa.html" title="算法" class="sidebar-link">算法</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="为什么使用-vue"><a href="#为什么使用-vue" class="header-anchor">#</a> 为什么使用 Vue？</h2> <p>从前端这么些年的发展史来看，从网页设计年代到了现在大前端时代的来临，各种各样的技术层出不穷。尤其是在前端性能优化方面，为了避免页面的回流和重绘，前辈们总结出了各种解决优化方案，基本都是尽量的减少 DOM 操作。</p> <p>Vue 的诞生，是一个很大的优化方案，直接用虚拟 DOM 映射真实 DOM，来进行更新，避免了直接操作真实 DOM 带来的性能缺陷。</p> <p>为了好理解呢，我们换个通俗一点的说法，当页面涉及到操作 DOM 的时候，我们不直接进行操作，因为这样降低了前端页面的性能。而是将 DOM 拿到内存中去，在内存中更改页面的 DOM ，这时候我们操作 DOM 不会导致每次操作 DOM 就会造成不必要的回流和重绘。更新完所有 DOM 之后，我们将更新完的 DOM 再插入到页面中，这样大大提高了页面的性能</p> <p>虽然这样讲有些欠妥或者不标准，其实 Vue 的虚拟 DOM 的作用可以这样去理解</p> <h2 id="对-mvvm-的理解"><a href="#对-mvvm-的理解" class="header-anchor">#</a> 对 MVVM 的理解</h2> <p>MVC 的弊端：MVC 即&quot;Model-View-Controller&quot;，当视图上发生变化，通过 Controller（控件）将响应传入到 Model（数据源），由数据源改变 View 上面的数据，允许 view 和 model 直接通信，随着业务不断庞大，会出现向蜘蛛网一样难以处理的依赖关系，违背了开发应该遵循的&quot;开放封闭原则&quot;</p> <p>MVVM，萌芽于 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF ，前端最早的 MVVM 框架 knockout 在 2010 年发布</p> <p><img src="/assets/img/MVVM.4e13b383.png" alt=""></p> <p>即&quot;Model-View-ViewModel&quot;，View 通过 View-Model 的 DOM Listeners 将事件绑定到 Model 上，而 Model 则通过 Data Bindings 来管理 View 中的数据，View-Model 从中起到一个连接桥的作用</p> <p><a href="/mian/base/design.html#什么是-mvvm之-比之-mvc-是-有什么区别-什么又是-mvp">MVVM,MVP,MVC</a></p> <h2 id="vue-双向数据绑定原理"><a href="#vue-双向数据绑定原理" class="header-anchor">#</a> vue 双向数据绑定原理</h2> <p>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现的。</p> <p>首先我<strong>们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持</strong>，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</p> <p>数据在 html 模板中一共有<strong>两种绑定情况</strong>，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</p> <p>如果遇到<strong>元素节点</strong>，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</p> <p>如果遇到了绑定的<strong>文本节点</strong>，我们使用 Model 中对应的属性的值来替换这个文本。</p> <p><strong>对于文本节点的更新，我们使用了发布订阅者模式</strong>，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</p> <h2 id="vue-双向数据绑定的实现"><a href="#vue-双向数据绑定的实现" class="header-anchor">#</a> vue 双向数据绑定的实现</h2> <ul><li>vue 内部利用 Object.defineProperty 监听数据变化，使数据具有可观测性，结合发布订阅模式，在数据发生变化时更新视图利用 Proxy 或 Object.defineProperty 生成的 Observer 针对对象/对象的属性进行&quot;劫持&quot;,在属性发生变化后通知订阅者</li> <li>解析器 Compile 解析模板中的 Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li> <li>Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简单的双向数据绑定</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当属性值发⽣变化时我们可以进⾏额外操作</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="object-defineproperty-函数"><a href="#object-defineproperty-函数" class="header-anchor">#</a> Object.defineProperty 函数</h2> <p>Object.defineProperty 函数一共有三个参数，第一个参数是<strong>需要定义属性的对象</strong>，第二个参数是<strong>需要定义的属性</strong>，第三个是<strong>该属性描述符</strong>。一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</p> <h2 id="使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2> <p><strong>有一些对属性的操作，使用这种方法无法拦截</strong>，比如说<strong>通过下标方式修改数组数据</strong>或者<strong>给对象新增属性</strong>，<strong>vue 内部通过重写函数解决了这个问</strong>题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 <strong>Proxy 的好处是它可以完美的监听到任何方式的数据改变</strong>，唯一的缺点是<strong>兼容性的问题</strong>，因为这是 ES6 的语法。</p> <h2 id="object-defineproperty-和-proxy-的优劣区别"><a href="#object-defineproperty-和-proxy-的优劣区别" class="header-anchor">#</a> Object.defineProperty 和 proxy 的优劣区别</h2> <p>Object.defineProperty 兼容性较好，但不能直接监听数组的变化，只能监听对象的属性(有时需要深层遍历)</p> <p>与之相比 proxy 的优点：</p> <ul><li>可以直接监听数组的变化</li> <li>可以直接监听对象而非属性</li> <li>proxy 有多达 13 种的拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等</li> <li>proxy 受到各大浏览器厂商的重视</li></ul> <h2 id="什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快"><a href="#什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快" class="header-anchor">#</a> 什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快</h2> <p>我对 Virtual DOM 的理解是:首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 <strong>js 对象树</strong>给保存下来，最后再将 DOM 片段插入到文档中。</p> <p>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p> <p>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，<strong>通过在操作前确定需要做的最小修改</strong>，<strong>尽可能的减少 DOM 操作带来的重流和重绘的影响</strong>。其实 <strong>Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作</strong>。</p> <h2 id="除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异"><a href="#除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异" class="header-anchor">#</a> 除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异</h2> <p>现代前端框架主要有两种监听数据的方式：一种是<strong>pull</strong>的方式，一种是<strong>push</strong>的方式</p> <p><strong>pull，其代表为 react</strong>，react 和 vue 基于双向数据绑定的依赖收集的订阅式机制不同，react 是通过显式的触发函数调用来更新视图，比如 setState，然后 React 会一层层的进行 VirtualDom Diff 操作找出差异，通过较暴力 diff 的方式查找哪里发生变化。<strong>另一个代表是 angular 的脏值检测</strong></p> <p><strong>push，其代表为 vue</strong>，当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知；我们知道绑定一个数据通常就需要一个 watcher，那么一旦细粒度过高会产生大量的 watcher，会给增加内存以及依赖追踪的开销，而细粒度过低会无法精准检测变化，因此 vue 选择中细粒度方案，<strong>在组件级进行 push 检测的方式(即依赖响应式系统)，在组件内部进行 Virtual Dom Diff 获取更加具体的差异，所以 vue 采用了 push+pull 结合的方式</strong></p> <h2 id="如何比较两个-dom-树的差异"><a href="#如何比较两个-dom-树的差异" class="header-anchor">#</a> 如何比较两个 DOM 树的差异？</h2> <p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是<strong>在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)</strong>。</p> <p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p> <p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，<strong>列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点</strong>。</p> <h2 id="对-vue-响应式系统的理解"><a href="#对-vue-响应式系统的理解" class="header-anchor">#</a> 对 vue 响应式系统的理解</h2> <p><img src="/assets/img/08.f8f8e868.png" alt=""></p> <p>响应式系统简述：</p> <ul><li>任何⼀个 Vue Component 都有⼀个与之对应的 Watcher 实例</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性</li> <li>当 Vue Component render 函数被执⾏的时候，data 上会被触碰(touch)， 即被读，getter ⽅法会被调⽤， 此时 Vue 会去记录此 Vue component 所依赖的所有 data(这⼀过程被称为依赖收集)</li> <li>data 被改动时(主要是⽤户操作)， setter ⽅法会被调⽤， 此时 Vue 会去通知所有依赖于此 data 的组件去调⽤他们的 render 函数进⾏更新</li></ul> <h2 id="vue-的生命周期是什么"><a href="#vue-的生命周期是什么" class="header-anchor">#</a> Vue 的生命周期是什么</h2> <p>Vue 的生命周期指的是<strong>组件从创建到销毁的一系列的过程</strong>，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作</p> <p><img src="/assets/img/vue-life-cycle.011913ba.png" alt=""></p> <ul><li>beforeCreate：完成实例初始化，初始化非响应式变量</li> <li>created：实例初始化完成(未挂载 DOM)</li> <li>berofeMount：找到对应的 template，并编译成 render 函数</li> <li>mounted：完成创建 vm.$el 和双向绑定，完成 DOM 挂载</li> <li>beforeUpdate：数据更新之前(可在更新前访问现有的 DOM)</li> <li>updated：完成虚拟 DOM 的重新渲染和打补丁</li> <li>activated：子组件需要在每次加载时候进行某些操作，可以使用 activated 钩子触发</li> <li>deactivated：keep-alive 组件被移除时使用</li> <li>beforeDestroy：可做一些删除提示，销毁定时器，解绑全局时间 销毁插件对象</li> <li>destroyed：当前组件已被销毁</li></ul> <h2 id="vue-的各个生命阶段是什么"><a href="#vue-的各个生命阶段是什么" class="header-anchor">#</a> Vue 的各个生命阶段是什么？</h2> <p>Vue 一共有 <strong>8</strong> 个生命阶段，分别是<strong>创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后</strong>，每个阶段对应了一个生命周期的钩子函数。</p> <p>（1）beforeCreate 钩子函数，在<strong>实例初始化之后</strong>，在<strong>数据监听和事件配置之前触发</strong>。因此在这个事件中我们是<strong>获取不到 data 数据</strong>的。</p> <p>（2）created 钩子函数，在<strong>实例创建完成后触发</strong>，此时可以访问 data、methods 等属性。但这个时候<strong>组件还没有被挂载到页面中去</strong>，所以这个时候访问<strong>不到 $el 属性</strong>。一般我们可以在这个函数中<strong>进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化</strong>。</p> <p>（3）beforeMount 钩子函数，在<strong>组件被挂载到页面之前触发</strong>。<strong>在 beforeMount 之前，会找到对应的 template，并编译成 render 函数</strong>。</p> <p>（4）mounted 钩子函数，在<strong>组件挂载到页面之后触发</strong>。此时<strong>可以通过 DOM API 获取到页面中的 DOM 元素</strong>。</p> <p>（5）beforeUpdate 钩子函数，在<strong>响应式数据更新时触发</strong>，发生在虚拟 DOM 重新渲染和打补丁之前**，这个时候我们可以**对可能会被移除的元素做一些操作**，比如移除事件监听器。</p> <p>（6）updated 钩子函数，<strong>虚拟 DOM 重新渲染和打补丁之后调用</strong>。</p> <p>（7）beforeDestroy 钩子函数，在<strong>实例销毁之前调用</strong>。一般在这一步我们<strong>可以销毁定时器、解绑全局事件</strong>等。</p> <p>（8）destroyed 钩子函数，在<strong>实例销毁之后调用</strong>，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <p>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。<strong>用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</strong>。</p> <p><strong>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件在组件中使用 addEventListene 是不会销毁的，所以我们在组件销毁时手动移除这些事件监听，避免造成内存泄漏</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function"> addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function"> removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-组件间的参数传递方式"><a href="#vue-组件间的参数传递方式" class="header-anchor">#</a> Vue 组件间的参数传递方式</h2> <p>（1）父子组件间通信</p> <p>第一种方法是子组件通过 <strong>props 属性</strong>来接受父组件的数据，然后<strong>父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据</strong>。</p> <p>第二种是通过 <strong>ref 属性</strong>给子组件设置一个名字。<strong>父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件</strong>，这样也可以实现通信。</p> <p>第三种是使用 <strong>provider/injec</strong>t，在<strong>父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中</strong>。<strong>不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</strong></p> <p>（2）兄弟组件间通信</p> <p>第一种是使用 <strong>eventBus</strong> 的方法，它的本<strong>质是通过创建一个空的 Vue 实例来作为消息传递的对象</strong>，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p> <p>第二种是通过 <strong><code>$parent.$refs</code></strong> 来获取到兄弟组件，也可以进行通信。</p> <p>（3）任意组件之间</p> <p>使用 <strong>eventBus</strong> ，其实就是创建一个<strong>事件中心，相当于中转站</strong>，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 <strong>vuex</strong> ，<strong>vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的</strong>。</p> <p>总结：</p> <ul><li>props/$emit+v-on
<ul><li>父组件通过 props 的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信</li></ul></li> <li>eventBus
<ul><li>通过 eventBus 向中心事件发送或者接收事件，所有事件都可以共用事件中心</li></ul></li> <li>vuex
<ul><li>状态管理模式，采用集中式存储管理应用的所有组件的状态，可以通过 vuex 管理全局的数据</li></ul></li></ul> <h2 id="computed-和-和-watch-的差异"><a href="#computed-和-和-watch-的差异" class="header-anchor">#</a> computed 和 和 watch 的差异</h2> <p>知识点：</p> <p>当我们要进⾏数值计算,⽽且依赖于其他数据，我们需要使用 computed</p> <p>如果你需要在某个数据变化时做⼀些事情，使⽤ watch 来观察这个数据</p> <p>computed：</p> <ul><li>是计算值，</li> <li>应用：就是简化 tempalte 里面计算和处理 props 或$emit 的传值</li> <li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li></ul> <p>watch：</p> <ul><li>是观察的动作，</li> <li>应用：监听 props，$emit 或本组件的值执行异步操作</li> <li>无缓存性，页面重新渲染时值不变化也会执行</li></ul> <p>回答：</p> <p>（1）computed 是<strong>计算一个新的属性，并将该属性挂载到 Vue 实例上</strong>，而 watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数</strong>据，所以<strong>用 watch 同样可以监听 computed 计算属性的变化</strong>。</p> <p>（2）computed 本质是一个<strong>惰性求值的观察者</strong>，具有<strong>缓存性</strong>，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p> <p>（3）从使用场景上说，<strong>computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据</strong></p> <p>computed 是计算属性，<strong>依赖其他属性计算值，并且 computed 的值有缓存</strong>，只有当计算值变化才会返回内容。</p> <p>watch <strong>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</strong>。</p> <h2 id="vue-指令有哪些-v-if-和-v-for-能不能一起使用"><a href="#vue-指令有哪些-v-if-和-v-for-能不能一起使用" class="header-anchor">#</a> vue 指令有哪些，v-if 和 v-for 能不能一起使用</h2> <div class="language- extra-class"><pre class="language-text"><code>v-html，v-text，v-show，v-for，v-if v-else-if v-else，
v-bind（用来动态的绑定一个或者多个特性）
img
v-model（创建双向数据绑定）
v-cloak（保持在元素上直到关联实例结束时进行编译）
v-pre（用来跳过这个元素和它的子元素编译过程）
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">v-if 和 v-for 能不能一起使用(或者问 v-for 和 v-if 谁的优先级更高)：</p> <p>v-for 指令的优先级要高于 v-if，当处于同一节点时候，意味着 v-if 将分别重复运行于每个 v-for 循环中，所以应该尽量避免 v-for 和 v-if 在同一结点</p></div> <h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="header-anchor">#</a> vue-router 中的导航钩子函数</h2> <p>（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，<strong>to 代表要进入的路由对象，from 代表离开的路由对象</strong>。<strong>next 是一个必须要执行的函数</strong>，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p> <p>（2）<strong>单个路由独享的钩子函数 beforeEnter</strong>，它是在路由配置上直接进行定义的。</p> <p>（3）<strong>组件内的导航钩子</strong>主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</p> <h2 id="route-和-和-router-的区别"><a href="#route-和-和-router-的区别" class="header-anchor">#</a> <code>$route</code> 和 和 <code>$router</code> 的区别</h2> <p><strong><code>$route</code> 是“路由信息对象”</strong>，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 <strong><code>$router</code> 是“路由实例”对象</strong>包括了路由的跳转方法，钩子函数等。</p> <h2 id="vue-的路由实现"><a href="#vue-的路由实现" class="header-anchor">#</a> vue 的路由实现</h2> <p>更新视图但不重新请求页面，是前端路由原理的核心，目前在浏览器环境主要有两种方式：</p> <ul><li>Hash 模式(默认)</li></ul> <p>模式的原理是 onhashchange 事件 ，可以在 window 对象上监听这个事件。</p> <p>使用 URL 的 hash 来模拟一个完整的 URL ，于是当 URL 改变时，页面不会重新加载。</p> <p>hash（<code>#</code>） 是 URL 的锚点，代表的是网页中的一个位置，单单改变 <code>#</code> 后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响</p> <p>hash(&quot;#&quot;)符号的本来作用是加在 URL 指示网页中的位置：</p> <div class="language- extra-class"><pre class="language-text"><code>http://www.example.com/index.html#print
</code></pre></div><p><code>#</code>本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取，hash 虽然在 url 中，但是却不会被包含在 http 请求中，也不会重新加载页面，它用来指导浏览器动作</p> <ul><li>History 模式</li></ul> <p>hashchange 只能改变 <code>#</code> 后面的代码片段。</p> <p>这种模式充分利用了 html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。</p> <p>只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求</p> <p>History interface 是浏览器历史记录栈提供的接口，从 HTML5 开始，History interface 提供了 2 个新的方法： pushState()  ， replaceState()  使得我们可以对浏览器历史记录栈进行修改；这两个方法有有一个特点，当调用他们修改浏览器历史栈后，虽然当前 url 改变了，但浏览器不会立即发送请求该 url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础</p> <h2 id="vue-路由懒加载的方式有哪些"><a href="#vue-路由懒加载的方式有哪些" class="header-anchor">#</a> vue 路由懒加载的方式有哪些</h2> <p>懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载，常用的懒加载方式有三种：即使用<strong>vue 异步组件</strong> 和 <strong>ES6 中的 import</strong>，以及<strong>webpack 的 require.ensure()</strong></p> <ul><li>vue 异步组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 路由配置，使用vue异步组件</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/home'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>ES6 中的 import</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 指定了相同的webpackChunkName，合并打包成一个js文件</span>
<span class="token comment">// 如果不指定，则分开打包 2</span>
<span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/*webpackChunkName:'ImportFuncDemo'*/</span> <span class="token string">&quot;@/component/Home&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">Index</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/*webpackChunkName:'ImportFuncDemo'*/</span> <span class="token string">&quot;@/component/Index&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>webpack 推出的 require.ensure()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/hoome'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="header-anchor">#</a> vue 常用的修饰符</h2> <p><code>.prevent</code>: 提交事件<strong>不再重载页面</strong>；<code>.stop</code>: <strong>阻止单击事件冒泡</strong>；<code>.self</code>: 当事件发生在该元素本身而不是子元素的时候会触发；</p> <h2 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="header-anchor">#</a> vue 中 key 值的作用</h2> <p>vue 中 key 值的作用可以分为两种情况来考虑。</p> <p>第一种情况是 <strong>v-if 中使用 key</strong>。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，<strong>如果切换前后含有相同类型的元素，那么这个元素就会被复用</strong>。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 <strong>key 的作用是用来标识一个独立的元素</strong>。</p> <p>第二种情况是 <strong>v-for 中使用 key</strong>。<strong>用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略</strong>。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来<strong>以便 Vue 跟踪元素的身份</strong>，从而高效的实现复用。<strong>这个时候 key 的作用是为了高效的更新渲染虚拟 DOM</strong>。</p> <h2 id="diff-算法的过程-key-的作用"><a href="#diff-算法的过程-key-的作用" class="header-anchor">#</a> diff 算法的过程(key 的作用)</h2> <p>vue 采用“就地复用”策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，key 的作用主要是为了高效的更新虚拟 DOM</p> <div class="custom-block tip"><p class="custom-block-title"> </p> <p>虚拟 dom 的 diff 算法的过程中，先会进⾏新旧节点的⾸尾交叉对比，当⽆法匹配的时候会⽤新节点的 key 与旧节点进⾏⽐对，然后超出差异</p></div> <p><img src="/assets/img/diff.8dd6d8fc.png" alt=""></p> <p>vue 的 diff 位于 patch.js 中，这里简单总结一下 patchVnode 比较的的过程，首先要判断 vnode 和 oldVnode 是否都存在，都存在并且 vnode 和 oldVnode 是同一节点时，才会进入 patchVnode 进行比较，结点比较五种情况：</p> <ul><li>引用一致，可以认为没有变化</li> <li>文本节点的比较，如果需要修改：则会调用 Node.textContent = vnode.text</li> <li>两个节点都有子节点，而且它们不一样：则调用 updateChildren 函数比较子节点</li> <li>只有新的节点有子节点：则调用 addVnodes 创建子节点</li> <li>只有老节点有子节点，则调用 removeVnodes 把这些子节点都删除</li></ul> <p>updateChildren 的过程：updateChildren 用指针的方式把新旧节点的子节点的首尾节点标记，即 oldStartIndex(1)，oldEndIndex(2)，newStartIndex(3), oldEndIndex(4)（这里简单用 12 3 4 顺序标记）即依次比较 13，14，23，24，有 10 种左右情况分别做出对应的处理</p> <h2 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="header-anchor">#</a> keep-alive 组件有什么作用</h2> <p>如果你需要在组件切换的时候，<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件</p> <h2 id="vue-中-mixin-和-mixins-区别"><a href="#vue-中-mixin-和-mixins-区别" class="header-anchor">#</a> vue 中 mixin 和 mixins 区别？</h2> <p>mixin 用于<strong>全局混入</strong>，会影响到每个组件实例。</p> <p>mixins 应该是我们<strong>最常使用的扩展组件的方式</strong>了。<strong>如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码</strong>，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 <strong>mixins 混入的钩子函数会先于组件内的钩子函数执行</strong>，并且在<strong>遇到同名选项的时候也会有选择性的进行合并</strong></p> <h2 id="如何优化不使用到-vue-数据劫持的长列表"><a href="#如何优化不使用到-vue-数据劫持的长列表" class="header-anchor">#</a> 如何优化不使用到 Vue 数据劫持的长列表？</h2> <p>通常 Vue 中的数据在初始化的时候设置数据劫持，但是有些数据不需要进行设置数据劫持，从而减少渲染的时间，只是作为显示使用。</p> <p>为了提高性能，我们使用一下方案冻结 Vue 的数据劫持</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    users<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/api/users&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>users <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="v-for-为什么必须为-item-增加-key-为什么同时避免-v-if"><a href="#v-for-为什么必须为-item-增加-key-为什么同时避免-v-if" class="header-anchor">#</a> v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？</h2> <p>使用 v-for 渲染列表的时候，默认使用 就地复用 策略。当列表的数据修改的时候，会根据 key 值判断某个值是否修改，如果修改则重新渲染这一项，否则复用之前的元素。</p> <ul><li>key 的作用主要是为了高效的更新虚拟 DOM 。</li> <li>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。例如：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>li
  v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;user in activeUsers&quot;</span>
 <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;user.id&quot;</span><span class="token operator">&gt;</span>
 <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
computed<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> activeUsers</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> user<span class="token punctuation">.</span>isActive
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="图片资源懒加载"><a href="#图片资源懒加载" class="header-anchor">#</a> 图片资源懒加载</h2> <p>对于图片多的页面，我们采用懒加载的方式，用户滑动到哪张图片，哪张才开始加载。</p> <p>在 Vue 中主要借助 vue-lazyload 插件进行。</p> <p>安装、引用、使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 安装</span>
npm install vue<span class="token operator">-</span>lazyload <span class="token operator">--</span>save<span class="token operator">-</span>dev
<span class="token comment">// 引入</span>
<span class="token keyword">import</span> VueLazyload <span class="token keyword">from</span> <span class="token string">'vue-lazyload'</span>
<span class="token comment">// 使用</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">)</span>
<span class="token comment">// 自定义选项</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  preLoad<span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">,</span>
  error<span class="token operator">:</span> <span class="token string">'dist/error.png'</span><span class="token punctuation">,</span>
  loading<span class="token operator">:</span> <span class="token string">'dist/loading.gif'</span><span class="token punctuation">,</span>
  attempt<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>img v<span class="token operator">-</span>lazy<span class="token operator">=</span><span class="token string">&quot;/static/img/1.png&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="第三方插件按需引入"><a href="#第三方插件按需引入" class="header-anchor">#</a> 第三方插件按需引入</h2> <p>我们项目中通常用到第三方的插件，但是直接引入所有的组件库，会造成体积太大。我们可以通过 babel-plugin-component ，按需值引用需要的组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 安装</span>
npm install babel<span class="token operator">-</span>plugin<span class="token operator">-</span>component <span class="token operator">-</span><span class="token constant">D</span>
<span class="token comment">// .babelrc</span>
<span class="token punctuation">{</span>
 <span class="token string">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;es2015&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">&quot;modules&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
 <span class="token punctuation">[</span>
   <span class="token string">&quot;component&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token string">&quot;libraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;element-ui&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;styleLibraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;theme-chalk&quot;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.js 引入</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button<span class="token punctuation">,</span> Select <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-ui'</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Select<span class="token punctuation">)</span>
</code></pre></div><h2 id="服务器端渲染"><a href="#服务器端渲染" class="header-anchor">#</a> 服务器端渲染</h2> <p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成。</p> <p>优点：</p> <p>有利于优化 SEO: SEO 的页面抓取是在 Ajax 之前，所以传统的页面是抓取不到 Ajax 的内容的。</p> <p>加快首屏渲染：传统的页面会等待所有 Vue 页面 JS 下载完成后，才进行页面渲染的，文件下载需要等待一定时间。 SSR 直接由服务器渲染好，直接显示页面。</p> <p>缺点：</p> <ul><li>在 Node.js 中渲染完整的应用程序，服务器负载严重，更加大量占用 CPU 资源。</li> <li>开发条件限制。服务端渲染应用程序，需要处于 Node.js server 运行环境。
<blockquote><p>注意：如果只想优化页面的 SEO，可以使用预渲染，只针对于特定路由的静态 HTML 文件。使用 prerender-spa-plugin 插件。</p></blockquote></li></ul> <h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h2> <p>Vuex 的核心是 store 仓库， store 存储着大部分的状态 ( state )，具有两个特点：</p> <ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>不能直接改变 store 的状态，而是通过提交 ( commit ) mutation。这样的好处就是方便我们跟踪每一个变化，而且可以记录每次调试的时候的状态改变。</li></ul> <h3 id="为什么使用-vuex"><a href="#为什么使用-vuex" class="header-anchor">#</a> 为什么使用 Vuex</h3> <ul><li>多个组件依赖于同一状态时。</li> <li>来自不同组件的行为需要变更同一状态</li></ul> <h3 id="四种状态"><a href="#四种状态" class="header-anchor">#</a> 四种状态</h3> <h4 id="state"><a href="#state" class="header-anchor">#</a> State</h4> <p>我们一般在 Vue 组件中使用 state ，通过以下方式：</p> <p><code>this.$store.state.count</code></p> <p>但是我们想要改变一个 store 的状态，使用 mutation 。</p> <p>当一个组件获取多个 state 状态的时，避免操作繁琐，使用 mapState ，而 mapState 函数返回的是一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 箭头函数可使代码更简练</span>
    <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span>
    countAlias<span class="token operator">:</span> <span class="token string">&quot;count&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>
    <span class="token function">countPlusLocalState</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="getter"><a href="#getter" class="header-anchor">#</a> Getter</h4> <p>有时我们需要对获取 state 中的状态数据进行过滤，尤其是多个组件用到该属性，传统的在组件中过滤会造成代码的冗余和重复，所以我们使用 store 的计算属性 getter 。当依赖发生时，才会改变重新计算的值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    todos<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">doneTodos</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>doneTodosCount
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除此之外， getter 返回一个函数，用于传参</p> <div class="language-js extra-class"><pre class="language-js"><code>getters<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getTodoById</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>id <span class="token operator">===</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span><span class="token function">getTodoById</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; { id: 2, text: '...', done: false }</span>
</code></pre></div><p>如果想将 Getter 映射到组件局部的计算属性，直接使用 mapGetter 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>
    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">&quot;doneTodosCount&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;anotherGetter&quot;</span><span class="token punctuation">,</span> <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="mutation"><a href="#mutation" class="header-anchor">#</a> Mutation</h4> <p>我们上述说到，通常使用 Mutation 来改变状态。最重要的一点就是 mutation 只能是<strong>同步任务</strong>，因为如果同步和异步都有，不知道哪个先完成。所以异步任务交给 Action</p> <div class="language-js extra-class"><pre class="language-js"><code>mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count <span class="token operator">+=</span> n
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>于此同时，我们也可以使用提交载荷（对象）的方式。</p> <div class="language-js extra-class"><pre class="language-js"><code>mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count <span class="token operator">+=</span> payload<span class="token punctuation">.</span>amount
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  amount<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在我们多人团队合作中，通常使用常量的方式进行开发，这样看起来便于管理和团队协作开发</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// mutation-types.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">SOME_MUTATION</span> <span class="token operator">=</span> <span class="token string">&quot;SOME_MUTATION&quot;</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// store.js</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">SOME_MUTATION</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mutation-types'</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
     state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>
     <span class="token punctuation">[</span><span class="token constant">SOME_MUTATION</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// mutate state</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以使用 mapMutation 辅助函数将组件中的 methods 映射为 store.commit</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为`this.$store.commit('increment')` // `mapMutations` 也支持载荷：</span>
      <span class="token string">&quot;incrementBy&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为`this.$store.commit('incrementBy', amount)`</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      add<span class="token operator">:</span> <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.add()` 映射为`this.$store.commit('increment')`</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="action"><a href="#action" class="header-anchor">#</a> Action</h4> <p>Action 主要用来处理项目中的<strong>异步任务</strong>，且 Action 提交的是 mutation ，而不是直接变更状态</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
state<span class="token operator">:</span> <span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function">  increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   state<span class="token punctuation">.</span>count<span class="token operator">++</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
actions<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function">  increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 参数解构</span>
actions<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">  commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用分发 Action</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function"> incrementAsync</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">  setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token function">   commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 分发的两种形式</span>
<span class="token comment">// 以载荷形式分发</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'incrementAsync'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
 amount<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 以对象形式分发</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 type<span class="token operator">:</span> <span class="token string">'incrementAsync'</span><span class="token punctuation">,</span>
 amount<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 组件中分发</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span>
</code></pre></div><p>在 action 函数中返回 Promise ，然后再提交时候用 then 处理</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token constant">SET_NUMBER_A</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
<span class="token function">      setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
<span class="token function">        commit</span><span class="token punctuation">(</span><span class="token string">'SET_NUMBER'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">        resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'SET_NUMBER_A'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在异步任务中处理异步任务，使用 ES7 中的 async 和 await 。如下：在 actionB 要提交 actionA</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span><span class="token punctuation">{</span>
 <span class="token keyword">async</span> <span class="token function">actionA</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">//...</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token keyword">async</span> <span class="token function">actionB</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">await</span> <span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token string">'actionA'</span><span class="token punctuation">)</span><span class="token comment">//等待actionA完成</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="model"><a href="#model" class="header-anchor">#</a> Model</h4> <p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时， store 对象就有可能变得相当臃肿。所以使用模块（ Model ）将 store 分隔开单独的模块</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 modules<span class="token operator">:</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>
  b<span class="token operator">:</span> moduleB
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment">// -&gt; moduleA 的状态</span>
store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment">// -&gt; moduleB 的状态</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mian/base/ts.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        TypeScript
      </a></span> <span class="next"><a href="/mian/base/project.html">
        工程化
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3e346258.js" defer></script><script src="/assets/js/2.3070da37.js" defer></script><script src="/assets/js/6.32e6ea72.js" defer></script>
  </body>
</html>