<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>为什么使用 Vue？ | 跌倒的小黄瓜</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="这儿将描述一些东西···💤">
    <link rel="preload" href="/assets/css/0.styles.5251e6d5.css" as="style"><link rel="preload" href="/assets/js/app.7804a0b3.js" as="script"><link rel="preload" href="/assets/js/2.9d52316c.js" as="script"><link rel="preload" href="/assets/js/3.fc2fbd9e.js" as="script"><link rel="prefetch" href="/assets/js/10.997f1175.js"><link rel="prefetch" href="/assets/js/11.c8e68b1c.js"><link rel="prefetch" href="/assets/js/12.7b4d399d.js"><link rel="prefetch" href="/assets/js/13.fe02c68a.js"><link rel="prefetch" href="/assets/js/14.767e6492.js"><link rel="prefetch" href="/assets/js/15.fae12494.js"><link rel="prefetch" href="/assets/js/16.7fcfd0c5.js"><link rel="prefetch" href="/assets/js/17.6080a715.js"><link rel="prefetch" href="/assets/js/18.f194af9d.js"><link rel="prefetch" href="/assets/js/19.a9d004ea.js"><link rel="prefetch" href="/assets/js/20.c20bb810.js"><link rel="prefetch" href="/assets/js/21.90aac146.js"><link rel="prefetch" href="/assets/js/22.78eb74f2.js"><link rel="prefetch" href="/assets/js/23.319e4982.js"><link rel="prefetch" href="/assets/js/24.8366aa54.js"><link rel="prefetch" href="/assets/js/25.f8fa3f9e.js"><link rel="prefetch" href="/assets/js/26.62704a12.js"><link rel="prefetch" href="/assets/js/27.640bcf33.js"><link rel="prefetch" href="/assets/js/28.ae767434.js"><link rel="prefetch" href="/assets/js/29.2f3451e7.js"><link rel="prefetch" href="/assets/js/30.ad641bdb.js"><link rel="prefetch" href="/assets/js/31.7671813f.js"><link rel="prefetch" href="/assets/js/32.ef2b3a32.js"><link rel="prefetch" href="/assets/js/33.226789d6.js"><link rel="prefetch" href="/assets/js/34.15f5ca0b.js"><link rel="prefetch" href="/assets/js/35.e795b3ef.js"><link rel="prefetch" href="/assets/js/36.9de972a8.js"><link rel="prefetch" href="/assets/js/37.f42aab44.js"><link rel="prefetch" href="/assets/js/38.1fedf3ed.js"><link rel="prefetch" href="/assets/js/39.03228b8f.js"><link rel="prefetch" href="/assets/js/4.3e307fce.js"><link rel="prefetch" href="/assets/js/40.81b5ffd1.js"><link rel="prefetch" href="/assets/js/41.eb6343cd.js"><link rel="prefetch" href="/assets/js/42.86ec51c9.js"><link rel="prefetch" href="/assets/js/43.4c71ad1b.js"><link rel="prefetch" href="/assets/js/44.0460b3b2.js"><link rel="prefetch" href="/assets/js/45.07b74c38.js"><link rel="prefetch" href="/assets/js/46.134f073f.js"><link rel="prefetch" href="/assets/js/47.09bea62e.js"><link rel="prefetch" href="/assets/js/48.5fe9acb2.js"><link rel="prefetch" href="/assets/js/49.aed2b82a.js"><link rel="prefetch" href="/assets/js/5.49437d77.js"><link rel="prefetch" href="/assets/js/50.70ce68e0.js"><link rel="prefetch" href="/assets/js/51.f5e4d71c.js"><link rel="prefetch" href="/assets/js/52.c02667bb.js"><link rel="prefetch" href="/assets/js/53.f774f30d.js"><link rel="prefetch" href="/assets/js/54.644fe06f.js"><link rel="prefetch" href="/assets/js/55.6e988143.js"><link rel="prefetch" href="/assets/js/56.48d51fba.js"><link rel="prefetch" href="/assets/js/57.8b082e15.js"><link rel="prefetch" href="/assets/js/58.5c1bc14c.js"><link rel="prefetch" href="/assets/js/59.e20dceb5.js"><link rel="prefetch" href="/assets/js/6.cec4b6ee.js"><link rel="prefetch" href="/assets/js/60.8ce5575c.js"><link rel="prefetch" href="/assets/js/61.d57ab97e.js"><link rel="prefetch" href="/assets/js/62.c3681bea.js"><link rel="prefetch" href="/assets/js/63.90bd940a.js"><link rel="prefetch" href="/assets/js/64.856935ee.js"><link rel="prefetch" href="/assets/js/65.680c7447.js"><link rel="prefetch" href="/assets/js/66.10b8f5c4.js"><link rel="prefetch" href="/assets/js/67.a40eb39d.js"><link rel="prefetch" href="/assets/js/68.9a1dcbf3.js"><link rel="prefetch" href="/assets/js/69.f9c50b2c.js"><link rel="prefetch" href="/assets/js/7.6f34402a.js"><link rel="prefetch" href="/assets/js/70.7b33780d.js"><link rel="prefetch" href="/assets/js/71.509992d3.js"><link rel="prefetch" href="/assets/js/72.d7b48ab2.js"><link rel="prefetch" href="/assets/js/73.6cef776c.js"><link rel="prefetch" href="/assets/js/74.350463b4.js"><link rel="prefetch" href="/assets/js/8.0224a9d3.js"><link rel="prefetch" href="/assets/js/9.9e952900.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5251e6d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">跌倒的小黄瓜</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/mian/index.html">
          面试
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/Demo/index.html">
          Demo
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          其他
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><div><div class="ads"><div id="ads_2"><div class="ant-carousel"><div class="slick-slider slick-initialized"><div class="slick-list"><div class="slick-track"><div tabIndex="-1" data-index="-1" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="0" class="slick-slide slick-active slick-current" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="1" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="2" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="3" aria-hidden="true" class="slick-slide" style="outline:none;width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="4" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/4173c34f96e93981fd435e36b01b96f9.jpeg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="5" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5b98420cfdce4a50987d5b137da4fa08.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="6" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/5699abf03eb19.jpg" title="Ads details here"></a></div></div></div><div tabIndex="-1" data-index="7" aria-hidden="true" class="slick-slide slick-cloned" style="width:null;"><div><div tabIndex="-1" style="width:100%;display:inline-block;"><a href="http://doc1.ygjie.icu/" target="_blank" rel="noopener noreferrer"><img src="https://wx-xly-1301545895.cos.ap-beijing.myqcloud.com/wx-image/doc/timg8.gif" title="Ads details here"></a></div></div></div></div></div><ul class="slick-dots slick-dots-bottom" style="display:block;"><li class="slick-active"><button>1</button></li><li><button>2</button></li><li><button>3</button></li><li><button>4</button></li></ul></div></div></div></div> <div role="separator" id="reset-margin" class="ant-divider ant-divider-horizontal ant-divider-dashed"></div></div> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试知识点</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mian/base/browser.html" title="浏览器" class="sidebar-link">浏览器</a></li><li><a href="/mian/base/html2.html" title="HTML" class="sidebar-link">HTML</a></li><li><a href="/mian/base/css.html" title="CSS" class="sidebar-link">CSS</a></li><li><a href="/mian/base/js.html" title="Javascript" class="sidebar-link">Javascript</a></li><li><a href="/mian/base/Ajax.html" title="Ajax" class="sidebar-link">Ajax</a></li><li><a href="/mian/base/es6.html" title="ES6" class="sidebar-link">ES6</a></li><li><a href="/mian/base/nodejs.html" title="nodejs" class="sidebar-link">nodejs</a></li><li><a href="/mian/base/ts.html" title="TypeScript" class="sidebar-link">TypeScript</a></li><li><a href="/mian/base/vue.html" aria-current="page" title="vue" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/vue.html#为什么使用-vue" title="为什么使用 Vue？" class="sidebar-link">为什么使用 Vue？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#对于-vue-是一套渐进式框架的理解" title="对于 Vue 是一套渐进式框架的理解" class="sidebar-link">对于 Vue 是一套渐进式框架的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-js-的两个核心是什么" title="vue.js 的两个核心是什么？" class="sidebar-link">vue.js 的两个核心是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的优点是什么" title="vue 的优点是什么？" class="sidebar-link">vue 的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#对-mvvm-的理解" title="对 MVVM 的理解" class="sidebar-link">对 MVVM 的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#mvvm-和-mvc-区别-它和其它框架-jquery-的区别是什么-哪些场景适合" title="mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？" class="sidebar-link">mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#说说vue的mvvm实现原理" title="说说Vue的MVVM实现原理" class="sidebar-link">说说Vue的MVVM实现原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-双向数据绑定原理" title="vue 双向数据绑定原理" class="sidebar-link">vue 双向数据绑定原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-双向数据绑定的实现" title="vue 双向数据绑定的实现" class="sidebar-link">vue 双向数据绑定的实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#object-defineproperty-函数" title="Object.defineProperty 函数" class="sidebar-link">Object.defineProperty 函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#使用-object-defineproperty-来进行数据劫持有什么缺点" title="使用 Object.defineProperty() 来进行数据劫持有什么缺点？" class="sidebar-link">使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#object-defineproperty-和-proxy-的优劣区别" title="Object.defineProperty 和 proxy 的优劣区别" class="sidebar-link">Object.defineProperty 和 proxy 的优劣区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#为什么要替换-object-defineproperty-proxy-相比于-defineproperty-的优势" title="为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）" class="sidebar-link">为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#什么是-proxy" title="什么是 Proxy？" class="sidebar-link">什么是 Proxy？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快" title="什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快" class="sidebar-link">什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异" title="除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异" class="sidebar-link">除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何比较两个-dom-树的差异" title="如何比较两个 DOM 树的差异？" class="sidebar-link">如何比较两个 DOM 树的差异？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#对-vue-响应式系统的理解" title="对 vue 响应式系统的理解" class="sidebar-link">对 vue 响应式系统的理解</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-更新数组时触发视图更新的方法" title="vue 更新数组时触发视图更新的方法" class="sidebar-link">vue 更新数组时触发视图更新的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-在什么情况下在数据发生改变的时候不会触发视图更新" title="vue 在什么情况下在数据发生改变的时候不会触发视图更新" class="sidebar-link">vue 在什么情况下在数据发生改变的时候不会触发视图更新</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的生命周期是什么" title="Vue 的生命周期是什么" class="sidebar-link">Vue 的生命周期是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的各个生命阶段是什么" title="Vue 的各个生命阶段是什么？" class="sidebar-link">Vue 的各个生命阶段是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的父组件和子组件生命周期钩子执行顺序是什么" title="Vue 的父组件和子组件生命周期钩子执行顺序是什么" class="sidebar-link">Vue 的父组件和子组件生命周期钩子执行顺序是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-组件间的参数传递方式" title="Vue 组件间的参数传递方式" class="sidebar-link">Vue 组件间的参数传递方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#实现通信方式" title="实现通信方式" class="sidebar-link">实现通信方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#组件的设计原则" title="组件的设计原则" class="sidebar-link">组件的设计原则</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中如何编写可复用的组件" title="vue 中如何编写可复用的组件？" class="sidebar-link">vue 中如何编写可复用的组件？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-组件中-data-为什么必须是函数" title="Vue 组件中 data 为什么必须是函数" class="sidebar-link">Vue 组件中 data 为什么必须是函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中子组件调用父组件的方法" title="vue 中子组件调用父组件的方法" class="sidebar-link">vue 中子组件调用父组件的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中父组件调用子组件的方法" title="vue 中父组件调用子组件的方法" class="sidebar-link">vue 中父组件调用子组件的方法</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#computed-和-和-watch-的差异" title="computed 和 和 watch 的差异" class="sidebar-link">computed 和 和 watch 的差异</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#计算属性的缓存和方法调用的区别" title="计算属性的缓存和方法调用的区别" class="sidebar-link">计算属性的缓存和方法调用的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-指令有哪些-v-if-和-v-for-能不能一起使用" title="vue 指令有哪些，v-if 和 v-for 能不能一起使用" class="sidebar-link">vue 指令有哪些，v-if 和 v-for 能不能一起使用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#v-for-为什么必须为-item-增加-key-为什么同时避免-v-if" title="v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？" class="sidebar-link">v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-slot-是做什么的" title="vue slot 是做什么的?" class="sidebar-link">vue slot 是做什么的?</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#请问-v-if-和-v-show-有什么区别" title="请问 v-if 和 v-show 有什么区别" class="sidebar-link">请问 v-if 和 v-show 有什么区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#v-on-可以监听多个方法吗" title="v-on 可以监听多个方法吗？" class="sidebar-link">v-on 可以监听多个方法吗？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#指令-v-el-的作用是什么" title="指令 v-el 的作用是什么?" class="sidebar-link">指令 v-el 的作用是什么?</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#nexttick-的使用" title="$nextTick 的使用" class="sidebar-link">$nextTick 的使用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-router-中的导航钩子函数" title="vue-router 中的导航钩子函数" class="sidebar-link">vue-router 中的导航钩子函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#route-和-和-router-的区别" title="$route 和 和 $router 的区别" class="sidebar-link">$route 和 和 $router 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的路由实现" title="vue 的路由实现" class="sidebar-link">vue 的路由实现</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-路由懒加载的方式有哪些" title="vue 路由懒加载的方式有哪些" class="sidebar-link">vue 路由懒加载的方式有哪些</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-怎么实现页面的权限控制" title="vue 怎么实现页面的权限控制" class="sidebar-link">vue 怎么实现页面的权限控制</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-常用的修饰符" title="vue 常用的修饰符" class="sidebar-link">vue 常用的修饰符</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-key-值的作用" title="vue 中 key 值的作用" class="sidebar-link">vue 中 key 值的作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#diff-算法的过程-key-的作用" title="diff 算法的过程(key 的作用)" class="sidebar-link">diff 算法的过程(key 的作用)</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#keep-alive-组件有什么作用" title="keep-alive 组件有什么作用" class="sidebar-link">keep-alive 组件有什么作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-mixin-和-mixins-区别" title="vue 中 mixin 和 mixins 区别？" class="sidebar-link">vue 中 mixin 和 mixins 区别？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中的性能优化" title="vue 中的性能优化" class="sidebar-link">vue 中的性能优化</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何优化不使用到-vue-数据劫持的长列表" title="如何优化不使用到 Vue 数据劫持的长列表？" class="sidebar-link">如何优化不使用到 Vue 数据劫持的长列表？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#图片资源懒加载" title="图片资源懒加载" class="sidebar-link">图片资源懒加载</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#第三方插件按需引入" title="第三方插件按需引入" class="sidebar-link">第三方插件按需引入</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#服务器端渲染" title="服务器端渲染" class="sidebar-link">服务器端渲染</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vuex" title="Vuex" class="sidebar-link">Vuex</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/vue.html#为什么使用-vuex" title="为什么使用 Vuex" class="sidebar-link">为什么使用 Vuex</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#不用-vuex-会带来什么问题" title="不用 Vuex 会带来什么问题？" class="sidebar-link">不用 Vuex 会带来什么问题？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#四种状态" title="四种状态" class="sidebar-link">四种状态</a></li></ul></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-cli-工程升级-vue-版本" title="vue-cli 工程升级 vue 版本" class="sidebar-link">vue-cli 工程升级 vue 版本</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#构建的-vue-cli-工程都用到了哪些技术-它们的作用分别是什么" title="构建的 vue-cli 工程都用到了哪些技术，它们的作用分别是什么？" class="sidebar-link">构建的 vue-cli 工程都用到了哪些技术，它们的作用分别是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-cli-工程常用的-npm-命令有哪些" title="vue-cli 工程常用的 npm 命令有哪些？" class="sidebar-link">vue-cli 工程常用的 npm 命令有哪些？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#请说出-vue-cli-工程中每个文件夹和文件的用处" title="请说出 vue-cli 工程中每个文件夹和文件的用处" class="sidebar-link">请说出 vue-cli 工程中每个文件夹和文件的用处</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#config-文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置" title="config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置" class="sidebar-link">config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#请你详细介绍一些-package-json-里面的配置" title="请你详细介绍一些 package.json 里面的配置" class="sidebar-link">请你详细介绍一些 package.json 里面的配置</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-cli-中常用到的加载器" title="vue-cli 中常用到的加载器" class="sidebar-link">vue-cli 中常用到的加载器</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-cli-中怎样使用自定义的组件-有遇到过哪些问题吗" title="vue-cli 中怎样使用自定义的组件？有遇到过哪些问题吗？" class="sidebar-link">vue-cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-事件中如何使用-event-对象" title="vue 事件中如何使用 event 对象？" class="sidebar-link">vue 事件中如何使用 event 对象？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-等单页面应用及其优缺点" title="vue 等单页面应用及其优缺点" class="sidebar-link">vue 等单页面应用及其优缺点</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-如何优化首页的加载速度" title="vue 如何优化首页的加载速度？" class="sidebar-link">vue 如何优化首页的加载速度？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-首页白屏是什么问题引起的" title="vue 首页白屏是什么问题引起的？" class="sidebar-link">vue 首页白屏是什么问题引起的？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中如何实现-proxy-代理" title="Vue 中如何实现 proxy 代理？" class="sidebar-link">Vue 中如何实现 proxy 代理？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-如何实现按需加载配合-webpack-设置" title="vue 如何实现按需加载配合 webpack 设置" class="sidebar-link">vue 如何实现按需加载配合 webpack 设置</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何让-css-只在当前组件中起作用" title="如何让 CSS 只在当前组件中起作用" class="sidebar-link">如何让 CSS 只在当前组件中起作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-loader-是什么-使用它的用途有哪些" title="vue-loader 是什么？使用它的用途有哪些？" class="sidebar-link">vue-loader 是什么？使用它的用途有哪些？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#递归组件的使用" title="递归组件的使用" class="sidebar-link">递归组件的使用</a></li></ul></li><li><a href="/mian/base/react.html" title="react" class="sidebar-link">react</a></li><li><a href="/mian/base/wx.html" title="微信小程序" class="sidebar-link">微信小程序</a></li><li><a href="/mian/base/project.html" title="工程化" class="sidebar-link">工程化</a></li><li><a href="/mian/base/network.html" title="计算机网络" class="sidebar-link">计算机网络</a></li><li><a href="/mian/base/design.html" title="设计模式" class="sidebar-link">设计模式</a></li><li><a href="/mian/base/safe.html" title="安全" class="sidebar-link">安全</a></li><li><a href="/mian/base/better.html" title="性能优化" class="sidebar-link">性能优化</a></li><li><a href="/mian/base/tools.html" title="工具" class="sidebar-link">工具</a></li><li><a href="/mian/base/datastruct.html" title="数据结构" class="sidebar-link">数据结构</a></li><li><a href="/mian/base/jstimu.html" title="js相关题目" class="sidebar-link">js相关题目</a></li><li><a href="/mian/base/suanfa.html" title="算法" class="sidebar-link">算法</a></li><li><a href="/mian/base/select.html" title="选择题" class="sidebar-link">选择题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="为什么使用-vue"><a href="#为什么使用-vue" class="header-anchor">#</a> 为什么使用 Vue？</h2> <p>从前端这么些年的发展史来看，从网页设计年代到了现在大前端时代的来临，各种各样的技术层出不穷。尤其是在前端性能优化方面，为了避免页面的回流和重绘，前辈们总结出了各种解决优化方案，基本都是尽量的减少 DOM 操作。</p> <p>Vue 的诞生，是一个很大的优化方案，直接用虚拟 DOM 映射真实 DOM，来进行更新，避免了直接操作真实 DOM 带来的性能缺陷。</p> <p>为了好理解呢，我们换个通俗一点的说法，当页面涉及到操作 DOM 的时候，我们不直接进行操作，因为这样降低了前端页面的性能。而是将 DOM 拿到内存中去，在内存中更改页面的 DOM ，这时候我们操作 DOM 不会导致每次操作 DOM 就会造成不必要的回流和重绘。更新完所有 DOM 之后，我们将更新完的 DOM 再插入到页面中，这样大大提高了页面的性能</p> <p>虽然这样讲有些欠妥或者不标准，其实 Vue 的虚拟 DOM 的作用可以这样去理解</p> <h2 id="对于-vue-是一套渐进式框架的理解"><a href="#对于-vue-是一套渐进式框架的理解" class="header-anchor">#</a> 对于 Vue 是一套渐进式框架的理解</h2> <p>每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。</p> <p>1、使用 vue，你可以在原有大系统的上面，把一两个组件改用它实现，当 jQuery 用；</p> <p>2、也可以整个用它全家桶开发，当 Angular 用；</p> <p>3、还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO(Object–Oriented )面向对象和设计模式的那套理念。 也可以函数式，都可以。</p> <p>它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。</p> <p>你不必一开始就用 Vue 所有的全家桶，根据场景，官方提供了方便的框架供你使用。</p> <p>场景联想 场景 1： 维护一个老项目管理后台，日常就是提交各种表单了，这时候你可以把 vue 当成一个 js 库来使用，就用来收集 form 表单，和表单验证。</p> <p>场景 2： 得到 boss 认可， 后面整个页面的 dom 用 Vue 来管理，抽组件，列表用 v-for 来循环，用数据驱动 DOM 的变化</p> <p>场景 3: 越来越受大家信赖，领导又找你了，让你去做一个移动端 webapp，直接上了 vue 全家桶！</p> <p>场景 1-3 从最初的只因多看你一眼而用了前端 js 库，一直到最后的大型项目解决方案。</p> <h2 id="vue-js-的两个核心是什么"><a href="#vue-js-的两个核心是什么" class="header-anchor">#</a> vue.js 的两个核心是什么？</h2> <p>数据驱动和组件化思想</p> <h2 id="vue-的优点是什么"><a href="#vue-的优点是什么" class="header-anchor">#</a> vue 的优点是什么？</h2> <p>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的&quot;View&quot;上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</p> <p>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</p> <p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p> <p>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</p> <h2 id="对-mvvm-的理解"><a href="#对-mvvm-的理解" class="header-anchor">#</a> 对 MVVM 的理解</h2> <p>MVC 的弊端：MVC 即&quot;Model-View-Controller&quot;，当视图上发生变化，通过 Controller（控件）将响应传入到 Model（数据源），由数据源改变 View 上面的数据，允许 view 和 model 直接通信，随着业务不断庞大，会出现向蜘蛛网一样难以处理的依赖关系，违背了开发应该遵循的&quot;开放封闭原则&quot;</p> <p>MVVM，萌芽于 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF ，前端最早的 MVVM 框架 knockout 在 2010 年发布</p> <p><img src="/assets/img/MVVM.4e13b383.png" alt=""></p> <p>即&quot;Model-View-ViewModel&quot;，View 通过 View-Model 的 DOM Listeners 将事件绑定到 Model 上，而 Model 则通过 Data Bindings 来管理 View 中的数据，View-Model 从中起到一个连接桥的作用</p> <p><a href="/mian/base/design.html#什么是-mvvm之-比之-mvc-是-有什么区别-什么又是-mvp">MVVM,MVP,MVC</a></p> <hr> <p>MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象（桥梁）。</p> <p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p> <p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p> <h2 id="mvvm-和-mvc-区别-它和其它框架-jquery-的区别是什么-哪些场景适合"><a href="#mvvm-和-mvc-区别-它和其它框架-jquery-的区别是什么-哪些场景适合" class="header-anchor">#</a> mvvm 和 mvc 区别？它和其它框架（jquery）的区别是什么？哪些场景适合？</h2> <p>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p> <p>区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。</p> <p>场景：数据操作比较多的场景，更加便捷</p> <h2 id="说说vue的mvvm实现原理"><a href="#说说vue的mvvm实现原理" class="header-anchor">#</a> 说说Vue的MVVM实现原理</h2> <p>理解</p> <div class="language- extra-class"><pre class="language-text"><code>1)	Vue作为MVVM模式的实现库的2种技术
a.	模板解析
b.	数据绑定

2)	模板解析: 实现初始化显示
a.	解析大括号表达式
b.	解析指令

3)	数据绑定: 实现更新显示
a.	通过数据劫持实现
</code></pre></div><p><strong>原理结构图</strong></p> <p><img src="/assets/img/mvvm3.32c4c3d7.png" alt="vue_006"></p> <h2 id="vue-双向数据绑定原理"><a href="#vue-双向数据绑定原理" class="header-anchor">#</a> vue 双向数据绑定原理</h2> <p>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现的。</p> <p>首先我<strong>们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持</strong>，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</p> <p>数据在 html 模板中一共有<strong>两种绑定情况</strong>，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</p> <p>如果遇到<strong>元素节点</strong>，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</p> <p>如果遇到了绑定的<strong>文本节点</strong>，我们使用 Model 中对应的属性的值来替换这个文本。</p> <p><strong>对于文本节点的更新，我们使用了发布订阅者模式</strong>，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</p> <h2 id="vue-双向数据绑定的实现"><a href="#vue-双向数据绑定的实现" class="header-anchor">#</a> vue 双向数据绑定的实现</h2> <ul><li>vue 内部利用 Object.defineProperty 监听数据变化，使数据具有可观测性，结合发布订阅模式，在数据发生变化时更新视图利用 Proxy 或 Object.defineProperty 生成的 Observer 针对对象/对象的属性进行&quot;劫持&quot;,在属性发生变化后通知订阅者</li> <li>解析器 Compile 解析模板中的 Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li> <li>Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 简单的双向数据绑定</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当属性值发⽣变化时我们可以进⾏额外操作</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="object-defineproperty-函数"><a href="#object-defineproperty-函数" class="header-anchor">#</a> Object.defineProperty 函数</h2> <p>Object.defineProperty 函数一共有三个参数，第一个参数是<strong>需要定义属性的对象</strong>，第二个参数是<strong>需要定义的属性</strong>，第三个是<strong>该属性描述符</strong>。一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</p> <p><strong>语法</strong></p> <p>Object.defineProperty(object, attribute, descriptor)</p> <ul><li>这三个参数都是必输项</li> <li>第一个参数为 目标对象</li> <li>第二个参数为 需要定义的属性或者方法</li> <li>第三个参数为 目标属性所拥有的特性</li></ul> <p><strong>descriptor</strong></p> <p>前两个参数都很明确，重点是第三个参数 descriptor， 它有以下取值</p> <ul><li>value: 属性的值</li> <li>writable: 属性的值是否可被重写（默认为 false）</li> <li>configurable: 总开关，是否可配置，若为 false, 则其他都为 false（默认为 false）</li> <li>enumerable: 属性是否可被枚举（默认为 false）</li> <li>get: 获取该属性的值时调用</li> <li>set: 重写该属性的值时调用</li></ul> <p>一个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//123</span>
a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//123</span>
a<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>item <span class="token keyword">in</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> a<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//c 110</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为 writable 和 enumerable 默认值为 false, 所以对 a.b 赋值无效，也无法遍历它</p> <p><strong>configurable</strong></p> <p>总开关，是否可配置，设置为 false 后，就不能再设置了，否则报错， 例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//error: Uncaught TypeError: Cannot redefine property: b</span>
</code></pre></div><p><strong>writable</strong></p> <p>是否可重写</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
  writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 123</span>
a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">// 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 123， 赋值不起作用。</span>
</code></pre></div><p><strong>enumerable</strong></p> <p>属性特性 enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">3445</span><span class="token punctuation">,</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印[&quot;b&quot;]</span>
</code></pre></div><p>enumerable 改为 false</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">3445</span><span class="token punctuation">,</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//注意咯这里改了</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印[]</span>
</code></pre></div><p><strong>set 和 get</strong></p> <p>如果设置了 set 或 get, 就不能设置 writable 和 value 中的任何一个，否则报错</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt; at Function.defineProperty</span>
</code></pre></div><p>对目标对象的目标属性 赋值和取值 时， 分别触发 set 和 get 方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;你要赋值给我,我的新值是&quot;</span> <span class="token operator">+</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;你取我的值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//注意这里，我硬编码返回2</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//打印 你要赋值给我,我的新值是1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 99</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 你取我的值</span>
<span class="token comment">//打印 2    注意这里，和我的硬编码相同的</span>
</code></pre></div><p>上面的代码中，给 a.b 赋值，b 的值也跟着改变了。原因是给 a.b 赋值，自动调用了 set 方法，在 set 方法中改变了 b 的值。vue 双向绑定的原理就是这个。</p> <h2 id="使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2> <p><strong>有一些对属性的操作，使用这种方法无法拦截</strong>，比如说<strong>通过下标方式修改数组数据</strong>或者<strong>给对象新增属性</strong>，<strong>vue 内部通过重写函数解决了这个问</strong>题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 <strong>Proxy 的好处是它可以完美的监听到任何方式的数据改变</strong>，唯一的缺点是<strong>兼容性的问题</strong>，因为这是 ES6 的语法。</p> <h2 id="object-defineproperty-和-proxy-的优劣区别"><a href="#object-defineproperty-和-proxy-的优劣区别" class="header-anchor">#</a> Object.defineProperty 和 proxy 的优劣区别</h2> <p>Object.defineProperty 兼容性较好，但不能直接监听数组的变化，只能监听对象的属性(有时需要深层遍历)</p> <p>与之相比 proxy 的优点：</p> <ul><li>可以直接监听数组的变化</li> <li>可以直接监听对象而非属性</li> <li>proxy 有多达 13 种的拦截方法，不限于 apply、ownKeys、deleteProperty、has 等等</li> <li>proxy 受到各大浏览器厂商的重视</li></ul> <h2 id="为什么要替换-object-defineproperty-proxy-相比于-defineproperty-的优势"><a href="#为什么要替换-object-defineproperty-proxy-相比于-defineproperty-的优势" class="header-anchor">#</a> 为什么要替换 Object.defineProperty？（Proxy 相比于 defineProperty 的优势）</h2> <p>在 Vue 中，Object.defineProperty 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。</p> <p>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。</p> <p>而要取代它的 Proxy 有以下两个优点;</p> <p>可以劫持整个对象，并返回一个新对象
有 13 种劫持操作
既然 Proxy 能解决以上两个问题，而且 Proxy 作为 es6 的新属性在 vue2.x 之前就有了，为什么 vue2.x 不使用 Proxy 呢？一个很重要的原因就是：</p> <p>Proxy 是 es6 提供的新特性，兼容性不好，最主要的是这个属性无法用 polyfill 来兼容</p> <h2 id="什么是-proxy"><a href="#什么是-proxy" class="header-anchor">#</a> 什么是 Proxy？</h2> <p>1.含义：</p> <p>Proxy 是 ES6 中新增的一个特性，翻译过来意思是&quot;代理&quot;，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p> <p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p> <p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p> <p>2.基本用法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>参数：</p> <p>target 是用 Proxy 包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p> <p>handler 是一个对象，其声明了代理 target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。</p> <p>p 是代理后的对象。当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。Proxy 共有 13 种劫持操作，handler 代理的一些常用的方法有如下几个：</p> <ul><li><p>get：读取</p></li> <li><p>set：修改</p></li> <li><p>has：判断对象是否有该属性</p></li> <li><p>construct：构造函数</p> <p>3.示例：</p></li></ul> <p>下面就用 Proxy 来定义一个对象的 get 和 set，作为一个基础 demo</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 被读取</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> property <span class="token keyword">in</span> target <span class="token operator">?</span> target<span class="token punctuation">[</span>property<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 被设置为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    target<span class="token punctuation">[</span>property<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;tom&quot;</span><span class="token punctuation">;</span> <span class="token comment">//name 被设置为 tom</span>
p<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">//age 被读取 3</span>
</code></pre></div><p>p 读取属性的值时，实际上执行的是 handler.get() ：在控制台输出信息，并且读取被代理对象 obj 的属性。</p> <p>p 设置属性值时，实际上执行的是 handler.set() ：在控制台输出信息，并且设置被代理对象 obj 的属性的值。</p> <h2 id="什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快"><a href="#什么是-virtual-dom-么-为什么-virtual-dom-生-比原生-dom-快" class="header-anchor">#</a> 什么是 Virtual DOM 么 ？为什么 Virtual DOM 生 比原生 DOM 快</h2> <p>我对 Virtual DOM 的理解是:首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 <strong>js 对象树</strong>给保存下来，最后再将 DOM 片段插入到文档中。</p> <p>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p> <p>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，<strong>通过在操作前确定需要做的最小修改</strong>，<strong>尽可能的减少 DOM 操作带来的重流和重绘的影响</strong>。其实 <strong>Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作</strong>。</p> <h2 id="除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异"><a href="#除了数据劫持-vue-为什么还需要虚拟-dom-进行-diff-检测差异" class="header-anchor">#</a> 除了数据劫持，vue 为什么还需要虚拟 DOM 进行 diff 检测差异</h2> <p>现代前端框架主要有两种监听数据的方式：一种是<strong>pull</strong>的方式，一种是<strong>push</strong>的方式</p> <p><strong>pull，其代表为 react</strong>，react 和 vue 基于双向数据绑定的依赖收集的订阅式机制不同，react 是通过显式的触发函数调用来更新视图，比如 setState，然后 React 会一层层的进行 VirtualDom Diff 操作找出差异，通过较暴力 diff 的方式查找哪里发生变化。<strong>另一个代表是 angular 的脏值检测</strong></p> <p><strong>push，其代表为 vue</strong>，当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知；我们知道绑定一个数据通常就需要一个 watcher，那么一旦细粒度过高会产生大量的 watcher，会给增加内存以及依赖追踪的开销，而细粒度过低会无法精准检测变化，因此 vue 选择中细粒度方案，<strong>在组件级进行 push 检测的方式(即依赖响应式系统)，在组件内部进行 Virtual Dom Diff 获取更加具体的差异，所以 vue 采用了 push+pull 结合的方式</strong></p> <h2 id="如何比较两个-dom-树的差异"><a href="#如何比较两个-dom-树的差异" class="header-anchor">#</a> 如何比较两个 DOM 树的差异？</h2> <p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是<strong>在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)</strong>。</p> <p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p> <p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，<strong>列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点</strong>。</p> <h2 id="对-vue-响应式系统的理解"><a href="#对-vue-响应式系统的理解" class="header-anchor">#</a> 对 vue 响应式系统的理解</h2> <p><img src="/assets/img/08.f8f8e868.png" alt=""></p> <p>vue 响应式的原理，首先对象传入 vue 实例作为 data 对象时，首先被 vue 遍历所有属性，调用 Object.defineProperty 设置为 getter 和 setter，每个组件都有一个 watcher 对象，在组件渲染的过程中，把相关的数据都注册成依赖，当数据发生 setter 变化时，会通知 watcehr，从而更新相关联的组件</p> <p>响应式系统简述：</p> <ul><li>任何⼀个 Vue Component 都有⼀个与之对应的 Watcher 实例</li> <li>Vue 的 data 上的属性会被添加 getter 和 setter 属性</li> <li>当 Vue Component render 函数被执⾏的时候，data 上会被触碰(touch)， 即被读，getter ⽅法会被调⽤， 此时 Vue 会去记录此 Vue component 所依赖的所有 data(这⼀过程被称为依赖收集)</li> <li>data 被改动时(主要是⽤户操作)， setter ⽅法会被调⽤， 此时 Vue 会去通知所有依赖于此 data 的组件去调⽤他们的 render 函数进⾏更新</li></ul> <h2 id="vue-更新数组时触发视图更新的方法"><a href="#vue-更新数组时触发视图更新的方法" class="header-anchor">#</a> vue 更新数组时触发视图更新的方法</h2> <p>1.Vue.set 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code>数组修改<span class="token punctuation">;</span>

Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
对象修改<span class="token punctuation">;</span>

Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keyOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>keyOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>2.Vue.delete 删除对象或数组中元素，通过 key 或数组索引，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code>数组修改<span class="token punctuation">;</span>

Vue<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span>$<span class="token keyword">delete</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
对象修改<span class="token punctuation">;</span>

Vue<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> keyOfItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>$<span class="token keyword">delete</span><span class="token punctuation">(</span>keyOfItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>3.数组对象直接修改属性，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  item<span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>4.splice 方法修改数组，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>5.数组整体修改，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> tempArray <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">;</span>
tempArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>show <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>array <span class="token operator">=</span> tempArray<span class="token punctuation">;</span>
</code></pre></div><p>6.用 Object.assign 或 lodash.assign 可以为对象添加响应式属性，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//assign与Object.assign一样</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//merge会递归的合并属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>7.Vue 提供了如下的数组的变异方法，可以触发视图更新</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unshift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">splice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="vue-在什么情况下在数据发生改变的时候不会触发视图更新"><a href="#vue-在什么情况下在数据发生改变的时候不会触发视图更新" class="header-anchor">#</a> vue 在什么情况下在数据发生改变的时候不会触发视图更新</h2> <p>v-for 遍历的数组，当数组内容使用的是 <code>arr[0].xx =xx</code> 更改数据，vue 无法监测到 vm.arr.length = newLength 也是无法检测的到的</p> <h2 id="vue-的生命周期是什么"><a href="#vue-的生命周期是什么" class="header-anchor">#</a> Vue 的生命周期是什么</h2> <p>Vue 的生命周期指的是<strong>组件从创建到销毁的一系列的过程</strong>，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作</p> <p><img src="/assets/img/vue-life-cycle.011913ba.png" alt=""> <img src="/assets/img/vue-ifecycle2.f08ad4f1.jpg" alt=""></p> <ul><li>beforeCreate：完成实例初始化，初始化非响应式变量</li> <li>created：实例初始化完成(未挂载 DOM)</li> <li>berofeMount：找到对应的 template，并编译成 render 函数</li> <li>mounted：完成创建 vm.$el 和双向绑定，完成 DOM 挂载</li> <li>beforeUpdate：数据更新之前(可在更新前访问现有的 DOM)</li> <li>updated：完成虚拟 DOM 的重新渲染和打补丁</li> <li>activated：子组件需要在每次加载时候进行某些操作，可以使用 activated 钩子触发</li> <li>deactivated：keep-alive 组件被移除时使用</li> <li>beforeDestroy：可做一些删除提示，销毁定时器，解绑全局时间 销毁插件对象</li> <li>destroyed：当前组件已被销毁</li></ul> <h2 id="vue-的各个生命阶段是什么"><a href="#vue-的各个生命阶段是什么" class="header-anchor">#</a> Vue 的各个生命阶段是什么？</h2> <p>Vue 一共有 <strong>8</strong> 个生命阶段，分别是<strong>创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后</strong>，每个阶段对应了一个生命周期的钩子函数。</p> <p>（1）beforeCreate 钩子函数，在<strong>实例初始化之后</strong>，在<strong>数据监听和事件配置之前触发</strong>。因此在这个事件中我们是<strong>获取不到 data 数据</strong>的。</p> <p>（2）created 钩子函数，在<strong>实例创建完成后触发</strong>，此时可以访问 data、methods 等属性。但这个时候<strong>组件还没有被挂载到页面中去</strong>，所以这个时候访问<strong>不到 $el 属性</strong>。一般我们可以在这个函数中<strong>进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化</strong>。</p> <p>（3）beforeMount 钩子函数，在<strong>组件被挂载到页面之前触发</strong>。<strong>在 beforeMount 之前，会找到对应的 template，并编译成 render 函数</strong>。</p> <p>（4）mounted 钩子函数，在<strong>组件挂载到页面之后触发</strong>。此时<strong>可以通过 DOM API 获取到页面中的 DOM 元素</strong>。</p> <p>（5）beforeUpdate 钩子函数，在<strong>响应式数据更新时触发</strong>，发生在虚拟 DOM 重新渲染和打补丁之前**，这个时候我们可以**对可能会被移除的元素做一些操作**，比如移除事件监听器。</p> <p>（6）updated 钩子函数，<strong>虚拟 DOM 重新渲染和打补丁之后调用</strong>。</p> <p>（7）beforeDestroy 钩子函数，在<strong>实例销毁之前调用</strong>。一般在这一步我们<strong>可以销毁定时器、解绑全局事件</strong>等。</p> <p>（8）destroyed 钩子函数，在<strong>实例销毁之后调用</strong>，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <p>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。<strong>用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</strong>。</p> <p><strong>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件在组件中使用 addEventListene 是不会销毁的，所以我们在组件销毁时手动移除这些事件监听，避免造成内存泄漏</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function"> addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function"> removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-的父组件和子组件生命周期钩子执行顺序是什么"><a href="#vue-的父组件和子组件生命周期钩子执行顺序是什么" class="header-anchor">#</a> Vue 的父组件和子组件生命周期钩子执行顺序是什么</h2> <ul><li><p>加载渲染过程</p> <ul><li>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li></ul></li> <li><p>子组件更新过程</p> <ul><li>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li></ul></li> <li><p>父组件更新过程</p> <ul><li>父beforeUpdate-&gt;父updated</li></ul></li> <li><p>销毁过程</p> <ul><li>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li></ul></li></ul> <h2 id="vue-组件间的参数传递方式"><a href="#vue-组件间的参数传递方式" class="header-anchor">#</a> Vue 组件间的参数传递方式</h2> <p>（1）父子组件间通信</p> <p>第一种方法是子组件通过 <strong>props 属性</strong>来接受父组件的数据，然后<strong>父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据</strong>。</p> <p>第二种是通过 <strong>ref 属性</strong>给子组件设置一个名字。<strong>父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件</strong>，这样也可以实现通信。</p> <p>第三种是使用 <strong>provider/injec</strong>t，在<strong>父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中</strong>。<strong>不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</strong></p> <p>（2）兄弟组件间通信</p> <p>第一种是使用 <strong>eventBus</strong> 的方法，它的本<strong>质是通过创建一个空的 Vue 实例来作为消息传递的对象</strong>，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p> <p>第二种是通过 <strong><code>$parent.$refs</code></strong> 来获取到兄弟组件，也可以进行通信。</p> <p>（3）任意组件之间</p> <p>使用 <strong>eventBus</strong> ，其实就是创建一个<strong>事件中心，相当于中转站</strong>，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 <strong>vuex</strong> ，<strong>vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的</strong>。</p> <p>总结：</p> <ul><li>props/$emit+v-on
<ul><li>父组件通过 props 的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信</li></ul></li> <li>eventBus
<ul><li>通过 eventBus 向中心事件发送或者接收事件，所有事件都可以共用事件中心</li></ul></li> <li>vuex
<ul><li>状态管理模式，采用集中式存储管理应用的所有组件的状态，可以通过 vuex 管理全局的数据</li></ul></li></ul> <h2 id="实现通信方式"><a href="#实现通信方式" class="header-anchor">#</a> 实现通信方式</h2> <div class="language- extra-class"><pre class="language-text"><code>方式1: props
1)	通过一般属性实现父向子通信
2)	通过函数属性实现子向父通信
3)	缺点: 隔代组件和兄弟组件间通信比较麻烦

方式2: vue自定义事件
1)	vue内置实现, 可以代替函数类型的props
  a.	绑定监听: &lt;MyComp @eventName=&quot;callback&quot;
  b.	触发(分发)事件: this.$emit(&quot;eventName&quot;, data)
2)	缺点: 只适合于子向父通信

方式3: 消息订阅与发布
1)	需要引入消息订阅与发布的实现库, 如: pubsub-js
  a.	订阅消息: PubSub.subscribe('msg', (msg, data)=&gt;{})
  b.	发布消息: PubSub.publish(‘msg’, data)
2)	优点: 此方式可用于任意关系组件间通信

方式4: vuex
1)	是什么: vuex是vue官方提供的集中式管理vue多组件共享状态数据的vue插件
2)	优点: 对组件间关系没有限制, 且相比于pubsub库管理更集中, 更方便

方式5: slot
1)	是什么: 专门用来实现父向子传递带数据的标签
  a.	子组件
  b.	父组件
2)	注意: 通信的标签模板是在父组件中解析好后再传递给子组件的
</code></pre></div><h2 id="组件的设计原则"><a href="#组件的设计原则" class="header-anchor">#</a> 组件的设计原则</h2> <ul><li>页面上每个独立的可视/可交互区域视为一个组件(比如页面的头部，尾部，可复用的区块)</li> <li>每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护(组件的就近维护思想体现了前端的工程化思想，为前端开发提供了很好的分治策略，在 vue.js 中，通过.vue 文件将组件依赖的模板，js，样式写在一个文件中)</li> <li>每个开发者清楚开发维护的功能单元，它的代码必然存在在对应的组件目录中，在该目录下，可以找到功能单元所有的内部逻辑)</li> <li>页面不过是组件的容器，组件可以嵌套自由组合成完整的页面</li></ul> <h2 id="vue-中如何编写可复用的组件"><a href="#vue-中如何编写可复用的组件" class="header-anchor">#</a> vue 中如何编写可复用的组件？</h2> <p>总结组件的职能，什么需要外部控制（即 props 传啥），组件需要控制外部吗（$emit）,是否需要插槽（slot）</p> <h2 id="vue-组件中-data-为什么必须是函数"><a href="#vue-组件中-data-为什么必须是函数" class="header-anchor">#</a> Vue 组件中 data 为什么必须是函数</h2> <p>在 new Vue() 中，data 是可以作为一个对象进行操作的，然而在 component 中，data 只能以函数的形式存在，不能直接将对象赋值给它，这并非是 Vue 自身如此设计，而是跟 JavaScript 特性相关，我们来回顾下 JavaScript 的原型链</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Component</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">{</span>
  message<span class="token operator">:</span> <span class="token string">&quot;Love&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> component1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  component2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
component1<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&quot;Peace&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>component2<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Peace</span>
</code></pre></div><p>以上<strong>两个实例都引用同一个原型对象，当其中一个实例属性改变时，另一个实例属性也随之改变，只有当两个实例拥有自己的作用域时，才不会互相干扰</strong> ！！！！！这句是重点！！！！！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Component</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">data</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> <span class="token string">&quot;Love&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> component1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  component2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
component1<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&quot;Peace&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>component2<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Love</span>
</code></pre></div><h2 id="vue-中子组件调用父组件的方法"><a href="#vue-中子组件调用父组件的方法" class="header-anchor">#</a> vue 中子组件调用父组件的方法</h2> <ul><li>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</li> <li>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</li> <li>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul> <p>解析：</p> <p>第一种方法是直接在子组件中通过 this.$parent.event 来调用父组件的方法</p> <p>父组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>child<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>child<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">'~/components/dam/child'</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      child
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">fatherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'测试'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>子组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>childMethod()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">childMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span><span class="token function">fatherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>第二种方法是在子组件里用$emit 向父组件触发一个事件，父组件监听这个事件就行了</p> <p>父组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">@fatherMethod</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fatherMethod<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">&quot;~/components/dam/child&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      child<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">fatherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;测试&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>childMethod()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">childMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;fatherMethod&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</p> <p>父组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:fatherMethod</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fatherMethod<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> child <span class="token keyword">from</span> <span class="token string">&quot;~/components/dam/child&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      child<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">fatherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;测试&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>childMethod()<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span>
      fatherMethod<span class="token operator">:</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> Function<span class="token punctuation">,</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">childMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fatherMethod<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fatherMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="vue-中父组件调用子组件的方法"><a href="#vue-中父组件调用子组件的方法" class="header-anchor">#</a> vue 中父组件调用子组件的方法</h2> <p>使用$refs</p> <p>解析：</p> <p>父组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>clickParent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>mychild<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> Child <span class="token keyword">from</span> <span class="token string">&quot;./child&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;parent&quot;</span><span class="token punctuation">,</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      child<span class="token operator">:</span> Child<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">clickParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>mychild<span class="token punctuation">.</span><span class="token function">parentHandleclick</span><span class="token punctuation">(</span><span class="token string">&quot;嘿嘿嘿&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划重点！！！！</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>子组件</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    child
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;child&quot;</span><span class="token punctuation">,</span>
    props<span class="token operator">:</span> <span class="token string">&quot;someprops&quot;</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">parentHandleclick</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="computed-和-和-watch-的差异"><a href="#computed-和-和-watch-的差异" class="header-anchor">#</a> computed 和 和 watch 的差异</h2> <p>知识点：</p> <p>当我们要进⾏数值计算,⽽且依赖于其他数据，我们需要使用 computed</p> <p>如果你需要在某个数据变化时做⼀些事情，使⽤ watch 来观察这个数据</p> <p>computed：</p> <ul><li>是计算值，</li> <li>应用：就是简化 tempalte 里面计算和处理 props 或$emit 的传值</li> <li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li></ul> <p>watch：</p> <ul><li>是观察的动作，</li> <li>应用：监听 props，$emit 或本组件的值执行异步操作</li> <li>无缓存性，页面重新渲染时值不变化也会执行</li></ul> <p>回答：</p> <p>（1）computed 是<strong>计算一个新的属性，并将该属性挂载到 Vue 实例上</strong>，而 watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数</strong>据，所以<strong>用 watch 同样可以监听 computed 计算属性的变化</strong>。</p> <p>（2）computed 本质是一个<strong>惰性求值的观察者</strong>，具有<strong>缓存性</strong>，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p> <p>（3）从使用场景上说，<strong>computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据</strong></p> <p>computed 是计算属性，<strong>依赖其他属性计算值，并且 computed 的值有缓存</strong>，只有当计算值变化才会返回内容。</p> <p>watch <strong>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</strong>。</p> <h2 id="计算属性的缓存和方法调用的区别"><a href="#计算属性的缓存和方法调用的区别" class="header-anchor">#</a> 计算属性的缓存和方法调用的区别</h2> <p>计算属性是基于数据的依赖缓存，数据发生变化，缓存才会发生变化，如果数据没有发生变化，调用计算属性直接调用的是存储的缓存值；</p> <p>而方法每次调用都会重新计算；所以可以根据实际需要选择使用，如果需要计算大量数据，性能开销比较大，可以选用计算属性，如果不能使用缓存可以使用方法；</p> <p>其实这两个区别还应加一个 watch，watch 是用来监测数据的变化，和计算属性相比，是 watch 没有缓存，但是一般想要在数据变化时响应时，或者执行异步操作时，可以选择 watch</p> <h2 id="vue-指令有哪些-v-if-和-v-for-能不能一起使用"><a href="#vue-指令有哪些-v-if-和-v-for-能不能一起使用" class="header-anchor">#</a> vue 指令有哪些，v-if 和 v-for 能不能一起使用</h2> <div class="language- extra-class"><pre class="language-text"><code>v-html，v-text，v-show，v-for，v-if v-else-if v-else，
v-bind（用来动态的绑定一个或者多个特性）
img
v-model（创建双向数据绑定）
v-cloak（保持在元素上直到关联实例结束时进行编译）
v-pre（用来跳过这个元素和它的子元素编译过程）
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">v-if 和 v-for 能不能一起使用(或者问 v-for 和 v-if 谁的优先级更高)：</p> <p>v-for 指令的优先级要高于 v-if，当处于同一节点时候，意味着 v-if 将分别重复运行于每个 v-for 循环中，所以应该尽量避免 v-for 和 v-if 在同一结点</p></div> <h2 id="v-for-为什么必须为-item-增加-key-为什么同时避免-v-if"><a href="#v-for-为什么必须为-item-增加-key-为什么同时避免-v-if" class="header-anchor">#</a> v-for 为什么必须为 item 增加 key？为什么同时避免 v-if？</h2> <p>使用 v-for 渲染列表的时候，默认使用 就地复用 策略。当列表的数据修改的时候，会根据 key 值判断某个值是否修改，如果修改则重新渲染这一项，否则复用之前的元素。</p> <ul><li>key 的作用主要是为了高效的更新虚拟 DOM 。</li> <li>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。例如：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>li
  v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;user in activeUsers&quot;</span>
 <span class="token operator">:</span>key<span class="token operator">=</span><span class="token string">&quot;user.id&quot;</span><span class="token operator">&gt;</span>
 <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
computed<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> activeUsers</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> user<span class="token punctuation">.</span>isActive
 <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-slot-是做什么的"><a href="#vue-slot-是做什么的" class="header-anchor">#</a> vue slot 是做什么的?</h2> <p>可以插入的槽口，比如插座的插孔。</p> <h2 id="请问-v-if-和-v-show-有什么区别"><a href="#请问-v-if-和-v-show-有什么区别" class="header-anchor">#</a> 请问 v-if 和 v-show 有什么区别</h2> <p>v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏</p> <p>v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果</p> <h2 id="v-on-可以监听多个方法吗"><a href="#v-on-可以监听多个方法吗" class="header-anchor">#</a> v-on 可以监听多个方法吗？</h2> <p>肯定可以的。</p> <p>解析：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onInput<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@focus</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onFocus<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@blur</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onBlur<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">/&gt;</span></span>
</code></pre></div><h2 id="指令-v-el-的作用是什么"><a href="#指令-v-el-的作用是什么" class="header-anchor">#</a> 指令 v-el 的作用是什么?</h2> <p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例</p> <h2 id="nexttick-的使用"><a href="#nexttick-的使用" class="header-anchor">#</a> <code>$nextTick</code> 的使用</h2> <p>1、什么是 Vue.nextTick()？</p> <p>定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <p>所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。所以放在 Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码；</p> <p>理解：<strong>nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用</strong>，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数，</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">&quot;firstBtn&quot;</span> @click<span class="token operator">=</span><span class="token string">&quot;testClick()&quot;</span> ref<span class="token operator">=</span><span class="token string">&quot;aa&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>testMsg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'HelloWorld'</span><span class="token punctuation">,</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      testMsg<span class="token operator">:</span><span class="token string">&quot;原始值&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">testClick</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span>testMsg<span class="token operator">=</span><span class="token string">&quot;修改后的值&quot;</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>aa<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//that.$refs.aa获取指定DOM，输出：原始值</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>使用 this.$nextTick()</p> <div class="language-js extra-class"><pre class="language-js"><code>methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">testClick</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span>testMsg<span class="token operator">=</span><span class="token string">&quot;修改后的值&quot;</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>aa<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出：修改后的值</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM，</p> <p>2、什么时候需要用的 Vue.nextTick()？？</p> <p>1、Vue 生命周期的 <strong>created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中</strong>，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    that<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//不使用this.$nextTick()方法会报错</span>
        that<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>aa<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">&quot;created中更改了按钮内容&quot;</span><span class="token punctuation">;</span>  <span class="token comment">//写入到DOM元素</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2、<strong>当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中</strong>；通俗的理解是：更改数据后当你想立即使用 js 操作新的视图的时候需要使用它</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h3 id<span class="token operator">=</span><span class="token string">&quot;h&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>testMsg<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'HelloWorld'</span><span class="token punctuation">,</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      testMsg<span class="token operator">:</span><span class="token string">&quot;原始值&quot;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">changeTxt</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span>testMsg<span class="token operator">=</span><span class="token string">&quot;修改后的文本值&quot;</span><span class="token punctuation">;</span>  <span class="token comment">//vue数据改变，改变dom结构</span>
      <span class="token keyword">let</span> domTxt<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText<span class="token punctuation">;</span>  <span class="token comment">//后续js对dom的操作</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>domTxt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>domTxt<span class="token operator">===</span><span class="token string">&quot;原始值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;文本data被修改后dom内容没立即更新&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;文本data被修改后dom内容被马上更新了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>正确的用法是：vue 改变 dom 元素结构后使用 vue.$nextTick()方法来实现 dom 数据更新后延迟执行后续代码</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token function-variable function">changeTxt</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> that<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>
      that<span class="token punctuation">.</span>testMsg<span class="token operator">=</span><span class="token string">&quot;修改后的文本值&quot;</span><span class="token punctuation">;</span>  <span class="token comment">//修改dom结构</span>

      that<span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//使用vue.$nextTick()方法可以dom数据更新后延迟执行</span>
        <span class="token keyword">let</span> domTxt<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'h'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText<span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>domTxt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出可以看到vue数据修改后并没有DOM没有立即更新，</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>domTxt<span class="token operator">===</span><span class="token string">&quot;原始值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;文本data被修改后dom内容没立即更新&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;文本data被修改后dom内容被马上更新了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>3、<strong>在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法</strong>。</p> <p>Vue.nextTick(callback) 使用原理：</p> <p>原因是，Vue 是异步执行 dom 更新的，一旦观察到数据变化，Vue 就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个 watcher 被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和 DOm 操作。而在下一个事件循环时，Vue 会清空队列，并进行必要的 DOM 更新。
当你设置 vm.someData = 'new value'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p> <h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="header-anchor">#</a> vue-router 中的导航钩子函数</h2> <p>（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，<strong>to 代表要进入的路由对象，from 代表离开的路由对象</strong>。<strong>next 是一个必须要执行的函数</strong>，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p> <p>（2）<strong>单个路由独享的钩子函数 beforeEnter</strong>，它是在路由配置上直接进行定义的。</p> <p>（3）<strong>组件内的导航钩子</strong>主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</p> <h2 id="route-和-和-router-的区别"><a href="#route-和-和-router-的区别" class="header-anchor">#</a> <code>$route</code> 和 和 <code>$router</code> 的区别</h2> <p><strong><code>$route</code> 是“路由信息对象”</strong>，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 <strong><code>$router</code> 是“路由实例”对象</strong>包括了路由的跳转方法，钩子函数等。</p> <h2 id="vue-的路由实现"><a href="#vue-的路由实现" class="header-anchor">#</a> vue 的路由实现</h2> <p>更新视图但不重新请求页面，是前端路由原理的核心，目前在浏览器环境主要有两种方式：</p> <ul><li>Hash 模式(默认)</li></ul> <p>模式的原理是 onhashchange 事件 ，可以在 window 对象上监听这个事件。</p> <p>使用 URL 的 hash 来模拟一个完整的 URL ，于是当 URL 改变时，页面不会重新加载。</p> <p>hash（<code>#</code>） 是 URL 的锚点，代表的是网页中的一个位置，单单改变 <code>#</code> 后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 hash 出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响</p> <p>hash(&quot;#&quot;)符号的本来作用是加在 URL 指示网页中的位置：</p> <div class="language- extra-class"><pre class="language-text"><code>http://www.example.com/index.html#print
</code></pre></div><p><code>#</code>本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取，hash 虽然在 url 中，但是却不会被包含在 http 请求中，也不会重新加载页面，它用来指导浏览器动作</p> <ul><li>History 模式</li></ul> <p>hashchange 只能改变 <code>#</code> 后面的代码片段。</p> <p>这种模式充分利用了 html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。</p> <p>只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求</p> <p>History interface 是浏览器历史记录栈提供的接口，从 HTML5 开始，History interface 提供了 2 个新的方法： pushState()  ， replaceState()  使得我们可以对浏览器历史记录栈进行修改；这两个方法有有一个特点，当调用他们修改浏览器历史栈后，虽然当前 url 改变了，但浏览器不会立即发送请求该 url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础</p> <h2 id="vue-路由懒加载的方式有哪些"><a href="#vue-路由懒加载的方式有哪些" class="header-anchor">#</a> vue 路由懒加载的方式有哪些</h2> <p>懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载，常用的懒加载方式有三种：即使用<strong>vue 异步组件</strong> 和 <strong>ES6 中的 import</strong>，以及<strong>webpack 的 require.ensure()</strong></p> <ul><li>vue 异步组件</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 路由配置，使用vue异步组件</span>
<span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/home'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>ES6 中的 import</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 指定了相同的webpackChunkName，合并打包成一个js文件</span>
<span class="token comment">// 如果不指定，则分开打包 2</span>
<span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/*webpackChunkName:'ImportFuncDemo'*/</span> <span class="token string">&quot;@/component/Home&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">Index</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/*webpackChunkName:'ImportFuncDemo'*/</span> <span class="token string">&quot;@/component/Index&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>webpack 推出的 require.ensure()</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  path<span class="token operator">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/hoome'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-怎么实现页面的权限控制"><a href="#vue-怎么实现页面的权限控制" class="header-anchor">#</a> vue 怎么实现页面的权限控制</h2> <p>利用 vue-router 的 beforeEach 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。</p> <h2 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="header-anchor">#</a> vue 常用的修饰符</h2> <p><code>.prevent</code>: 提交事件<strong>不再重载页面</strong>；<code>.stop</code>: <strong>阻止单击事件冒泡</strong>；<code>.self</code>: 当事件发生在该元素本身而不是子元素的时候会触发；</p> <h2 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="header-anchor">#</a> vue 中 key 值的作用</h2> <p>vue 中 key 值的作用可以分为两种情况来考虑。</p> <p>第一种情况是 <strong>v-if 中使用 key</strong>。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，<strong>如果切换前后含有相同类型的元素，那么这个元素就会被复用</strong>。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 <strong>key 的作用是用来标识一个独立的元素</strong>。</p> <p>第二种情况是 <strong>v-for 中使用 key</strong>。<strong>用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略</strong>。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来<strong>以便 Vue 跟踪元素的身份</strong>，从而高效的实现复用。<strong>这个时候 key 的作用是为了高效的更新渲染虚拟 DOM</strong>。</p> <h2 id="diff-算法的过程-key-的作用"><a href="#diff-算法的过程-key-的作用" class="header-anchor">#</a> diff 算法的过程(key 的作用)</h2> <p>vue 采用“就地复用”策略，如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，key 的作用主要是为了高效的更新虚拟 DOM</p> <div class="custom-block tip"><p class="custom-block-title"> </p> <p>虚拟 dom 的 diff 算法的过程中，先会进⾏新旧节点的⾸尾交叉对比，当⽆法匹配的时候会⽤新节点的 key 与旧节点进⾏⽐对，然后超出差异</p></div> <p><img src="/assets/img/diff.8dd6d8fc.png" alt=""></p> <p>vue 的 diff 位于 patch.js 中，这里简单总结一下 patchVnode 比较的的过程，首先要判断 vnode 和 oldVnode 是否都存在，都存在并且 vnode 和 oldVnode 是同一节点时，才会进入 patchVnode 进行比较，结点比较五种情况：</p> <ul><li>引用一致，可以认为没有变化</li> <li>文本节点的比较，如果需要修改：则会调用 Node.textContent = vnode.text</li> <li>两个节点都有子节点，而且它们不一样：则调用 updateChildren 函数比较子节点</li> <li>只有新的节点有子节点：则调用 addVnodes 创建子节点</li> <li>只有老节点有子节点，则调用 removeVnodes 把这些子节点都删除</li></ul> <p>updateChildren 的过程：updateChildren 用指针的方式把新旧节点的子节点的首尾节点标记，即 oldStartIndex(1)，oldEndIndex(2)，newStartIndex(3), oldEndIndex(4)（这里简单用 12 3 4 顺序标记）即依次比较 13，14，23，24，有 10 种左右情况分别做出对应的处理</p> <h2 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="header-anchor">#</a> keep-alive 组件有什么作用</h2> <p>如果你需要在组件切换的时候，<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件</p> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p> <p>解析：</p> <p>用法也很简单：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 该组件将被缓存！ --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>props
_ include - 字符串或正则表达，只有匹配的组件会被缓存
_ exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 组件 a</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">include</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- name 为 a 的组件将被缓存！ --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span>
<span class="token punctuation">&gt;</span></span>可以保留它的状态或避免重新渲染
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span> <span class="token attr-name">exclude</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 除了 name 为 a 的组件都将被缓存！ --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span>
<span class="token punctuation">&gt;</span></span>可以保留它的状态或避免重新渲染
</code></pre></div><p>但实际项目中,需要配合 vue-router 共同使用.</p> <p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果只想 router-view 里面某个组件被缓存，怎么办？</p> <p>增加 router.meta 属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// routes 配置</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">&quot;home&quot;</span><span class="token punctuation">,</span>
    component<span class="token operator">:</span> Home<span class="token punctuation">,</span>
    meta<span class="token operator">:</span> <span class="token punctuation">{</span>
      keepAlive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 需要被缓存</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">&quot;/:id&quot;</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">&quot;edit&quot;</span><span class="token punctuation">,</span>
    component<span class="token operator">:</span> Edit<span class="token punctuation">,</span>
    meta<span class="token operator">:</span> <span class="token punctuation">{</span>
      keepAlive<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 不需要被缓存</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$route.meta.keepAlive<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>!$route.meta.keepAlive<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2 id="vue-中-mixin-和-mixins-区别"><a href="#vue-中-mixin-和-mixins-区别" class="header-anchor">#</a> vue 中 mixin 和 mixins 区别？</h2> <p>mixin 用于<strong>全局混入</strong>，会影响到每个组件实例。</p> <p>mixins 应该是我们<strong>最常使用的扩展组件的方式</strong>了。<strong>如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码</strong>，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 <strong>mixins 混入的钩子函数会先于组件内的钩子函数执行</strong>，并且在<strong>遇到同名选项的时候也会有选择性的进行合并</strong></p> <h2 id="vue-中的性能优化"><a href="#vue-中的性能优化" class="header-anchor">#</a> vue 中的性能优化</h2> <p>1、Vue 应用运行时性能优化措施</p> <p>（1）引入生产环境的 Vue 文件</p> <p>（2）使用单文件组件预编译模板</p> <p>（3）提取组件的 CSS 到单独到文件</p> <p>（4）利用 Object.freeze()提升性能</p> <p>（5）扁平化 Store 数据结构</p> <p>（6）合理使用持久化 Store 数据</p> <p>（7）组件懒加载</p> <p>2、Vue 应用加载性能优化措施</p> <p>（1）服务端渲染 / 预渲染</p> <p>（2）组件懒加载</p> <h2 id="如何优化不使用到-vue-数据劫持的长列表"><a href="#如何优化不使用到-vue-数据劫持的长列表" class="header-anchor">#</a> 如何优化不使用到 Vue 数据劫持的长列表？</h2> <p>通常 Vue 中的数据在初始化的时候设置数据劫持，但是有些数据不需要进行设置数据劫持，从而减少渲染的时间，只是作为显示使用。</p> <p>为了提高性能，我们使用一下方案冻结 Vue 的数据劫持</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    users<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/api/users&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>users <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="图片资源懒加载"><a href="#图片资源懒加载" class="header-anchor">#</a> 图片资源懒加载</h2> <p>对于图片多的页面，我们采用懒加载的方式，用户滑动到哪张图片，哪张才开始加载。</p> <p>在 Vue 中主要借助 vue-lazyload 插件进行。</p> <p>安装、引用、使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 安装</span>
npm install vue<span class="token operator">-</span>lazyload <span class="token operator">--</span>save<span class="token operator">-</span>dev
<span class="token comment">// 引入</span>
<span class="token keyword">import</span> VueLazyload <span class="token keyword">from</span> <span class="token string">'vue-lazyload'</span>
<span class="token comment">// 使用</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">)</span>
<span class="token comment">// 自定义选项</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  preLoad<span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">,</span>
  error<span class="token operator">:</span> <span class="token string">'dist/error.png'</span><span class="token punctuation">,</span>
  loading<span class="token operator">:</span> <span class="token string">'dist/loading.gif'</span><span class="token punctuation">,</span>
  attempt<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>img v<span class="token operator">-</span>lazy<span class="token operator">=</span><span class="token string">&quot;/static/img/1.png&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="第三方插件按需引入"><a href="#第三方插件按需引入" class="header-anchor">#</a> 第三方插件按需引入</h2> <p>我们项目中通常用到第三方的插件，但是直接引入所有的组件库，会造成体积太大。我们可以通过 babel-plugin-component ，按需值引用需要的组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 安装</span>
npm install babel<span class="token operator">-</span>plugin<span class="token operator">-</span>component <span class="token operator">-</span><span class="token constant">D</span>
<span class="token comment">// .babelrc</span>
<span class="token punctuation">{</span>
 <span class="token string">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;es2015&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">&quot;modules&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
 <span class="token punctuation">[</span>
   <span class="token string">&quot;component&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token string">&quot;libraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;element-ui&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;styleLibraryName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;theme-chalk&quot;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token comment">// main.js 引入</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Button<span class="token punctuation">,</span> Select <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-ui'</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Select<span class="token punctuation">)</span>
</code></pre></div><h2 id="服务器端渲染"><a href="#服务器端渲染" class="header-anchor">#</a> 服务器端渲染</h2> <p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成。</p> <p>优点：</p> <p>有利于优化 SEO: SEO 的页面抓取是在 Ajax 之前，所以传统的页面是抓取不到 Ajax 的内容的。</p> <p>加快首屏渲染：传统的页面会等待所有 Vue 页面 JS 下载完成后，才进行页面渲染的，文件下载需要等待一定时间。 SSR 直接由服务器渲染好，直接显示页面。</p> <p>缺点：</p> <ul><li>在 Node.js 中渲染完整的应用程序，服务器负载严重，更加大量占用 CPU 资源。</li> <li>开发条件限制。服务端渲染应用程序，需要处于 Node.js server 运行环境。
<blockquote><p>注意：如果只想优化页面的 SEO，可以使用预渲染，只针对于特定路由的静态 HTML 文件。使用 prerender-spa-plugin 插件。</p></blockquote></li></ul> <h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h2> <p>vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</p> <p>vuex 的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？ 因为 vuex 生成了一个 store 实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个 store 实例。 store 实例上有数据，有方法，方法改变的都是 store 实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了 store 上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。</p> <p>Vuex 的核心是 store 仓库， store 存储着大部分的状态 ( state )，具有两个特点：</p> <ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>不能直接改变 store 的状态，而是通过提交 ( commit ) mutation。这样的好处就是方便我们跟踪每一个变化，而且可以记录每次调试的时候的状态改变。</li></ul> <h3 id="为什么使用-vuex"><a href="#为什么使用-vuex" class="header-anchor">#</a> 为什么使用 Vuex</h3> <ul><li>多个组件依赖于同一状态时。</li> <li>来自不同组件的行为需要变更同一状态</li></ul> <h3 id="不用-vuex-会带来什么问题"><a href="#不用-vuex-会带来什么问题" class="header-anchor">#</a> 不用 Vuex 会带来什么问题？</h3> <p>可维护性会下降，想修改数据要维护三个地方；</p> <p>可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的；</p> <p>增加耦合，大量的上传派发，会让耦合性大大增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。</p> <h3 id="四种状态"><a href="#四种状态" class="header-anchor">#</a> 四种状态</h3> <h4 id="state"><a href="#state" class="header-anchor">#</a> State</h4> <p>我们一般在 Vue 组件中使用 state ，通过以下方式：</p> <p><code>this.$store.state.count</code></p> <p>但是我们想要改变一个 store 的状态，使用 mutation 。</p> <p>当一个组件获取多个 state 状态的时，避免操作繁琐，使用 mapState ，而 mapState 函数返回的是一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 箭头函数可使代码更简练</span>
    <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span>
    countAlias<span class="token operator">:</span> <span class="token string">&quot;count&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>
    <span class="token function">countPlusLocalState</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="getter"><a href="#getter" class="header-anchor">#</a> Getter</h4> <p>有时我们需要对获取 state 中的状态数据进行过滤，尤其是多个组件用到该属性，传统的在组件中过滤会造成代码的冗余和重复，所以我们使用 store 的计算属性 getter 。当依赖发生时，才会改变重新计算的值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    todos<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">&quot;...&quot;</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">doneTodos</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>computed<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>doneTodosCount
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除此之外， getter 返回一个函数，用于传参</p> <div class="language-js extra-class"><pre class="language-js"><code>getters<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getTodoById</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> state<span class="token punctuation">.</span>todos<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">todo</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> todo<span class="token punctuation">.</span>id <span class="token operator">===</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span><span class="token function">getTodoById</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -&gt; { id: 2, text: '...', done: false }</span>
</code></pre></div><p>如果想将 Getter 映射到组件局部的计算属性，直接使用 mapGetter 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>
    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">&quot;doneTodosCount&quot;</span><span class="token punctuation">,</span>
      <span class="token string">&quot;anotherGetter&quot;</span><span class="token punctuation">,</span> <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="mutation"><a href="#mutation" class="header-anchor">#</a> Mutation</h4> <p>我们上述说到，通常使用 Mutation 来改变状态。最重要的一点就是 mutation 只能是<strong>同步任务</strong>，因为如果同步和异步都有，不知道哪个先完成。所以异步任务交给 Action</p> <div class="language-js extra-class"><pre class="language-js"><code>mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count <span class="token operator">+=</span> n
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>于此同时，我们也可以使用提交载荷（对象）的方式。</p> <div class="language-js extra-class"><pre class="language-js"><code>mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count <span class="token operator">+=</span> payload<span class="token punctuation">.</span>amount
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  amount<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在我们多人团队合作中，通常使用常量的方式进行开发，这样看起来便于管理和团队协作开发</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// mutation-types.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">SOME_MUTATION</span> <span class="token operator">=</span> <span class="token string">&quot;SOME_MUTATION&quot;</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// store.js</span>
<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">SOME_MUTATION</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mutation-types'</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
     state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
     mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>
     <span class="token punctuation">[</span><span class="token constant">SOME_MUTATION</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// mutate state</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以使用 mapMutation 辅助函数将组件中的 methods 映射为 store.commit</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vuex&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为`this.$store.commit('increment')` // `mapMutations` 也支持载荷：</span>
      <span class="token string">&quot;incrementBy&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为`this.$store.commit('incrementBy', amount)`</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      add<span class="token operator">:</span> <span class="token string">&quot;increment&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.add()` 映射为`this.$store.commit('increment')`</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="action"><a href="#action" class="header-anchor">#</a> Action</h4> <p>Action 主要用来处理项目中的<strong>异步任务</strong>，且 Action 提交的是 mutation ，而不是直接变更状态</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
state<span class="token operator">:</span> <span class="token punctuation">{</span>
  count<span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function">  increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   state<span class="token punctuation">.</span>count<span class="token operator">++</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
actions<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function">  increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 参数解构</span>
actions<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function"> increment</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">  commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用分发 Action</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token function"> incrementAsync</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">  setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token function">   commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 分发的两种形式</span>
<span class="token comment">// 以载荷形式分发</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'incrementAsync'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
 amount<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 以对象形式分发</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 type<span class="token operator">:</span> <span class="token string">'incrementAsync'</span><span class="token punctuation">,</span>
 amount<span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 组件中分发</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span>
</code></pre></div><p>在 action 函数中返回 Promise ，然后再提交时候用 then 处理</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span><span class="token punctuation">{</span>
  <span class="token constant">SET_NUMBER_A</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
<span class="token function">      setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
<span class="token function">        commit</span><span class="token punctuation">(</span><span class="token string">'SET_NUMBER'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">        resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'SET_NUMBER_A'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在异步任务中处理异步任务，使用 ES7 中的 async 和 await 。如下：在 actionB 要提交 actionA</p> <div class="language-js extra-class"><pre class="language-js"><code>actions<span class="token operator">:</span><span class="token punctuation">{</span>
 <span class="token keyword">async</span> <span class="token function">actionA</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>commit<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">//...</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token keyword">async</span> <span class="token function">actionB</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">await</span> <span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token string">'actionA'</span><span class="token punctuation">)</span><span class="token comment">//等待actionA完成</span>
   <span class="token comment">// ...</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="model"><a href="#model" class="header-anchor">#</a> Model</h4> <p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时， store 对象就有可能变得相当臃肿。所以使用模块（ Model ）将 store 分隔开单独的模块</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token function-variable function"> state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
 actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 modules<span class="token operator">:</span> <span class="token punctuation">{</span>
  a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>
  b<span class="token operator">:</span> moduleB
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>a <span class="token comment">// -&gt; moduleA 的状态</span>
store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>b <span class="token comment">// -&gt; moduleB 的状态</span>
</code></pre></div><h2 id="vue-cli-工程升级-vue-版本"><a href="#vue-cli-工程升级-vue-版本" class="header-anchor">#</a> vue-cli 工程升级 vue 版本</h2> <p>在项目目录里运行 <code>npm upgrade vue vue-template-compiler</code>，不出意外的话，可以正常运行和 build。如果有任何问题，删除 node_modules 文件夹然后重新运行 npm i 即可。（简单的说就是升级 vue 和 vue-template-compiler 两个插件）</p> <h2 id="构建的-vue-cli-工程都用到了哪些技术-它们的作用分别是什么"><a href="#构建的-vue-cli-工程都用到了哪些技术-它们的作用分别是什么" class="header-anchor">#</a> 构建的 vue-cli 工程都用到了哪些技术，它们的作用分别是什么？</h2> <p>1、vue.js：vue-cli 工程的核心，主要特点是 双向数据绑定 和 组件系统。</p> <p>2、vue-router：vue 官方推荐使用的路由框架。</p> <p>3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护 vue 组件间共用的一些 变量 和 方法。</p> <p>4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http 请求，基于 Promise 设计。</p> <p>5、vux 等：一个专为 vue 设计的移动端 UI 组件库。</p> <p>6、创建一个 emit.js 文件，用于 vue 事件机制的管理。</p> <p>7、webpack：模块加载和 vue-cli 工程打包器。</p> <h2 id="vue-cli-工程常用的-npm-命令有哪些"><a href="#vue-cli-工程常用的-npm-命令有哪些" class="header-anchor">#</a> vue-cli 工程常用的 npm 命令有哪些？</h2> <p>npm install、npm run dev、npm run build --report 等</p> <p>解析：</p> <p>下载 node_modules 资源包的命令：npm install</p> <p>启动 vue-cli 开发环境的 npm 命令：npm run dev</p> <p>vue-cli 生成 生产环境部署资源 的 npm 命令：npm run build</p> <p>用于查看 vue-cli 生产环境部署资源文件大小的 npm 命令：npm run build --report，此命令必答</p> <p>在浏览器上自动弹出一个 展示 vue-cli 工程打包后 app.js、manifest.js、vendor.js 文件里面所包含代码的页面。可以具此优化 vue-cli 生产环境部署的静态资源，提升 页面 的加载速度</p> <h2 id="请说出-vue-cli-工程中每个文件夹和文件的用处"><a href="#请说出-vue-cli-工程中每个文件夹和文件的用处" class="header-anchor">#</a> 请说出 vue-cli 工程中每个文件夹和文件的用处</h2> <p>vue-cli 目录解析：</p> <div class="language- extra-class"><pre class="language-text"><code>build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。
config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。
dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。
node_modules：存放npm命令下载的开发环境和生产环境的依赖包。
src: 存放项目源码及需要引用的资源文件。
src下assets：存放项目中需要用到的资源文件，css、js、images等。
src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。
src下emit：自己配置的vue集中式事件管理机制。
src下router：vue-router vue路由的配置文件。
src下service：自己配置的vue请求后台接口方法。
src下page：存在vue页面组件的文件夹。
src下util：存放vue开发过程中一些公共的.js方法。
src下vuex：存放 vuex 为vue专门开发的状态管理器。
src下app.vue：使用标签&lt;route-view&gt;&lt;/router-view&gt;渲染整个工程的.vue组件。
src下main.js：vue-cli工程的入口文件。
index.html：设置项目的一些meta头信息和提供&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;用于挂载 vue 节点。
package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。
</code></pre></div><h2 id="config-文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置"><a href="#config-文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置" class="header-anchor">#</a> config 文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</h2> <div class="language- extra-class"><pre class="language-text"><code>build 对象下 对于 生产环境 的配置：

index：配置打包后入口.html文件的名称以及文件夹名称
assetsRoot：配置打包后生成的文件名称和路径
assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 &quot;./&quot;
productionGzip：是否开发 gzip 压缩，以提升加载速度

dev 对象下 对于 开发环境 的配置：

port：设置端口号
autoOpenBrowser：启动工程时，自动打开浏览器
proxyTable：vue设置的代理，用以解决 跨域 问题
</code></pre></div><h2 id="请你详细介绍一些-package-json-里面的配置"><a href="#请你详细介绍一些-package-json-里面的配置" class="header-anchor">#</a> 请你详细介绍一些 package.json 里面的配置</h2> <div class="language- extra-class"><pre class="language-text"><code>scripts：npm run xxx 命令调用node执行的 .js 文件
dependencies：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面
devDependencies：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不会打包进 生产环境js文件 里面。

</code></pre></div><h2 id="vue-cli-中常用到的加载器"><a href="#vue-cli-中常用到的加载器" class="header-anchor">#</a> vue-cli 中常用到的加载器</h2> <p>1.安装 sass:</p> <p>2.安装 axios:</p> <p>3.安装 mock:</p> <p>4.安装 lib-flexible: --实现移动端自适应</p> <p>5.安装 sass-resourses-loader</p> <h2 id="vue-cli-中怎样使用自定义的组件-有遇到过哪些问题吗"><a href="#vue-cli-中怎样使用自定义的组件-有遇到过哪些问题吗" class="header-anchor">#</a> vue-cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</h2> <p>第一步：在 components 目录新建你的组件文件（如：indexPage.vue），script 一定要 export default {}</p> <p>第二步：在需要用的页面（组件）中导入：import indexPage from '@/components/indexPage.vue'</p> <p>第三步：注入到 vue 的子组件的 components 属性上面,components:{indexPage}</p> <p>第四步：在 template 视图 view 中使用</p> <p>遇到的问题： 例如有 indexPage 命名，使用的时候则 index-page</p> <h2 id="vue-事件中如何使用-event-对象"><a href="#vue-事件中如何使用-event-对象" class="header-anchor">#</a> vue 事件中如何使用 event 对象？</h2> <p>v-on 指令（可以简写为 @）</p> <p>1、使用不带圆括号的形式，event 对象将被自动当做实参传入；</p> <p>2、使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p> <p>解析：</p> <p>一、event 对象</p> <p>（一）事件的 event 对象</p> <p>你说你是搞前端的，那么你肯定就知道事件，知道事件，你就肯定知道 event 对象吧？各种的库、框架多少都有针对 event 对象的处理。比如 jquery，通过它内部进行一定的封装，我们开发的时候，就无需关注 event 对象的部分兼容性问题。最典型的，如果我们要阻止默认事件，在 chrome 等浏览器中，我们可能要写一个：</p> <div class="language-js extra-class"><pre class="language-js"><code>event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而在 IE 中，我们则需要写：</p> <div class="language-js extra-class"><pre class="language-js"><code>event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><p>多亏了 jquery ，跨浏览器的实现，我们统一只需要写：</p> <div class="language-js extra-class"><pre class="language-js"><code>event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>兼容？jquery 内部帮我们搞定了。类似的还有比如阻止事件冒泡以以及事件绑定（addEventListener / attachEvent）等，简单到很多的后端都会使用 $('xxx').bind(...)，这不是我们今天的重点，我们往下看。</p> <p>（二）vue 中的 event 对象</p> <p>我们知道，相比于 jquery，vue 的事件绑定可以显得更加直观和便捷，我们只需要在模板上添加一个 v-on 指令（还可以简写为 @），即可完成类似于 $('xxx').bind 的效果，少了一个利用选择器查询元素的操作。我们知道，jquery 中，event 对象会被默认当做实参传入到处理函数中，如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里直接就获取到了 event 对象，那么问题来了，vue 中呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;click&quot;</span><span class="token operator">&gt;</span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">...</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// object</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的实现方式看起来和 jquery 是一致的啊，但是实际上，vue 比 jquery 要要复杂得多，jquery 官方也明确的说，v-on 不简单是 addEventListener 的语法糖。在 jquery 中，我们传入到 bind 方法中的回调，只能是一个函数表类型的变量或者一个匿名函数，传递的时候，还不能执行它（在后面加上一堆圆括号），否则就变成了取这一个函数的返回值作为事件回调。而我们知道，vue 的 v-on 指令接受的值可以是函数执行的形式，比如 v-on:click=&quot;click(233)&quot; 。这里我们可以传递任何需要传递的参数，甚至可以不传递参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;click()&quot;</span><span class="token operator">&gt;</span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">...</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// undefined</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>咦？我的 event 对象呢？怎么不见了？打印看看 arguments.length 也是 0，说明这时候确实没有实参被传入进来。T_T，那我们如果既需要传递参数，又需要用到 event 对象，这个该怎么办呢？</p> <p>（三）$event</p> <p>翻看 vue 文档，不难发现，其实我们可以通过将一个特殊变量 $event 传入到回调中解决这个问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;click($event, 233)&quot;</span><span class="token operator">&gt;</span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">...</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// object</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>好吧，这样看起来就正常了。
简单总结来说：</p> <p>使用不带圆括号的形式，event 对象将被自动当做实参传入；</p> <p>使用带圆括号的形式，我们需要使用 $event 变量显式传入 event 对象。</p> <p>二、乌龙
前面都算是铺垫吧，现在真正的乌龙来了。
翻看小伙伴儿的代码，偶然看到了类似下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;click(233)&quot;</span><span class="token operator">&gt;</span>click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">...</span>
<span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// object</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看到这一段代码，我的内心是崩溃的，丢进 chrome 里面一跑，尼玛还真可以，打印 arguments.length，也是正常的 1。尼玛！这是什么鬼？毁三观啊？
既没有传入实参，也没有接收的形参，这个 event 对象的来源，要么是上级作用链，要么。。。是全局作用域。。。全局的，不禁想到了 window.event
。再次上 MDN 确认了一下，果然，window.event，ie 和 chrome 都在 window 对象上有这样一个属性：</p> <p><img src="/assets/img/event.0b659e52.jpg" alt=""></p> <p>代码丢进 Firefox 中运行，event 果然就变成了 undefined 了。额，这个我也不知道说什么了。。。</p> <h2 id="vue-等单页面应用及其优缺点"><a href="#vue-等单页面应用及其优缺点" class="header-anchor">#</a> vue 等单页面应用及其优缺点</h2> <p>优点： 1、用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。 2、前后端职责业分离（前端负责 view，后端负责 model），架构清晰 3、减轻服务器的压力</p> <p>缺点： 1、SEO（搜索引擎优化）难度高 2、初次加载页面更耗时 3、前进、后退、地址栏等，需要程序进行管理，所以会大大提高页面的复杂性和逻辑的难度</p> <h2 id="vue-如何优化首页的加载速度"><a href="#vue-如何优化首页的加载速度" class="header-anchor">#</a> vue 如何优化首页的加载速度？</h2> <ul><li>路由懒加载</li> <li>ui框架按需加载</li> <li>gzip压缩</li></ul> <h2 id="vue-首页白屏是什么问题引起的"><a href="#vue-首页白屏是什么问题引起的" class="header-anchor">#</a> vue 首页白屏是什么问题引起的？</h2> <ul><li><p>第一种，打包后文件引用路径不对，导致找不到文件报错白屏
解决办法：修改一下config下面的index.js中bulid模块导出的路径。因为index.html里边的内容都是通过script标签引入的，而你的路径不对，打开肯定是空白的。先看一下默认的路径。</p></li> <li><p>第二种，由于把路由模式mode设置影响
解决方法：路由里边router/index.js路由配置里边默认模式是hash，如果你改成了history模式的话，打开也会是一片空白。所以改为hash或者直接把模式配置删除，让它默认的就行 。如果非要使用history模式的话，需要你在服务端加一个覆盖所有的情况的候选资源：如果URL匹配不到任何静态资源，则应该返回一个index.html，这个页面就是你app依赖页面。</p></li></ul> <p>所以只要删除mode或者把mode改成hash就OK了。</p> <ul><li>第三种，项目中使用了es6的语法，一些浏览器不支持es6，造成编译错误不能解析而造成白屏
解决方法：</li></ul> <p>安装 npm install --save-dev babel-preset-es2015</p> <p>安装 npm install --save-dev babel-preset-stage-3</p> <p>在项目根目录创建一个.babelrc文件 里面内容 最基本配置是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token comment">// 此项指明，转码的规则</span>
    <span class="token string">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// env项是借助插件babel-preset-env，下面这个配置说的是babel对es6,es7,es8进行转码，并且设置amd,commonjs这样的模块化文件，不进行转码</span>
        <span class="token punctuation">[</span><span class="token string">&quot;env&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
            <span class="token string">&quot;modules&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 下面这个是不同阶段出现的es语法，包含不同的转码插件</span>
        <span class="token string">&quot;stage-2&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 下面这个选项是引用插件来处理代码的转换，transform-runtime用来处理全局函数和优化babel编译</span>
    <span class="token string">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;transform-runtime&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 下面指的是在生成的文件中，不产生注释</span>
    <span class="token string">&quot;comments&quot;</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token comment">// 下面这段是在特定的环境中所执行的转码规则，当环境变量是下面的test就会覆盖上面的设置</span>
    <span class="token string">&quot;env&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// test 是提前设置的环境变量，如果没有设置BABEL_ENV则使用NODE_ENV，如果都没有设置默认就是development</span>
        <span class="token string">&quot;test&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token string">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;env&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;stage-2&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token comment">// instanbul是一个用来测试转码后代码的工具</span>
            <span class="token string">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;istanbul&quot;</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-中如何实现-proxy-代理"><a href="#vue-中如何实现-proxy-代理" class="header-anchor">#</a> Vue 中如何实现 proxy 代理？</h2> <p>webpack 自带的 devServer 中集成了 http-proxy-middleware。配置 devServer 的 proxy 选项即可</p> <div class="language-js extra-class"><pre class="language-js"><code>proxyTable<span class="token operator">:</span> <span class="token punctuation">{</span>
   <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    target<span class="token operator">:</span> <span class="token string">'http://192.168.149.90:8080/'</span><span class="token punctuation">,</span> <span class="token comment">// 设置你调用的接口域名和端口号</span>
    changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>   <span class="token comment">// 跨域</span>
    pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>
     <span class="token string">'^/api'</span><span class="token operator">:</span> <span class="token string">'/'</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="vue-如何实现按需加载配合-webpack-设置"><a href="#vue-如何实现按需加载配合-webpack-设置" class="header-anchor">#</a> vue 如何实现按需加载配合 webpack 设置</h2> <div class="language-js extra-class"><pre class="language-js"><code>webpack 中提供了 require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>来实现按需加载。以前引入路由是通过 <span class="token keyword">import</span> 这样的方式引入，改为 <span class="token keyword">const</span> 定义的方式进行引入。
不进行页面按需加载引入方式：<span class="token keyword">import</span> home <span class="token keyword">from</span> <span class="token string">'../../common/home.vue'</span>
进行页面按需加载的引入方式：<span class="token keyword">const</span> <span class="token function-variable function">home</span> <span class="token operator">=</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span> <span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../../common/home.vue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在音乐 app 中使用的路由懒加载方式为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Recommend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;components/recommend/recommend&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Singer</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;components/singer/singer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="如何让-css-只在当前组件中起作用"><a href="#如何让-css-只在当前组件中起作用" class="header-anchor">#</a> 如何让 CSS 只在当前组件中起作用</h2> <p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p> <h2 id="vue-loader-是什么-使用它的用途有哪些"><a href="#vue-loader-是什么-使用它的用途有哪些" class="header-anchor">#</a> vue-loader 是什么？使用它的用途有哪些？</h2> <p>vue-loader 是解析 .vue 文件的一个加载器，将 template/js/style 转换成 js 模块。</p> <p>用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等。</p> <h2 id="递归组件的使用"><a href="#递归组件的使用" class="header-anchor">#</a> 递归组件的使用</h2> <p>组件是可以在自己的模板中调用自身的，不过他们只能通过 name 选项来做这件事</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mian/base/ts.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        TypeScript
      </a></span> <span class="next"><a href="/mian/base/react.html">
        react
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7804a0b3.js" defer></script><script src="/assets/js/2.9d52316c.js" defer></script><script src="/assets/js/3.fc2fbd9e.js" defer></script>
  </body>
</html>