<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue 双向数据绑定原理 | 跌倒的小黄瓜</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="文档部分">
    
    <link rel="preload" href="/assets/css/0.styles.060cc481.css" as="style"><link rel="preload" href="/assets/js/app.109dec69.js" as="script"><link rel="preload" href="/assets/js/2.fe82f1de.js" as="script"><link rel="preload" href="/assets/js/55.af9373a4.js" as="script"><link rel="prefetch" href="/assets/js/10.c12c8ad8.js"><link rel="prefetch" href="/assets/js/11.d9b15f6c.js"><link rel="prefetch" href="/assets/js/12.3b6afc87.js"><link rel="prefetch" href="/assets/js/13.0a735cc9.js"><link rel="prefetch" href="/assets/js/14.f794b3ef.js"><link rel="prefetch" href="/assets/js/15.03b6c3a2.js"><link rel="prefetch" href="/assets/js/16.4c6b6faf.js"><link rel="prefetch" href="/assets/js/17.4c05e969.js"><link rel="prefetch" href="/assets/js/18.3f053382.js"><link rel="prefetch" href="/assets/js/19.68befba2.js"><link rel="prefetch" href="/assets/js/20.76690524.js"><link rel="prefetch" href="/assets/js/21.08b0d3a8.js"><link rel="prefetch" href="/assets/js/22.fb7b8d54.js"><link rel="prefetch" href="/assets/js/23.74088265.js"><link rel="prefetch" href="/assets/js/24.913dc1ad.js"><link rel="prefetch" href="/assets/js/25.ec49ad77.js"><link rel="prefetch" href="/assets/js/26.da7e0ea8.js"><link rel="prefetch" href="/assets/js/27.c852c837.js"><link rel="prefetch" href="/assets/js/28.c003f855.js"><link rel="prefetch" href="/assets/js/29.1567d60d.js"><link rel="prefetch" href="/assets/js/3.02602895.js"><link rel="prefetch" href="/assets/js/30.3e0b7360.js"><link rel="prefetch" href="/assets/js/31.1f63794a.js"><link rel="prefetch" href="/assets/js/32.226d48cc.js"><link rel="prefetch" href="/assets/js/33.86510584.js"><link rel="prefetch" href="/assets/js/34.0b6925f6.js"><link rel="prefetch" href="/assets/js/35.27d5ab49.js"><link rel="prefetch" href="/assets/js/36.7991aaaa.js"><link rel="prefetch" href="/assets/js/37.b1c75aaa.js"><link rel="prefetch" href="/assets/js/38.032686d3.js"><link rel="prefetch" href="/assets/js/39.71046e73.js"><link rel="prefetch" href="/assets/js/4.d8099d01.js"><link rel="prefetch" href="/assets/js/40.ddb0cd3f.js"><link rel="prefetch" href="/assets/js/41.5cde72e3.js"><link rel="prefetch" href="/assets/js/42.149738ae.js"><link rel="prefetch" href="/assets/js/43.caea195c.js"><link rel="prefetch" href="/assets/js/44.f99cc4d4.js"><link rel="prefetch" href="/assets/js/45.8193976f.js"><link rel="prefetch" href="/assets/js/46.1ef7882a.js"><link rel="prefetch" href="/assets/js/47.d9bdb1c0.js"><link rel="prefetch" href="/assets/js/48.d75de7a7.js"><link rel="prefetch" href="/assets/js/49.d6d173c1.js"><link rel="prefetch" href="/assets/js/5.d7ce0a9b.js"><link rel="prefetch" href="/assets/js/50.df8d8af6.js"><link rel="prefetch" href="/assets/js/51.01e2d401.js"><link rel="prefetch" href="/assets/js/52.7ef0f86e.js"><link rel="prefetch" href="/assets/js/53.1def2f2d.js"><link rel="prefetch" href="/assets/js/54.0d6c9caf.js"><link rel="prefetch" href="/assets/js/56.7bb855bd.js"><link rel="prefetch" href="/assets/js/57.5f870d5e.js"><link rel="prefetch" href="/assets/js/58.0fcaa988.js"><link rel="prefetch" href="/assets/js/59.36b95f83.js"><link rel="prefetch" href="/assets/js/6.cadeca81.js"><link rel="prefetch" href="/assets/js/60.10ffeab5.js"><link rel="prefetch" href="/assets/js/61.6da16abc.js"><link rel="prefetch" href="/assets/js/62.55d1e846.js"><link rel="prefetch" href="/assets/js/63.3eee06df.js"><link rel="prefetch" href="/assets/js/64.676241a6.js"><link rel="prefetch" href="/assets/js/65.1b3f992b.js"><link rel="prefetch" href="/assets/js/66.6c3d6c7b.js"><link rel="prefetch" href="/assets/js/67.5521ada4.js"><link rel="prefetch" href="/assets/js/68.77f20e1c.js"><link rel="prefetch" href="/assets/js/69.9245a671.js"><link rel="prefetch" href="/assets/js/7.6694095a.js"><link rel="prefetch" href="/assets/js/8.80131140.js"><link rel="prefetch" href="/assets/js/9.39451dc6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.060cc481.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">跌倒的小黄瓜</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/mian/" class="nav-link router-link-active">
  面试
</a></div><div class="nav-item"><a href="/Demo/" class="nav-link">
  Demo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/1793523411" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://mymaster.ygjie.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  master
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/mian/" class="nav-link router-link-active">
  面试
</a></div><div class="nav-item"><a href="/Demo/" class="nav-link">
  Demo
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/1793523411" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="http://mymaster.ygjie.icu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  master
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端</span> <!----></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试知识点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mian/base/browser.html" class="sidebar-link">浏览器</a></li><li><a href="/mian/base/html2.html" class="sidebar-link">HTML</a></li><li><a href="/mian/base/css.html" class="sidebar-link">CSS</a></li><li><a href="/mian/base/js.html" class="sidebar-link">Javascript</a></li><li><a href="/mian/base/vue.html" aria-current="page" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-双向数据绑定原理" class="sidebar-link">vue 双向数据绑定原理</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#object-defineproperty-函数" class="sidebar-link">Object.defineProperty 函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#使用-object-defineproperty-来进行数据劫持有什么缺点" class="sidebar-link">使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#什么是-virtual-dom么-为什么-virtual-dom-生-比原生-dom-快" class="sidebar-link">什么是 Virtual DOM么 ？为什么 Virtual DOM 生 比原生 DOM 快</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#如何比较两个-dom-树的差异" class="sidebar-link">如何比较两个 DOM 树的差异？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的生命周期是什么" class="sidebar-link">Vue 的生命周期是什么</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-的各个生命阶段是什么" class="sidebar-link">Vue 的各个生命阶段是什么？</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-组件间的参数传递方式" class="sidebar-link">Vue 组件间的参数传递方式</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#computed-和-和-watch-的差异" class="sidebar-link">computed 和 和 watch 的差异</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-router-中的导航钩子函数" class="sidebar-link">vue-router 中的导航钩子函数</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#route-和-和-router-的区别" class="sidebar-link">$route 和 和 $router 的区别</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-常用的修饰符" class="sidebar-link">vue 常用的修饰符</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-key-值的作用" class="sidebar-link">vue 中 key 值的作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#keep-alive-组件有什么作用" class="sidebar-link">keep-alive 组件有什么作用</a></li><li class="sidebar-sub-header"><a href="/mian/base/vue.html#vue-中-mixin-和-mixins-区别" class="sidebar-link">vue 中 mixin 和 mixins 区别？</a></li></ul></li><li><a href="/mian/base/project.html" class="sidebar-link">工程化</a></li><li><a href="/mian/base/network.html" class="sidebar-link">计算机网络</a></li><li><a href="/mian/base/design.html" class="sidebar-link">设计模式</a></li><li><a href="/mian/base/safe.html" class="sidebar-link">安全</a></li><li><a href="/mian/base/better.html" class="sidebar-link">性能优化</a></li><li><a href="/mian/base/tools.html" class="sidebar-link">工具</a></li><li><a href="/mian/base/datastruct.html" class="sidebar-link">数据结构</a></li><li><a href="/mian/base/jstimu.html" class="sidebar-link">js相关题目</a></li><li><a href="/mian/base/suanfa.html" class="sidebar-link">算法</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="vue-双向数据绑定原理"><a href="#vue-双向数据绑定原理" class="header-anchor">#</a> vue 双向数据绑定原理</h2> <p>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现的。</p> <p>首先我<strong>们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持</strong>，因此当 Model 中的数据发生变化的时候，我们可以通过配置的setter 和 getter 方法来实现对 View 层数据更新的通知。</p> <p>数据在 html 模板中一共有<strong>两种绑定情况</strong>，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</p> <p>如果遇到<strong>元素节点</strong>，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</p> <p>如果遇到了绑定的<strong>文本节点</strong>，我们使用 Model 中对应的属性的值来替换这个文本。</p> <p><strong>对于文本节点的更新，我们使用了发布订阅者模式</strong>，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</p> <h2 id="object-defineproperty-函数"><a href="#object-defineproperty-函数" class="header-anchor">#</a> Object.defineProperty 函数</h2> <p>Object.defineProperty 函数一共有三个参数，第一个参数是<strong>需要定义属性的对象</strong>，第二个参数是<strong>需要定义的属性</strong>，第三个是<strong>该属性描述符</strong>。一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</p> <h2 id="使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2> <p><strong>有一些对属性的操作，使用这种方法无法拦截</strong>，比如说<strong>通过下标方式修改数组数据</strong>或者<strong>给对象新增属性</strong>，<strong>vue 内部通过重写函数解决了这个问</strong>题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 <strong>Proxy 的好处是它可以完美的监听到任何方式的数据改变</strong>，唯一的缺点是<strong>兼容性的问题</strong>，因为这是 ES6 的语法。</p> <h2 id="什么是-virtual-dom么-为什么-virtual-dom-生-比原生-dom-快"><a href="#什么是-virtual-dom么-为什么-virtual-dom-生-比原生-dom-快" class="header-anchor">#</a> 什么是 Virtual DOM么 ？为什么 Virtual DOM 生 比原生 DOM 快</h2> <p>我对 Virtual DOM 的理解是:首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 <strong>js 对象树</strong>给保存下来，最后再将 DOM 片段插入到文档中。</p> <p>当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p> <p>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，<strong>通过在操作前确定需要做的最小修改</strong>，<strong>尽可能的减少 DOM 操作带来的重流和重绘的影响</strong>。其实 <strong>Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作</strong>。</p> <h2 id="如何比较两个-dom-树的差异"><a href="#如何比较两个-dom-树的差异" class="header-anchor">#</a> 如何比较两个 DOM 树的差异？</h2> <p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是<strong>在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为O(n)</strong>。</p> <p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p> <p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，<strong>列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点</strong>。</p> <h2 id="vue-的生命周期是什么"><a href="#vue-的生命周期是什么" class="header-anchor">#</a> Vue 的生命周期是什么</h2> <p>Vue 的生命周期指的是<strong>组件从创建到销毁的一系列的过程</strong>，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作</p> <h2 id="vue-的各个生命阶段是什么"><a href="#vue-的各个生命阶段是什么" class="header-anchor">#</a> Vue 的各个生命阶段是什么？</h2> <p>Vue 一共有 <strong>8</strong> 个生命阶段，分别是<strong>创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后</strong>，每个阶段对应了一个生命周期的钩子函数。</p> <p>（1）beforeCreate 钩子函数，在<strong>实例初始化之后</strong>，在<strong>数据监听和事件配置之前触发</strong>。因此在这个事件中我们是<strong>获取不到 data 数据</strong>的。</p> <p>（2）created 钩子函数，在<strong>实例创建完成后触发</strong>，此时可以访问 data、methods 等属性。但这个时候<strong>组件还没有被挂载到页面中去</strong>，所以这个时候访问<strong>不到 $el 属性</strong>。一般我们可以在这个函数中<strong>进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化</strong>。</p> <p>（3）beforeMount 钩子函数，在<strong>组件被挂载到页面之前触发</strong>。<strong>在 beforeMount 之前，会找到对应的 template，并编译成 render 函数</strong>。</p> <p>（4）mounted 钩子函数，在<strong>组件挂载到页面之后触发</strong>。此时<strong>可以通过 DOM API 获取到页面中的 DOM 元素</strong>。</p> <p>（5）beforeUpdate 钩子函数，在<strong>响应式数据更新时触发****，发生在虚拟 DOM 重新渲染和打补丁之前</strong>，这个时候我们可以<strong>对可能会被移除的元素做一些操作</strong>，比如移除事件监听器。</p> <p>（6）updated 钩子函数，<strong>虚拟 DOM 重新渲染和打补丁之后调用</strong>。</p> <p>（7）beforeDestroy 钩子函数，在<strong>实例销毁之前调用</strong>。一般在这一步我们<strong>可以销毁定时器、解绑全局事件</strong>等。</p> <p>（8）destroyed 钩子函数，在<strong>实例销毁之后调用</strong>，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <p>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。<strong>用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated钩子函数，命中缓存渲染后会执行 actived 钩子函数</strong>。</p> <h2 id="vue-组件间的参数传递方式"><a href="#vue-组件间的参数传递方式" class="header-anchor">#</a> Vue 组件间的参数传递方式</h2> <p>（1）父子组件间通信</p> <p>第一种方法是子组件通过 <strong>props 属性</strong>来接受父组件的数据，然后<strong>父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据</strong>。</p> <p>第二种是通过 <strong>ref 属性</strong>给子组件设置一个名字。<strong>父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件</strong>，这样也可以实现通信。</p> <p>第三种是使用 <strong>provider/injec</strong>t，在<strong>父组件中通过 provider 提供变量，在子组件中通过inject 来将变量注入到组件中</strong>。<strong>不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</strong></p> <p>（2）兄弟组件间通信</p> <p>第一种是使用 <strong>eventBus</strong> 的方法，它的本<strong>质是通过创建一个空的 Vue 实例来作为消息传递的对象</strong>，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p> <p>第二种是通过 <strong><code>$parent.$refs</code></strong> 来获取到兄弟组件，也可以进行通信。</p> <p>（3）任意组件之间</p> <p>使用 <strong>eventBus</strong> ，其实就是创建一个<strong>事件中心，相当于中转站</strong>，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 <strong>vuex</strong> ，<strong>vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的</strong>。</p> <h2 id="computed-和-和-watch-的差异"><a href="#computed-和-和-watch-的差异" class="header-anchor">#</a> computed 和 和 watch 的差异</h2> <p>（1）computed 是<strong>计算一个新的属性，并将该属性挂载到 Vue 实例上</strong>，而 watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数</strong>据，所以<strong>用 watch 同样可以监听 computed 计算属性的变化</strong>。</p> <p>（2）computed 本质是一个<strong>惰性求值的观察者</strong>，具有<strong>缓存性</strong>，只有当依赖变化后，第一次访问computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。</p> <p>（3）从使用场景上说，<strong>computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据</strong></p> <p>computed 是计算属性，<strong>依赖其他属性计算值，并且 computed 的值有缓存</strong>，只有当计算值变化才会返回内容。</p> <p>watch <strong>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作</strong>。</p> <h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="header-anchor">#</a> vue-router 中的导航钩子函数</h2> <p>（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，<strong>to 代表要进入的路由对象，from 代表离开的路由对象</strong>。<strong>next 是一个必须要执行的函数</strong>，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p> <p>（2）<strong>单个路由独享的钩子函数 beforeEnter</strong>，它是在路由配置上直接进行定义的。</p> <p>（3）<strong>组件内的导航钩子</strong>主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</p> <h2 id="route-和-和-router-的区别"><a href="#route-和-和-router-的区别" class="header-anchor">#</a> <code>$route</code> 和 和 <code>$router</code> 的区别</h2> <p><strong><code>$route</code> 是“路由信息对象”</strong>，包括 path，params，hash，query，fullPath，matched，name等路由信息参数。而 <strong><code>$router</code> 是“路由实例”对象</strong>包括了路由的跳转方法，钩子函数等。</p> <h2 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="header-anchor">#</a> vue 常用的修饰符</h2> <p><code>.prevent</code>: 提交事件<strong>不再重载页面</strong>；<code>.stop</code>: <strong>阻止单击事件冒泡</strong>；<code>.self</code>: 当事件发生在该元素本身而不是子元素的时候会触发；</p> <h2 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="header-anchor">#</a> vue 中 key 值的作用</h2> <p>vue 中 key 值的作用可以分为两种情况来考虑。</p> <p>第一种情况是 <strong>v-if 中使用 key</strong>。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，<strong>如果切换前后含有相同类型的元素，那么这个元素就会被复用</strong>。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 <strong>key 的作用是用来标识一个独立的元素</strong>。</p> <p>第二种情况是 <strong>v-for 中使用 key</strong>。<strong>用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略</strong>。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来<strong>以便 Vue 跟踪元素的身份</strong>，从而高效的实现复用。<strong>这个时候 key 的作用是为了高效的更新渲染虚拟 DOM</strong>。</p> <h2 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="header-anchor">#</a> keep-alive 组件有什么作用</h2> <p>如果你需要在组件切换的时候，<strong>保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件</p> <h2 id="vue-中-mixin-和-mixins-区别"><a href="#vue-中-mixin-和-mixins-区别" class="header-anchor">#</a> vue 中 mixin 和 mixins 区别？</h2> <p>mixin 用于<strong>全局混入</strong>，会影响到每个组件实例。</p> <p>mixins 应该是我们<strong>最常使用的扩展组件的方式</strong>了。<strong>如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码</strong>，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 <strong>mixins 混入的钩子函数会先于组件内的钩子函数执行</strong>，并且在<strong>遇到同名选项的时候也会有选择性的进行合并</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mian/base/js.html" class="prev">
        Javascript
      </a></span> <span class="next"><a href="/mian/base/project.html">
        工程化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.109dec69.js" defer></script><script src="/assets/js/2.fe82f1de.js" defer></script><script src="/assets/js/55.af9373a4.js" defer></script>
  </body>
</html>
