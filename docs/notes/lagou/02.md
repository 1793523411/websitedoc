# 前端核心基础知识(中)

## 浏览器如何渲染页面

假如我们在浏览器中输入了一个网址，得到了下面的 html 文件，渲染引擎是怎样通过解析代码生成页面的呢？

### 从 HTML 到 DOM

#### 字节流解码

对于上面的代码，我们看到的是它的字符形式。而浏览器通过 HTTP 协议接收到的文档内容是字节数据，当浏览器得到字节数据后，通过“编码嗅探算法”来确定字符编码，然后根据字符编码将字节流数据进行解码，生成我们编写的代码。

这个把字节数据解码成字符数据的过程称之为“字节流解码”。我们通过浏览器调试工具查看网络请求时，也是经过了这个操作过程，才能直观地看到字符串。

#### 输入流预处理

通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将换行符转换成统一的格式，最终生成规范化的字符流数据，这个把字符数据进行统一格式化的过程称之为“输入流预处理”。

#### 令牌化

经过前两步的数据解码和预处理，下面就要进入重要的解析步骤了。

解析包含两步，第一步是将字符数据转化成令牌（Token），第二步是解析 HTML 生成 DOM 树。先来说说令牌化，其过程是使用了一种类似状态机的算法，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到“body”字符串时，在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点。

这个算法的解析规则较多，在此就不一一列举了

最终生成类似下面的令牌结构：

```
开始标签:html
  开始标签:head
  结束标签:head
  开始标签:body
    字符串:lagou
  结束标签:body
结束标签:html
```

#### 遇到 script 标签时的处理

如果在 HTML 解析过程中遇到 script 标签，则会发生一些变化。

如果遇到的是内联代码，也就是在 script 标签中直接写代码，那么解析过程会暂停，执行权限会转给 JavaScript 脚本引擎，待 JavaScript 脚本执行完成之后再交由渲染引擎继续解析。有一种情况例外，那就是脚本内容中调用了改变 DOM 结构的 document.write() 函数，此时渲染引擎会回到第二步，将这些代码加入字符流，重新进行解析。

如果遇到的是外链脚本，那么渲染引擎会按照上一篇文章中所述的，根据标签属性来执行对应的操作。

#### 构建 DOM 树

解析 HTML 的第二步是树构建。

浏览器在创建解析器的同时会创建一个 Document 对象。在树构建阶段，Document 会作为根节点被不断地修改和扩充。标记步骤产生的令牌会被送到树构建器进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。

为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个开放元素栈中。

树构建算法也可以采用状态机的方式来描述

最终生成下面的 DOM 树结构：

```
              Document
             /        \
DocumentType           HTMLHtmlElement
                      /               \
       HTMLHeadElement                 HTMLBodyElement
                                              |
                                          TextNode
```

![](https://s0.lgstatic.com/i/image/M00/12/EE/CgqCHl7OM-CAQGiGAAFv6uHi6MI573.png)

#### 从 CSS 到 CSSOM

渲染引擎除了解析 HTML 之外，也需要解析 CSS。

CSS 解析的过程与 HTML 解析过程步骤一致，最终也会生成树状结构。

与 DOM 树不同的是，CSSOM 树的节点具有继承特性，也就是会先继承父节点样式作为当前样式，然后再进行补充或覆盖。下面举例说明。

```css
body {
  font-size: 12px;
}

p {
  font-weight: light;
}

span {
  color: blue;
}

p span {
  display: none;
}

img {
  float: left;
}
```

对于上面的代码，会解析生成类似下面结构的 DOM 树：

![](https://s0.lgstatic.com/i/image/M00/12/E2/Ciqc1F7OM-mAO8T2AAGu2Fxum4w061.png)

需要注意的是，上图中的 CSSOM 树并不完整，完整的 CSSOM 树还应当包括浏览器提供的默认样式（也称为“User Agent 样式”）。

### 从 DOM 到渲染

有了 DOM 树和 CSSOM 树之后，渲染引擎就可以开始生成页面了。

#### 构建渲染树

DOM 树包含的结构内容与 CSSOM 树包含的样式规则都是独立的，为了更方便渲染，先需要将它们合并成一棵渲染树。

这个过程会从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。

遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。

对于上面的 HTML 和 CSS 代码，最终生成的渲染树就只有一个 body 节点，样式为 font-size:12px。

#### 布局

生成了渲染树之后，就可以进入布局阶段了，布局就是计算元素的大小及位置。

计算元素布局是一个比较复杂的操作，因为需要考虑的因素有很多，包括字体大小、换行位置等，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。

布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。

#### 绘制

绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。得到布局树这份“施工图”之后，渲染引擎并不能立即绘制，因为还不知道绘制顺序，如果没有弄清楚绘制顺序，那么很可能会导致页面被错误地渲染。

例如，对于使用 z-index 属性的元素（如遮罩层）如果未按照正确的顺序绘制，则将导致渲染结果和预期不符（失去遮罩作用）。

所以绘制过程中的第一步就是遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。

对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。

::: tip
渲染引擎需要遍历 DOM 树节点并从 CSSOM 树中找到匹配的样式规则，在匹配过程中是通过自上而下还是自下而上的方式?

浏览器进行 CSS 选择器匹配时，是从右向左进行的，所以可以推知是自下而上,如果自上而下，会引起重复渲染
:::

浏览器渲染引擎生成页面的 7 个步骤，前面 4 个步骤为 DOM 树的生成过程，后面 3 个步骤是利用 DOM 树和 CSSOM 树来渲染页面的过程,以数据变化为线索，具体来说数据的变化过程为：

字节 → 字符 → 令牌 → 树 → 页面

## 关于 JavaScript 的数据类型，你知多少？

JavaScript 的数据类型可以分为 7 种：空（Null）、未定义（Undefined）、数字（Number）、字符串（String）、布尔值（Boolean）、符号（Symbol）、对象（Object）。

其中前 6 种类型为基础类型，最后 1 种为引用类型。这两者的区别在于，基础类型的数据在被引用或拷贝时，是值传递，也就是说会创建一个完全相等的变量；而引用类型只是创建一个指针指向原有的变量，实际上两个变量是“共享”这个数据的，并没有重新创建一个新的数据。

### Undefined

Undefined 是一个很特殊的数据类型，它只有一个值，也就是 undefined。可以通过下面几种方式来得到 undefined：

- 引用已声明但未初始化的变量；
- 引用未定义的对象属性；
- 执行无返回值函数；
- 执行 void 表达式；
- 全局常量 window.undefined 或 undefined。

对应代码如下：

```js
var a; // undefined
var o = {};
o.b(
  // undefined
  () => {}
)(); // undefined
void 0; // undefined
window.undefined; // undefined
```

其中比较推荐通过 void 表达式来得到 undefined 值，因为这种方式既简便（window.undefined 或 undefined 常量的字符长度都大于 "void 0" 表达式）又不需要引用额外的变量和属性；同时它作为表达式还可以配合三目运算符使用，代表不执行任何操作。

如下面的代码就表示满足条件 x 大于 0 且小于 5 的时候执行函数 fn，否则不进行任何操作：

```js
x > 0 && x < 5 ? fn() : void 0;
```

判断一个变量的值是否为 undefined :

方式 1 直接通过逻辑取非操作来将变量 x 强制转换为布尔值进行判断；方式 2 通过 3 个等号将变量 x 与 undefined 做真值比较；方式 3 通过 typeof 关键字获取变量 x 的类型，然后与 'undefined' 字符串做真值比较

```js
// 方式1
if(!x) {
  ...
}
// 方式2
if(x===undefined) {
  ...
}
// 方式2
if(typeof x === 'undefined') {
  ...
}
```

方式 1 不可行，因为只要变量 x 的值为 undefined、空字符串、数值 0、null 时都会判断为真。方式 2 也存在一些问题，虽然通过 “===” 和 undefined 值做比较是可行的，但如果 x 未定义则会抛出错误 “ReferenceError: x is not defined” 导致程序执行终止，这对于代码的健壮性显然是不利的。方式 3 则解决了这一问题

### Null

Null 数据类型和 Undefined 类似，只有唯一的一个值 null，都可以表示空值，甚至我们通过 “==” 来比较它们是否相等的时候得到的结果都是 true，但 null 是 JavaScript 保留关键字，而 undefined 只是一个常量。

也就是说我们可以声明名称为 undefined 的变量（虽然只能在老版本的 IE 浏览器中给它重新赋值），但将 null 作为变量使用时则会报错。

### Boolean

Boolean 数据类型只有两个值：true 和 false，分别代表真和假，理解和使用起来并不复杂。但是我们常常会将各种表达式和变量转换成 Boolean 数据类型来当作判断条件，这时候就要注意了。

下面是一个简单地将星期数转换成中文的函数，比如输入数字 1，函数就会返回“星期一”，输入数字 2 会返回“星期二”，以此类推，如果未输入数字则返回 undefined。

```js
function getWeek(week) {
  const dict = ["日", "一", "二", "三", "四", "五", "六"];

  if (week) return `星期${dict[week]}`;
}
```

这里在 if 语句中就进行了类型转换，将 week 变量转换成 Boolean 数据类型，而 0、空字符串、null、undefined 在转换时都会返回 false。所以这段代码在输入 0 的时候不会返回“星期日”，而返回 undefined。

### Number

Number 是数值类型，有 2 个特殊数值得注意一下，即 NaN 和 Infinity。

- NaN（Not a Number）通常在计算失败的时候会得到该值。要判断一个变量是否为 NaN，则可以通过 Number.isNaN 函数进行判断。
- Infinity 是无穷大，加上负号 “-” 会变成无穷小，在某些场景下比较有用，比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。

#### 进制转换

当我们需要将其他进制的整数转换成十进制显示的时候可以使用 parseInt 函数，该函数第一个参数为数值或字符串，第二个参数为进制数，默认为 10，当进制数转换失败时会返回 NaN。所以，如果在数组的 map 函数的回调函数中直接调用 parseInt，那么会将数组元素和索引值都作为参数传入。

```js
["0", "1", "2"].map(parseInt); // [0, NaN, NaN]
```

而将十进制转换成其他进制时，可以通过 toString 函数来实现。

```js
(10).toString(2); // "1010"
```

#### 精度问题

我们执行简单的运算 0.1 + 0.2，得到的结果是 0.30000000000000004，如果直接和 0.3 作相等判断时就会得到 false。

出现这种情况的原因在于计算的时候，JavaScript 引擎会先将十进制数转换为二进制，然后进行加法运算，再将所得结果转换为十进制。在进制转换过程中如果小数位是无限的，就会出现误差。同样的，对于下面的表达式，将数字 5 开方后再平方得到的结果也和数字 5 不相等。

```js
Math.pow(Math.pow(5, 1 / 2), 2); // 5.000000000000001
```

对于这个问题的解决方法也很简单，那就是消除无限小数位:

- 一种方式是先转换成整数进行计算，然后再转换回小数，这种方式适合在小数位不是很多的时候。比如一些程序的支付功能 API 以“分”为单位，从而避免使用小数进行计算。
- 还有另一种方法就是舍弃末尾的小数位。比如对上面的加法就可以先调用 toPrecision 截取 12 位，然后调用 parseFloat 函数转换回浮点数。

```js
parseFloat((0.1 + 0.2).toPrecision(12)); // 0.3
```

### String

千位分隔符是指为了方便识别较大数字，每隔三位数会加入 1 个逗号，该逗号就是千位分隔符。如果要编写一个函数来为输入值的数字添加千分位分隔符，该怎么实现呢？

一种很容易想到的方法就是从右往左遍历数值每一位，每隔 3 位添加分隔符。为了操作方便，我们可以将数值转换成字符数组，而要实现从右往左遍历，一种实现方式是通过 for 循环的索引值找到对应的字符；而另一种方式是通过数组反转，从而变成从左到右操作。

```js
function sep(n) {
  let [i, c] = n.toString().split(/(\.\d+)/);

  return (
    i
      .split("")
      .reverse()
      .map((c, idx) => ((idx + 1) % 3 === 0 ? "," + c : c))
      .reverse()
      .join("")
      .replace(/^,/, "") + c
  );
}
```

这种方式就是将字符串数据转化成引用类型数据，即用数组来实现。

第二种方式则是通过引用类型，即用正则表达式对字符进行替换来实现。

```js
function sep2(n) {
  let str = n.toString();

  str.indexOf(".") < 0 ? (str += ".") : void 0;

  return str.replace(/(\d)(?=(\d{3})+\.)/g, "$1,").replace(/\.$/, "");
}
```

### Symbol

Symbol 是 ES6 中引入的新数据类型，它表示一个唯一的常量，通过 Symbol 函数来创建对应的数据类型，创建时可以添加变量描述，该变量描述在传入时会被强行转换成字符串进行存储。

```js
var a = Symbol("1");
var b = Symbol(1);
a.description === b.description; // true
var c = Symbol({ id: 1 });
c.description; // [object Object]
var _a = Symbol("1");
_a == a; // false
```

基于上面的特性，Symbol 属性类型比较适合用于两类场景中：常量值和对象属性。

#### 避免常量值重复

假设有个 getValue 函数，根据传入的字符串参数 key 执行对应代码逻辑。代码如下所示：

```js
function getValue(key) {
  switch(key){
    case 'A':
      ...
    ...
    case 'B':
      ...
  }
}
getValue('B');
```

这段代码对调用者而言非常不友好，因为代码中使用了魔术字符串（魔术字符串是指在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值），导致调用 getValue 函数时需要查看函数源码才能找到参数 key 的可选值。所以可以将参数 key 的值以常量的方式声明出来

```js
const KEY = {
  alibaba: 'A',
  baidu: 'B',
  ...
}

function getValue(key) {
  switch(key){
    case KEY.alibaba:
      ...
    ...
    case KEY.baidu:
      ...
  }
}
getValue(KEY.baidu);

```

但这样也并非完美，假设现在我们要在 KEY 常量中加入一个 key，根据对应的规则，很有可能会出现值重复的情况：

```js
const KEY = {
  alibaba: 'A',
  baidu: 'B',
  ...
  bytedance: 'B'
}
getValue(KEY.baidu) // 等同于 getValue(KEY.bytedance)
```

所以在这种场景下更适合使用 Symbol，我们不关心值本身，只关心值的唯一性。

```js
const KEY = {
  alibaba: Symbol(),
  baidu: Symbol(),
  ...
  bytedance: Symbol()
}
```

#### 避免对象属性覆盖

假设有这样一个函数 fn，需要对传入的对象参数添加一个临时属性 user，但可能该对象参数中已经有这个属性了，如果直接赋值就会覆盖之前的值。此时就可以使用 Symbol 来避免这个问题。

创建一个 Symbol 数据类型的变量，然后将该变量作为对象参数的属性进行赋值和读取，这样就能避免覆盖的情况，示例代码如下：

```js
function fn(o) { // {user: {id: xx, name: yy}}
  const s = Symbol()
  o[s] = 'zzz'
  ...
}
```

### 类型转换

JavaScript 这种弱类型的语言，相对于其他高级语言有一个特点，那就是在处理不同数据类型运算或逻辑操作时会强制转换成同一数据类型。如果我们不理解这个特点，就很容易在编写代码时产生 bug。

通常强制转换的目标数据类型为 String、Number、Boolean 这三种。下面的表格中显示了 6 种基础数据类型转换关系

![](https://s0.lgstatic.com/i/image/M00/17/C1/CgqCHl7XaNOAOR-5AAC7iyHcEyQ034.png)

除了不同类型的转换之外，操作同种数据类型也会发生转换。把基本类型的数据换成对应的对象过程称之为“装箱转换”，反过来，把数据对象转换为基本类型的过程称之为“拆箱转换”。

对于装箱和拆箱转换操作，我们既可以显示地手动实现，比如将 Number 数据类型转换成 Number 对象；也可以通过一些操作触发浏览器显式地自动转换，比如将对 Number 对象进行加法运算。

```js
var n = 1;
var o = new Number(n); // 显式装箱
o.valueOf(); // 显式拆箱
n.toPrecision(3); // 隐式装箱, 实际操作：var tmp = new Number(n);tmp.toPrecision(3);tmp = null;
o + 2; // 隐式拆箱，实际操作:var tmp = o.valueOf();tmp + 2;tmp = null;
```

**什么时候会触发类型转换？**

下面这些常见的操作会触发隐式地类型转换，我们在编写代码的时候一定要注意。

- 运算相关的操作符包括 +、-、+=、++、\* 、/、%、<<、& 等。
- 数据比较相关的操作符包括 >、<、== 、<=、>=、===。
- 逻辑判断相关的操作符包括 &&、!、||、三目运算符。

### Object

相对于基础类型，引用类型 Object 则复杂很多。简单地说，Object 类型数据就是键值对的集合，键是一个字符串（或者 Symbol） ，值可以是任意类型的值； 复杂地说，Object 又包括很多子类型，比如 Date、Array、Set、RegExp。

对于 Object 类型，我们重点理解一种常见的操作，即深拷贝。

- 由于引用类型在赋值时只传递指针，这种拷贝方式称为浅拷贝。
- 而创建一个新的与之相同的引用类型数据的过程称之为深拷贝。

为了准确判断每种数据类型，我们可以先通过 typeof 来查看每种数据类型的描述：

```js
[undefined, null, true, "", 0, Symbol(), {}].map((it) => typeof it);
// ["undefined", "object", "boolean", "string", "number", "symbol", "object"]
```

发现 null 有些特殊，返回结果和 Object 类型一样都为"object"，所以需要再次进行判断。按照上面分析的结论，我们可以写出下面的函数：

```js
function clone(data) {
  let result = {};

  const keys = [
    ...Object.getOwnPropertyNames(data),
    ...Object.getOwnPropertySymbols(data),
  ];

  if (!keys.length) return data;

  keys.forEach((key) => {
    let item = data[key];

    if (typeof item === "object" && item) {
      result[key] = clone(item);
    } else {
      result[key] = item;
    }
  });

  return result;
}
```

在遍历 Object 类型数据时，我们需要把 Symbol 数据类型也考虑进来，所以不能通过 Object.keys 获取键名或 for...in 方式遍历，而是通过 getOwnPropertyNames 和 getOwnPropertySymbols 函数将键名组合成数组，然后进行遍历。对于键数组长度为 0 的非 Object 类型的数据可直接返回，然后再遍历递归，最终实现拷贝。

我们在编写递归函数的时候需要特别注意的是，递归调用的终止条件，避免无限递归。那在这个 clone 函数中有没有可能出现无限递归调用呢？

答案是有的。那就是当对象数据嵌套的时候，比如像下面这种情况，对象 a 的键 b 指向对象 b，对象 b 的键 a 指向对象 a，那么执行 clone 函数就会出现死循环，从而耗尽内存。

```js
var a = {};
var b = {};
a.b = b;
b.a = a;
```

怎么避免这种情况呢？一种简单的方式就是把已添加的对象记录下来，这样下次碰到相同的对象引用时，直接指向记录中的对象即可。要实现这个记录功能，我们可以借助 ES6 推出的 WeakMap 对象，该对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。

我们对 clone 函数改造一下，添加一个 WeakMap 来记录已经拷贝过的对象，如果当前对象已经被拷贝过，那么直接从 WeakMap 中取出，否则重新创建一个对象并加入 WeakMap 中。具体代码如下：

```js
function clone(obj) {
  let map = new WeakMap();

  function deep(data) {
    let result = {};

    const keys = [
      ...Object.getOwnPropertyNames(data),
      ...Object.getOwnPropertySymbols(data),
    ];

    if (!keys.length) return data;

    const exist = map.get(data);

    if (exist) return exist;

    map.set(data, result);

    keys.forEach((key) => {
      let item = data[key];

      if (typeof item === "object" && item) {
        result[key] = deep(item);
      } else {
        result[key] = item;
      }
    });

    return result;
  }

  return deep(obj);
}
```

## 为什么说函数是 JavaScript 的一等公民？

数据类型与函数是很多高级语言中最重要的两个概念，前者用来存储数据，后者用来存储代码。JavaScript 中的函数相对于数据类型而言更加复杂，它可以有属性，也可以被赋值给一个变量，还可以作为参数被传递......正是这些强大特性让它成了 JavaScript 的“一等公民”。

### this 关键字

什么是 this？this 是 JavaScript 的一个关键字，一般指向调用它的对象。

这句话其实有两层意思，首先 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象”。其次这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined）。

下面举几个例子来进行说明。

- 当代码 1 执行 fn() 函数时，实际上就是通过对象 o 来调用的，所以 this 指向对象 o。
- 代码 2 也是同样的道理，通过实例 a 来调用，this 指向类实例 a。
- 代码 3 则可以看成是通过全局对象来调用，this 会指向全局对象（需要注意的是，严格模式下会是 undefined）。

```js
// 代码 1

var o = {
  fn() {
    console.log(this);
  },
};

o.fn(); // o

// 代码 2

class A {
  fn() {
    console.log(this);
  }
}

var a = new A();

a.fn(); // a

// 代码 3

function fn() {
  console.log(this);
}

fn(); // 浏览器：Window；Node.js：global
```

**（1）如果在函数 fn2() 中调用函数 fn()，那么当调用函数 fn2() 的时候，函数 fn() 的 this 指向哪里呢？**

```js
function fn() {
  console.log(this);
}

function fn2() {
  fn();
}

fn2(); // ?
```

由于没有找到调用 fn 的对象，所以 this 会指向全局对象，答案就是 window（Node.js 下是 global）。

**（2）再把这段代码稍稍改变一下，让函数 fn2() 作为对象 obj 的属性，通过 obj 属性来调用 fn2，此时函数 fn() 的 this 指向哪里呢？**

```js
function fn() {
  console.log(this);
}

function fn2() {
  fn();
}

var obj = { fn2 };

obj.fn2(); // ?
```

这里需要注意，调用函数 fn() 的是函数 fn2() 而不是 obj。虽然 fn2() 作为 obj 的属性调用，但 fn2()中的 this 指向并不会传递给函数 fn()， 所以答案也是 window（Node.js 下是 global）。

**（3）对象 dx 拥有数组属性 arr，在属性 arr 的 forEach 回调函数中输出 this，指向的是什么呢？**

```js
var dx = {
  arr: [1],
};

dx.arr.forEach(function() {
  console.log(this);
}); // ?
```

如果你看过 forEach 的说明文档便会知道，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里只传入了回调函数，第二个参数没有传入，默认为 undefined，所以正确答案应该是输出全局对象。

类似的，需要传入 this 指向的函数还有：every()、find()、findIndex()、map()、some()，在使用的时候需要特别注意。

**前面提到通过类实例来调用函数时，this 会指向实例。那么如果像下面的代码，创建一个 fun 变量来引用实例 b 的 fn() 函数，当调用 fun() 的时候 this 会指向什么呢？**

```js
class B {
  fn() {
    console.log(this);
  }
}

var b = new B();

var fun = b.fn;

fun(); // ?
```

fun 是在全局下调用的，所以 this 应该指向的是全局对象。这个思路没有没问题，但是这里有个隐藏的知识点。那就是 ES6 下的 class 内部默认采用的是严格模式，实际上面代码的类定义部分可以理解为下面的形式。

```js
class B {
  "use strict";

  fn() {
    console.log(this);
  }
}
```

而严格模式下不会指定全局对象为默认调用对象，所以答案是 undefined。

**（5）ES6 新加入的箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。可以简单地理解为箭头函数的 this 继承自上层的 this，但在全局环境下定义仍会指向全局对象。**

```js
var arrow = {
  fn: () => {
    console.log(this);
  },
};

arrow.fn(); // ?
```

所以虽然通过对象 arrow 来调用箭头函数 fn()，那么 this 指向不是 arrow 对象，而是全局对象。如果要让 fn() 箭头函数指向 arrow 对象，我们还需要再加一层函数，让箭头函数的上层 this 指向 arrow 对象。

```js
var arrow = {
  fn() {
    const a = () => console.log(this);

    a();
  },
};

arrow.fn(); // arrow
```

**（6）前面提到 this 指向的要么是调用它的对象，要么是 undefined，那么如果将 this 指向一个基础类型的数据会发生什么呢？**

比如下面的代码将 this 指向数字 0，打印出的 this 是什么呢？

```js
[0].forEach(function() {
  console.log(this);
}, 0); // ?
```

基础类型也可以转换成对应的引用对象。所以这里 this 指向的是一个值为 0 的 Number 类型对象。

**（7）改变 this 指向的常见 3 种方式有 bind、call 和 apply。**

call 和 apply 用法功能基本类似，都是通过传入 this 指向的对象以及参数来调用函数。区别在于传参方式，前者为逐个参数传递，后者将参数放入一个数组，以数组的形式传递。bind 有些特殊，它不但可以绑定 this 指向也可以绑定函数参数并返回一个新的函数，当 c 调用新的函数时，绑定之后的 this 或参数将无法再被改变。

```js
function getName() {
  console.log(this.name);
}

var b = getName.bind({ name: "bind" });

b();

getName.call({ name: "call" });

getName.apply({ name: "apply" });
```

由于 this 指向的不确定性，所以很容易在调用时发生意想不到的情况。在编写代码时，应尽量避免使用 this，比如可以写成纯函数的形式，也可以通过参数来传递上下文对象。实在要使用 this 的话，可以考虑使用 bind 等方式将其绑定

### 箭头函数

箭头函数和普通函数相比，有以下几个区别，在开发中应特别注意：

- 不绑定 arguments 对象，也就是说在箭头函数内访问 arguments 对象会报错；
- 不能用作构造器，也就是说不能通过关键字 new 来创建实例；
- 默认不会创建 prototype 原型属性；
- 不能用作 Generator() 函数，不能使用 yeild 关键字。

### 函数的转换

编写一个 add() 函数，支持对多个参数求和以及多次调用求和。示例如下：

```js
add(1); // 1

add(1)(2); // 3

add(1, 2)(3, 4, 5)(6); // 21
```

对于不定参数的求和处理比较简单，很容易想到通过 arguments 或者扩展符的方式获取数组形式的参数，然后通过 reduce 累加求和。但如果直接返回结果那么后面的调用肯定会报错，所以每次返回的必须是函数，才能保证可以连续调用。也就是说 add 返回值既是一个可调用的函数又是求和的数值结果。

要实现这个要求，我们必须知道函数相关的两个隐式转换函数 toString() 和 valueOf()。toString() 函数会在打印函数的时候调用，比如 console.log、valueOf 会在获取函数原始值时调用，比如加法操作。

具体代码实现如下，在 add() 函数内部定义一个 fn() 函数并返回。fn() 函数的主要职能就是拼接参数并返回自身，当调用 toString() 和 valueOf() 函数时对拼接好的参数进行累加求和并返回。

```js
function add(...args) {
  let arr = args;

  function fn(...newArgs) {
    arr = [...arr, ...newArgs];

    return fn;
  }

  fn.toString = fn.valueOf = function() {
    return arr.reduce((acc, cur) => acc + parseInt(cur));
  };

  return fn;
}
```

::: tip

reducer 函数接收 4 个参数:

- Accumulator (acc) (累计器)
- Current Value (cur) (当前值)
- Current Index (idx) (当前索引)
- Source Array (src) (源数组)

:::

### 原型

原型是 JavaScript 的重要特性之一，可以让对象从其他对象继承功能特性，所以 JavaScript 也被称为“基于原型的语言”。

严格地说，原型应该是对象的特性，但函数其实也是一种特殊的对象。例如，我们对自定义的函数进行 instanceof Object 操作时，其结果是 true。

```js
function fn() {}

fn instanceof Object; // true
```

#### 什么是原型和原型链？

隐式原型通常在创建实例的时候就会自动指向构造函数的显式原型。例如，在下面的示例代码中，当创建对象 a 时，a 的隐式原型会指向构造函数 Object() 的显式原型。

```js
var a = {};
a.__proto__ === Object.prototype; // true
var b = new Object();
b.__proto__ === a.__proto__; // true
```

显式原型是内置函数（比如 Date() 函数）的默认属性，在自定义函数时（箭头函数除外）也会默认生成，生成的显式原型对象只有一个属性 constructor ，该属性指向函数自身。通常配合 new 关键字一起使用，当通过 new 关键字创建函数实例时，会将实例的隐式原型指向构造函数的显式原型。

```js
function fn() {}
fn.prototype.constructor === fn; // true
```

隐式原型必须和显式原型配合使用的想法是错误的。

下面的代码声明了 parent 和 child 两个对象，其中对象 child 定义了属性 name 和隐式原型 proto，隐式原型指向对象 parent，对象 parent 定义了 code 和 name 两个属性。

当打印 child.name 的时候会输出对象 child 的 name 属性值，当打印 child.code 时由于对象 child 没有属性 code，所以会找到原型对象 parent 的属性 code，将 parent.code 的值打印出来。同时可以通过打印结果看到，对象 parent 并没有显式原型属性。如果要区分对象 child 的属性是否继承自原型对象，可以通过 hasOwnProperty() 函数来判断。

```js
var parent = { code: "p", name: "parent" };
var child = { __proto__: parent, name: "child" };
console.log(parent.prototype); // undefined
console.log(child.name); // "child"
console.log(child.code); // "p"
child.hasOwnProperty("name"); // true
child.hasOwnProperty("code"); // false
```

在这个例子中，如果对象 parent 也没有属性 code，那么会继续在对象 parent 的原型对象中寻找属性 code，以此类推，逐个原型对象依次进行查找，直到找到属性 code 或原型对象没有指向时停止。

这种类似递归的链式查找机制被称作“原型链”。

### new 操作符实现了什么？

前面提到显式原型对象在使用 new 关键字的时候会被自动创建。现在再来具体分析通过 new 关键字创建函数实例时到底发生了什么。

下面的代码通过 new 关键字创建了一个函数 F() 的实例。

```js
function F(init) {}
var f = new F(args);
```

其中主要包含了 3 个步骤：

创建一个临时的空对象，为了表述方便，我们命名为 fn，让对象 fn 的隐式原型指向函数 F 的显式原型；

执行函数 F()，将 this 指向对象 fn，并传入参数 args，得到执行结果 result；

判断上一步的执行结果 result，如果 result 为非空对象，则返回 result，否则返回 fn。

具体可以表述为下面的代码：

```js
var fn = Object.create(F.prototype);
var obj = F.apply(fn, args);
var f = obj && typeof obj === "object" ? obj : fn;
```

### 怎么通过原型链实现多层继承？

假设构造函数 B() 需要继承构造函数 A()，就可以通过将函数 B() 的显式原型指向一个函数 A() 的实例，然后再对 B 的显式原型进行扩展。那么通过函数 B() 创建的实例，既能访问用函数 B() 的属性 b，也能访问函数 A() 的属性 a，从而实现了多层继承。

```js
function A() {}

A.prototype.a = function() {
  return "a";
};

function B() {}

B.prototype = new A();

B.prototype.b = function() {
  return "b";
};

var c = new B();

c.b(); // 'b'

c.a(); // 'a'
```

### typeof 和 instanceof

|      类型       |    结果     |
| :-------------: | :---------: |
|    Undefined    | "undefined" |
|     Boolean     |  "boolean"  |
|     Number      |  "number"   |
|     BigInt      |  "bigint"   |
|     String      |  "string"   |
|     Symbol      |  "symbol"   |
|    函数对象     | "function"  |
| 其他对象及 null |  "object"   |

用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。例如，在表达式 left instanceof right 中，会沿着 left 的原型链查找，看看是否存在 right 的 prototype 对象。

```js
left.__proto__.__proto__... =?= right.prototype
```

### 作用域

作用域是指赋值、取值操作的执行范围，通过作用域机制可以有效地防止变量、函数的重复定义，以及控制它们的可访问性。

虽然在浏览器端和 Node.js 端作用域的处理有所不同，比如对于全局作用域，浏览器会自动将未主动声明的变量提升到全局作用域，而 Node.js 则需要显式的挂载到 global 对象上。又比如在 ES6 之前，浏览器不提供模块级别的作用域，而 Node.js 的 CommonJS 模块机制就提供了模块级别的作用域。但在类型上，可以分为全局作用域（window/global）、块级作用域（let、const、try/catch）、模块作用域（ES6 Module、CommonJS）及函数作用域。

### 命名提升

对于使用 var 关键字声明的变量以及创建命名函数的时候，JavaScript 在解释执行的时候都会将其声明内容提升到作用域顶部，这种机制称为“命名提升”。

变量的命名提升允许我们在同（子）级作用域中，在变量声明之前进行引用，但要注意，得到的是未赋值的变量。而且仅限 var 关键字声明的变量，对于 let 和 const 在定义之前引用会报错。

### 闭包

在函数内部访问外部函数作用域时就会产生闭包。闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这种关联不只是跨作用域引用，也可以实现数据与函数的隔离。

比如下面的代码就通过闭包来实现单例模式。

```js
var SingleStudent = (function() {
  function Student() {}

  var _student;
  return function() {
    if (_student) return _student;

    _student = new Student();

    return _student;
  };
})();

var s = new SingleStudent();

var s2 = new SingleStudent();

s === s2; // true
```

### 一道题

```js
for (var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000 * i);
}
```

```js
var i;

for (i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000 * i);
}
```

```js
for (let i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000 * i);
}

/**
等价于
for(var i = 0; i < 5; i++ ) {
    let _i = i
	setTimeout(() => {
		console.log(_i);
	}, 1000 * i)
}
 */
```

## 为什么代码没有按照编写顺序执行？

### 了解异步

#### 异步和同步

```js
function syncAdd(a, b) {
  return a + b;
}

syncAdd(1, 2); // 立即得到结果 3

function asyncAdd(a, b, cb) {
  setTimeout(function() {
    cb(a + b);
  }, 1000);
}

asyncAdd(1, 2, console.log); // 1s后打印结果 3
```

#### 异步与回调

如果你经常调用 JavaScript 的异步函数可能会形成一个结论：异步操作都采用回调函数的形式。

毕竟从浏览器端的 DOM 事件、AJAX 请求、定时器到 Node.js 端的文件读写、多进程，都是采用的回调形式。但事实真是如此吗？

下面是一段简单的代码，定义了一个 JSON 对象 a，然后把它打印到控制台，最后再将对象 a 的 couter.index 属性值自增 1。

```js
var a = {
  counter: {
    index: 1,
  },
};

console.log(a); // ?

a.counter.index++;
```

如果你把上面的代码复制粘贴到浏览器控制台中运行，应该可以看到控制台打印了一个可能和你预期不一致的 JSON 对象：{conter:{index: 2}}。
原因在于浏览器在运行代码的时候，把控制台打印这种涉及 I/O 的操作进行了延迟执行。可能你会猜想是不是控制台打印的只是将对象 a 进行了类似“浅拷贝”的操作，否定这种猜想很简单，此时再执行一次自增操作，就会发现被打印的对象值并没有发生变化。

既然并非所有异步都回调，那么反过来，是否所有回调函数都是异步执行的呢？答案也是否定的。

回调形式的同步函数，比如数组原型函数 forEach，又比如改变 this 指向的 call。

### 异步原理

#### 事件循环

对于大多数语言而言，实现异步会通过启动额外的进程、线程或协程来实现，而我们在前面已经提到过，JavaScript 是单线程的。

为什么单线程还能实现异步呢？

其实也没有什么特殊的黑魔法，只是把一些操作交给了其他线程处理，然后采用了一种称之为“事件循环”（也称“事件轮询”）的机制来处理返回结果。

下面用一段简化的代码，来帮助你快速地理解事件循环机制。

数组 eventLoop 表示事件队列（也有称作“任务队列”），用来存放需要执行的任务事件（可以理解为回调函数），对象 event 变量表示当前需要执行的任务事件。

用一个永不停止的 while 循环来表示事件循环，每一次循环称为一个 tick。

对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中获取一个事件并执行，这些事件通常是回调函数的形式。

```js
var eventLoop = []; // 事件队列，先进先出

var event; // 事件执行成功的回调回调函数

while (true) {
  // 一次tick

  if (eventLoop.length > 0) {
    // 队列中取出回调函数

    event = eventLoop.shift();

    try {
      event();
    } catch (err) {
      reportError(err);
    }
  }
}
```

那么这个事件队列里的事件是怎么来的呢？

以 AJAX 请求为例，当我们发出一个 AJAX 请求时，浏览器会将请求任务分派给网络线程来进行处理，当对应的网络线程拿到返回的数据之后，就会把回调函数插入到事件队列中。

setTimeout 和 setInterval 也是同样的道理，当我们执行 setTimeout 的时候并不是直接把回调函数放入事件队列中。它所做的是交给定时器线程来处理，当定时器到时后，再把回调函数放在事件队列中，这样，在未来的某轮 tick 中获取并执行这个回调函数。

这么做有一个隐性的问题，如果事件队列中已经有其他事件，那么这个回调就会排队等待。

所以说 setTimeout/setInterval 定时器的精度并不高。准确地说，它只能确保回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，这就要根据事件队列的状态而定。

#### 事件队列

在讲述 setTimeout/setInterval 原理的时候也暴露了事件队列的一个缺陷：事件队列按照先进先出的顺序执行，那么如果队列较长时，排在后面的事件即使较为“紧急”，也得需要等待前面的任务先执行完成。

JavaScript 解决这个问题的思路就是：设置多个队列，按照优先级来执行。

下面这段代码可以验证 JavaScript 内部拥有优先级不同的 2 个队列，在下图中分别用绿色和红色表示，其中红色队列优先级高于绿色队列。

这段代码定义了 4 个异步函数 f1、f2、f3、f4，其中：

函数 f1 通过定时器 setTimeout 向绿色队列中插入一个控制台打印任务，输出数字 1；

函数 f2 通过 Promise 向红色队列中插入一个控制台打印任务，输出数字 2；

函数 f3 通过定时器 setTimeout 向绿色队列中插入一个回调函数，该回调函数会调用控制台打印数字 3，并且调用函数 f2；

函数 f4 通过 Promise 向红色队列中插入一个回调函数，该回调函数会调用控制台打印数字 4，并且调用函数 f1。

```js
function f1() {
  setTimeout(console.log.bind(null,1), 0)
}
function f2() {
  Promise.resolve().then(console.log.bind(null,2))
}
function f3() {
  setTimeout(() => {
    console.log(3)
    f2()
  }, 0)
}
function f4() {
  Promise.resolve().then(() => {
    console.log(4)
    f1()
  }
}
f3()
f4()
```

这段代码的执行过程和结果可以查看下图，当调用函数 f3 和函数 f4 之后，绿色队列和红色队列都会被插入一个匿名回调函数。

第 1 次 tick，由于红色队列优先级高，所以先执行红色匿名函数，控制台打印数字 4，然后调用函数 f1，向绿色队列中插入一个打印函数；

第 2 次 tick，按照先进先出原则，此时调用匿名函数打印数字 3，并调用函数 f2，向红色队列中插入一个打印函数；

第 3 次 tick，调用红色队列中的打印函数，控制台打印数字 2；

第 4 次 tick，调用绿色队列中的打印函数，控制台打印数字 1。

![](https://s0.lgstatic.com/i/image/M00/1F/41/CgqCHl7m1W-AUWjTAAGFy-O9UzA843.png)

关于红色队列和绿色队列，一般称为“宏任务队列（Macro Task Queue）”和“微任务队列（Micro Task Queue）”，也有的称为“Task Queue”和“Job Queue”。不管如何称呼，我们需要记住的是，不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有当优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。

常见的异步函数优先级如下，从上到下优先级逐层降低：

```js
process.nextTick(Node.js) >
MutationObserver(浏览器)/promise.then(catch、finnally)>
setImmediate(IE) >
setTimeout/setInterval requestAnimationFrame >
其他 I/O 操作 / 浏览器 DOM 事件
```

### 处理异步

由于回调函数这种形式的代码可读性非常差，所以在编写代码的时候要尽量将回调形式转化成返回 Promise 对象的形式，一方面由于 ES6 标准下提供了原生 Promise 对象及方法，另一方面 Promise 的可操作性也更强，比如可以配合 async/await 关键字使用，也可以转换成 Observable 对象。所以越来越多的第三方库异步函数都开始返回 Promise 对象。

下面我们就以 Promise 形式的异步函数为例，讲解几个常见的异步场景。

#### 异步串行

```js
asyncF1()
.then(data => asyncF2(data))
.then(() => {
  ...
})
.catch(e => console.error(e))
```

如果使用 async/await 可以摆脱链式调用，代码可读性更好：

```js
(async function() {
  try {
    const data = await asyncFn1()
    const result = await asyncFn2(data)
    ...
  } catch(e) {
    console.error(e)
  }
})()
```

**按照顺序执行调用 asyncF 函数 n 次**

对于这种场景可以通过数组函数 reduce 来实现，而不是简单地使用 for 循环或数组的 forEach 函数，比如像下面这样：

```js
[1...n].reduce(async (lastPromise, i) => {
  try {
    await lastPromise
    console.log(await asyncF())
  } catch(e) {
    console.error(e)
  }
}, Promise.resolve())
```

**延迟打印数组 [1,2,3,4,5]，每一次打印的初始延迟为 1000ms，增长延迟为 500ms。打印结果如下所示：**

```js
0s:    1
1s:    2
2.5s: 3
4.5s: 4
7s:    5

```

这道题也是将多个异步函数改为串行执行的典型例子，所以也可以通过 reduce 函数来实现。由于引入了递增的延迟执行，所以都需要得到上一次执行的延迟时间。具体代码如下：

```js
const arr = [1, 2, 3, 4, 5];

arr.reduce(async (prs, cur, index) => {
  const t = await prs;

  const time = index === 0 ? 0 : 1000 + (index - 1) * 500;

  return new Promise((res) => {
    setTimeout(() => {
      console.log(cur);

      res(time);
    }, time);
  });
}, Promise.resolve(0));
```

#### 异步并行

（1）`Promise.all([promise1 ...... promiseN])`

调用函数 Promise.all 会返回一个新的 Promise 实例，该实例在参数内所有的 promise 都完成 (resolved) 时回调完成 (resolve)；如果参数中 promise 有一个失败（rejected），那么此实例返回第一个失败 promise 的结果。

当执行的异步函数具有强一致性时可以使用它，比如要更新一个较大的表单数据，会发送多个请求分别更新不同的数据，如果一个请求更新失败则放弃本次提交。

（2）`Promise.allSettled([promise1......promiseN])`

调用函数 Promise.allsellted 会返回一个新的 Promise 实例，该实例会在所有给定的 promise 已经执行完成时返回一个对象数组，每个对象表示对应的 promise 结果。

这个函数适用于需要并发执行多个异步函数，这些异步函数的执行结果相互独立。比如同时发送多个 AJAX 请求来分别更新多条数据。

（3）`Promise.race([promise1......promiseN])`

调用函数 Promise.race 会返回一个新的 promise 实例，一旦参数中的某个 promise 执行完成，新的 promise 实例就会返回对应 promise 的执行结果。

这个函数会让多个并发函数产生“竞争”，从而挑选出最先执行完成的。比如尝试从多个网址加载图片资源。

#### 异常处理

Promise 有一个隐藏的“坑”，那就是内部的异常不能在外部通过 try/catch 所捕获，当内部发生异常时，会自动进入失败状态（rejected）。所以下面的代码是等价的：

```js
new Promise((resolve, reject) => {
  throw new Error(0); // 等价于  reject(new Error(0))
});
```

所以建议尽量使用 catch 子句而不是在 then 子句中捕获 Promise 异常，因为这样可以捕获 then 子句中的异常信息

```js
Promise.resolve(1).then(
  (data) => {
    const arr = data.split("");

    //...
  },
  (error) => {
    // 这里捕获不到
    // ...
  }
);

Promise.resolve(1)

  .then((data) => {
    const arr = data.split("");

    // ...
  })

  .catch((error) => {
    // 这里可以捕获
    // ...
  });
```

### Promise 的局限性

虽然 Promise 相对于回调具有明显的优势，但其仍然有一些局限性，至少有下面 2 个方面的问题。

#### 立即执行

当一个 Promise 实例被创建时，内部的代码就会立即被执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费。

#### 单次执行

Promise 处理的问题都是“一次性”的，因为一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的就是通过事件监听的方式来实现。

所以说 Promise 并不是万能的，全面了解其优缺点能帮助我们更好地使用 Promise。上述这些问题其实都有解决方案，比如使用 [RxJS](https://rxjs.dev/)，期待你在工作中多思考、多积累，找到更多更好的解决方案。

## 怎么复用你的代码？

### ES6 模块

目前最主流的模块化方案应该是 ECMAScript 2015 提出的模块化规范（也称“ES6 模块”），这个规范同时适用于 JavaScript 的前后端环境。

#### 定义和引用

ES6 模块强制自动采用严格模式，所以说不管有没有“user strict”声明都是一样的，换言之，编写代码的时候不必再刻意声明了；

虽然大部分主流浏览器支持 ES6 模块，但是和引入普通 JS 的方式略有不同，需要在对应 script 标签中将属性 type 值设置为“module”才能被正确地解析为 ES6 模块；

在 Node.js 下使用 ES6 模块则需要将文件名后缀改为“.mjs”，用来和 Node.js 默认使用的 CommonJS 规范模块作区分。

#### 特性

ES6 模块有两个重要特性一定要掌握，一个是值引用，另一个是静态声明。

值引用是指 export 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为变量浅拷贝。

下面是一个简单的例子，模块 a 导出变量 a，初始值为空字符串，500 毫秒后赋值为字符串 'a'；模块 b 引用模块 a 并打印，控制台输出空字符串，1 秒后继续打印，控制台输出字符串 'a'。

```js
// a.js

export var a = "";

setTimeout(() => (a = "a"), 500);

// b.js

import { a } from "./a.js";

console.log(a); // ''

setTimeout(() => console.log(a), 1000); // 'a'
```

ES6 模块对于引用声明有严格的要求，首先必须在文件的首部，不允许使用变量或表达式，不允许被嵌入到其他语句中。所以下面 3 种引用模块方式都会报错。

```js
// 必须首部声明
let a = 1
import { app } from './app';
// 不允许使用变量或表达式
import { 'a' + 'p' + 'p' } from './app';
// 不允许被嵌入语句逻辑
if (moduleName === 'app') {
  import { init } from './app';
} else {
  import { init } from './bpp';
}
```

定义这些严格的要求可不仅仅是为了代码的可读性，更重要的是可以对代码进行静态分析。

静态分析是指不需要执行代码，只从字面量上对代码进行分析。例如，在上面的错误代码中，有一段代码需要通过判断变量 moduleName 的值来加载对应的模块，这就意味着需要执行代码之后才能判断加载哪个模块，而 ES6 模块则不需要。这样做的好处是方便优化代码体积，比如通过 Tree-shaking 操作消除模块中没有被引用或者执行结果不会被用到的无用代码。

**import 的动态模块提案**

虽然 ES6 模块设计在 90% 情况下是很有用的，特别是配合一些工具使用，但是却无法应付某些特殊场景。比如，出于性能原因对代码进行动态加载，所以在 ES2020 规范提案中，希望通过 import() 函数来支持动态引入模块。

具体用法如下所示，调用 import() 函数传入模块路径，得到一个 Promise 对象。

```js
import(`./section-modules/${link.dataset.entryModule}.js`)
  .then((module) => {
    module.loadPageInto(main);
  })

  .catch((err) => {
    main.textContent = err.message;
  });
```

import() 函数违反了上面静态声明的所有要求，并且提供了其他更强大的功能特性。

- 违反首部声明要求，那么就意味着可以在代码运行时按需加载模块，这个特性就可以用于首屏优化，根据路由和组件只加载依赖的模块。
- 违反变量或表达式要求，则意味着可以根据参数动态加载模块。
- 违反嵌入语句逻辑规则，可想象空间更大，比如可以通过 Promise.race 方式同时加载多个模块，选择加载速度最优模块来使用，从而提升性能。

### CommonJS

CommonJS 最初名为 Server.js，是为浏览器之外的 JavaScript 运行环境提供的模块规范，最终被 Node.js 采用。

#### 定义和引用

CommonJS 规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 module 对象，代表当前模块。通过它来导出 API，它有以下属性：

- id 模块的识别符，通常是带有绝对路径的模块文件名；
- filename 模块的文件名，带有绝对路径；
- loaded 返回一个布尔值，表示模块是否已经完成加载；
- parent 返回一个对象，表示调用该模块的模块；
- children 返回一个数组，表示该模块要用到的其他模块；
- exports 表示模块对外输出的值。

引用模块则需要通过 require 函数，它的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。

#### 特性

CommonJS 特性和 ES6 恰恰相反，它采用的是值拷贝和动态声明。值拷贝和值引用相反，一旦输出一个值，模块内部的变化就影响不到这个值了，可以简单地理解为变量浅拷贝。

仍然使用上面的例子，改写成 CommonJS 模块，在 Node.js 端运行，控制台会打印两个空字符串。

```js
// a.js

var a = "";

setTimeout(() => (a = "a"), 500);

module.exports = a;

// b.js

var a = require("./a.js");

console.log(a); // ''

setTimeout(() => console.log(a), 1000); // ''
```

动态声明就很好理解了，就是消除了静态声明的限制，可以“自由”地在表达式语句中引用模块。

### AMD

在 ES6 模块出现之前，AMD（Asynchronous Module Definition，异步模块定义）是一种很热门的浏览器模块化方案

#### 定义和引用

AMD 规范只定义了一个全局函数 define，通过它就可以定义和引用模块，它有 3 个参数：

```js
define(id?, dependencies?, factory);
```

第 1 个参数 id 为模块的名称，该参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字；如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。

第 2 个参数 dependencies 是个数组，它定义了所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂函数中。

第 3 个参数 factory 为模块初始化要执行的函数或对象。如果是函数，那么该函数是单例模式，只会被执行一次；如果是对象，此对象应该为模块的输出值。

下面是一个简单的例子，创建一个名为“alpha”的模块，依赖了 require、exports、beta 3 个模块，并导出了 verb 函数

```js
define("alpha", ["require", "exports", "beta"], function(
  require,
  exports,
  beta
) {
  exports.verb = function() {
    return beta.verb();
  };
});
```

#### 特性

它的重要特性就是异步加载。所谓异步加载，就是指同时并发加载所依赖的模块，当所有依赖模块都加载完成之后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。

由于 AMD 并不是浏览器原生支持的模块规范，所以需要借助第三方库来实现，其中最有名的就是 RequireJS。它的核心是两个全局函数 define 和 require，define 函数可以将依赖注入队列中，并将回调函数定义成模块；require 函数主要作用是创建 script 标签请求对应的模块，然后加载和执行模块。

### CMD

CMD（Common Module Definition，通用模块定义）是基于浏览器环境制定的模块规范。

#### 定义和引用

CMD 定义模块也是通过一个全局函数 define 来实现的，但只有一个参数，该参数既可以是函数也可以是对象：

```js
define(factory);
```

如果这个参数是对象，那么模块导出的就是对象；如果这个参数为函数，那么这个函数会被传入 3 个参数 require 、 exports 和 module。

```js
define(function(require, exports, module) {
  //...
});
```

第 1 个参数 require 是一个函数，通过调用它可以引用其他模块，也可以调用 require.async 函数来异步调用模块。

第 2 个参数 exports 是一个对象，当定义模块的时候，需要通过向参数 exports 添加属性来导出模块 API。

第 3 个参数 module 是一个对象，它包含 3 个属性：

- uri，模块完整的 URI 路径；
- dependencies，模块的依赖；
- exports，模块需要被导出的 API，作用同第二个参数 exports。

下面是一个简单的例子，定义了一个名为 increment 的模块，引用了 math 模块的 add 函数，经过封装后导出成 increment 函数。

```js
define(function(require, exports, module) {
  var add = require("math").add;
  exports.increment = function(val) {
    return add(val, 1);
  };
  module.id = "increment";
});
```

CMD 最大的特点就是懒加载，和上面示例代码一样，不需要在定义模块的时候声明依赖，可以在模块执行时动态加载依赖。当然还有一点不同，那就是 CMD 同时支持同步加载模块和异步加载模块。

用一句话来形容就是，它整合了 CommonJS 和 AMD 规范的特点。遵循 CMD 规范的代表开源项目是 sea.js

### UMD

UMD（Universal Module Definition，统一模块定义）其实并不是模块管理规范，而是带有前后端同构思想的模块封装工具。通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 环境中采用 CommonJS 模块管理，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。

它的实现原理也比较简单：

- 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；
- 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；
- 若前两个都不存在，则将模块公开到全局（Window 或 Global）。

大致实现如下：

```js
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof exports === "object") {
    module.exports, (module.exports = factory());
  } else {
    root.returnExports = factory();
  }
})(this, function() {
  //。。。

  return {};
});
```

### ES5 标准下如何编写模块

模块的核心就是创建独立的作用域，要实现这个目的,可以通过函数来实现。

如果直接在全局作用域下定义函数会很容易因为命名冲突而导致代码覆盖，为了避免这种情况可以通过对象创建“命名空间”。但是它有个缺点，就是无法创建私有变量，并不符合“高内聚、低耦合”的编码原则，也容易出现 bug

```js
var mod = {
  a: '',
  f: function() {
     ...
  },
}
```

为了解决这个问题，立即执行函数的形式也就出现了，这种形式就是在定义函数的时候就调用它并导出模块 API

```js
var mod = (function(w){
  function f() {
    ...
  }
  var a = ''
  ...
  return {
  　　f,
  　　a
  };
})(window);
```

有了这两个基础知识点，我们再通过 webpack 编译 ES6 模块的例子加深理解。

下面的代码定义了 2 个 ES6 模块，分别是 index.js、m.js，其中模块 index.js 依赖 m.js 模块的 API：

```js
// index.js
import { text, write } from "./m";
write(`<h1>${text} ${text2}</h1>`);
// m.js
const write = (content) => document.write(content);
var text = "hello";
export { text, write };
```

查看编译后的代码我们发现，整个代码就是一个立即执行函数，这个立即执行函数的参数就是对象形式的模块定义。

```js
// bundle.js
(function(modules) {
  ...
})({
  "./index.js": (function(module, __webpack_exports__, __webpack_require__) {
    ...
  },
  "./m.js": (function(module, __webpack_exports__, __webpack_require__) {
    ...
  }
})
```

这个立即执行函数会加载一个初始模块，也就是 webpack 配置的 entry 模块，按照依赖关系调用模块对应的函数并缓存

```js
function (modules) { 
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  ...
  return __webpack_require__(__webpack_require__.s = "./index.js");
}
```

那么这些 ES6 模块是怎么转化成函数的呢？

从上面的代码我们可以看到，每个模块定义函数都会传入 3 个参数，其中参数 module 可以理解为当前模块的配置参数，包含模块 id 等信息。参数 webpack_exports 是一个对象，模块需要导出的 API 都可以添加到这个对象上；参数 webpack_require 是一个函数，负责引用依赖的模块。

```js
// index.js 中引入 m.js 模块
var _m__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./m */ "./m.js");
// m.js 中导出字符串 text 和函数 write
__webpack_require__.d(__webpack_exports__, "text", function() {
  return text;
});
__webpack_require__.d(__webpack_exports__, "write", function() {
  return write;
});
const write = (content) => document.write(content);
var text = "hello";
```

## 为什么说 JavaScript 不适合大型项目？

JavaScript 的类型问题具体表现在下面 3 个方面。

- 类型声明

```js
var c = 0
...
function fn() {
  ...
  c = 30;
}
fn();
```

- 动态类型

动态类型是指在运行期间才做数据类型检查的语言，即动态类型语言编程时，不用给任何变量指定数据类型。

如果我们在调用函数 printId 时要想了解参数 user 的数据结构和返回值类型，只能通过查看源码，或者运行时调试、打印来获取。当函数结构复杂，参数较多时这个过程就会大大降低代码的可维护性。虽然添加注释能在一定程度上缓解问题，但为函数编写注释并不是强制性约束，能否及时同步注释也可能会成为新的问题。

就函数 printId 本身而言，也无法在编译时校验参数的合法性，只能在运行时添加校验逻辑，这也大大增加了程序出现 bug 的概率。

```js
function printId(user) {
  return user.id;
}
```

- 弱类型

弱类型是指一个变量可以被赋予不同数据类型的值。这也是一个既灵活又可怕的特性，编写代码的时候非常方便，不用考虑变量的数据类型，但这也很容易出现 bug，调试起来会变得相当困难

为了解决上面 3 个问题，开源社区提供了解决方案——TypeScript。它是基于 JavaScript 的语法糖，也就是说 TypeScript 代码没有单独的运行环境，需要编译成 JavaScript 代码之后才能运行。

从它的名字不难看出，它的核心特性是类型“Type”。具体工作原理就是在代码编译阶段进行类型检测，这样就能在代码部署运行之前及时发现问题。

### 类型与接口

TypeScript 让 JavaScript 变成了静态强类型\*\*\*\*、变量需要严格声明的语言，为此定义了两个重要概念：类型（type）和接口（interface）。

TypeScript 在 JavaScript 原生类型的基础上进行了扩展，但为了和基础类型对象进行区分，采用了小写的形式，比如 Number 类型对应的是 number。类型之间可以互相组合形成新的类型。

一些数据类型在前面已经提过，这里不再赘述。下面补充一下 TypeScript 扩展的类型

1. 元组

元组可以看成是具有固定长度的数组，其中数组元素类型可以不同。比如下面的代码声明了一个元组变量 x，x 的第一个元素是字符串，第二个是数字；又比如 react hooks 就是用到了元组类型。

```js
let x: [string, number];
```

2. 枚举

枚举指的是带有名字的常量，可以分为数字枚举、字符串枚举和异构枚举（字符串和数字的混合）3 种。比较适用于前后端通用的枚举值，比如通过 AJAX 请求获取的数据状态，对于仅在前端使用的枚举值还是推荐使用 Symbol。

下面是一个异构枚举的例子，定义了数字枚举值 0 和字符串枚举值 "YES"。

```js
enum example {
    No = 0,
    Yes = "YES",
}
```

也可以使用 const 修饰符来定义枚举值，通过这种定义方式，TypeScript 会在编译的时候，直接把枚举引用替换成对应的枚举值而非创建枚举对象。

```js
enum example {
    No = 0,
    Yes = "YES",
}
console.log(example.No)
// 编译成
var example;
(function (example) {
    example[example["No"] = 0] = "No";
    example["Yes"] = "YES";
})(example || (example = {}));
console.log(example.No);
////////////
const enum example {
    No = 0,
    Yes = "YES",
}
console.log(example.No)
//  编译成
console.log(0 /* No */);
```

3. any

any 类型代表可以是任何一种类型，所以会跳过类型检查，相当于让变量或返回值又变成弱类型。因此建议尽量减少 any 类型的使用。

4. void

void 表示没有任何类型，常用于描述无返回值的函数。

5. never

never 类型表示的是那些永不存在的值的类型，对于一些特殊的校验场景比较有用，比如代码的完整性检查。下面的示例代码通过穷举判断变量 u 的值来执行对应逻辑，如果此时变量 u 的可选值新增了字符串 "c"，那么这段代码并不会给出提示告诉开发者还有一种 u 等于字符串 "c" 的场景，但如果增加 never 类型赋值的话在编译时就可以给出提示。

```js
let u: "a" | "b";
//...
if (u === "a") {
  //...
} else if (u === "b") {
  //...
}
```

增加了 never 类型变量赋值：

```js
let u: "a" | "b" | "c";
//...
if (u === "a") {
  //...
} else if (u === "b") {
  //...
} else {
  let trmp: never = u; // Type '"c"' is not assignable to type 'never'.
}
```

接口的作用和类型非常相似，在大多数情况下可以通用，只存在一些细小的区别（比如同名接口可以自动合并，而类型不能；在编译器中将鼠标悬停在接口上显示的是接口名称，悬停在类型上显示的是字面量类型），最明显的区别还是在写法上。

```js
/* 声明 */
interface IA {
  id: string;
}
type TA = {
  id: string,
};
/* 继承 */
interface IA2 extends IA {
  name: string;
}
type TA2 = TA & { name: string };
/* 实现 */
class A implements IA {
  id: string = "";
}
class A2 implements TA {
  id: string = "";
}
```

### 类型抽象

泛型是对类型的一种抽象，一般用于函数，能让调用者动态地指定部分数据类型。这一点和 any 类型有些像，对于类型的定义具有不确定性，可以指代多种类型，但最大区别在于泛型可以对函数成员或类成员产生约束关系。

下面代码是 react 的钩子函数 useState 的类型定义，就用到了泛型。

```js
function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];
```

这段代码中 S 称为泛型变量。从这个定义可看出，useState 可以接收任何类型的参数或回调函数，但返回的元组数据第一个值必定和参数类型或者回调函数返回值类型相同，都为 S。
如果使用 any 类型来取代泛型，那么我们只能知道允许传入任何参数或回调函数，而无法知道返回值与入参的对应关系。

在使用泛型的时候，我们可以通过尖括号来手动指定泛型变量的类型，这个指定操作称之为**类型断言，**也可以不指定，让 TypeScript 自行推断类型。比如下面的代码就通过类型断言，将范型变量指定为 string 类型。

```js
const [id, setId] = useState < string > "";
```

### 类型组合

类型组合就是把现有的多种类型叠加到一起，组合成一种新的类型，具体有两种方式。

#### 交叉

交叉就是将多个类型合并为一个类型，操作符为 “&” 。下面的代码定义了一个 Admin 类型，它同时是类型 Student 和类型 Teacher 的交叉类型。 就是说 Admin 类型的对象同时拥有了这 2 种类型的成员。

```ts
type Admin = Student & Teacher;
```

#### 联合

联合就是表示符合多种类型中的任意一个，不同类型通过操作符“|”连接。下面代码定义的类型是 AorB，表示该类型值可以是类型 A，也可以是类型 B。

```ts
type A = {
  a: string;
};
type B = {
  b: number;
};
type AorB = A | B;
```

对于联合类型 AorB，我们能够确定的是它包含了 A 和 B 中共有的成员。如果我们想确切地了解值是否为类型 A，只能通过检查值的方法是否存在来进行判断。例如，下面的变量 v 属于 AorB 类型，在需要确认其具体类型时，先将变量 v 的类型断言为 A，然后再调用其属性 a 进行判断。

```ts
let v: AorB;
// ...
if ((<A>v).a) {
  //...
} else {
  (<B>v).b;
  //...
}
```

### 类型引用

#### 索引

索引类型的目的是让 TypeScript 编译器检查出使用了动态属性名的类型，需要通过索引类型查询和索引类型访问来实现。

下面的示例代码实现了一个简单的函数 getValue ，传入对象和对象属性名获取对应的值。

```ts
function getValue<T, K extends keyof T>(o: T, name: K): T[K] {
  return o[name]; // o[name] is of type T[K]
}
let com = {
  name: "lagou",
  id: 123,
};
let id: number = getValue(com, "id");
let no = getValue(com, "no"); //报错：Argument of type '"no"' is not assignable to parameter of type '"id" | "name"'.
```

其中，泛型变量 K 继承了泛型变量 T 的属性名联合，这里的 keyof 就是**索引类型查询**操作符；返回值 T[K] 就是**索引访问**操作符的使用方式。

前面提到的 Pick 类型就是通过索引类型来实现的。

#### 映射

映射类型是指从已有类型中创建新的类型。TypeScript 预定义了一些类型，比如最常用的 Pick 和 Omit。

下面是 Pick 类型的使用示例及源码，可以看到类型 Pick 从类型 task 中选择属性 "title" 和 "description" 生成了新的类型 simpleTask。

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
interface task {
  title: string;
  description: string;
  status: string;
}
type simpleTask = Pick<task, "title" | "description">; // {title: string;description: string}
```

类型 Pick 的实现，先用到了**索引类型查询**，获取了类型 T 的属性名联合 K，然后通过操作符 in 对其进行遍历，同时又用到了**索引类型访问**来表示属性值。

debounce 函数重新用 ts 写

首先给函数 debounce 添加类型，包括参数类型和返回值类型。参数类型使用泛型变量，在调用函数 debounce 的时候手动指定，泛型变量有 3 个：函数 T 、函数 T 的返回值 U 和 函数 T 的参数 V。

然后是变量 timeout ，当定时器存在时它的值为 number，定时器不存在时值为 null。

最后按照之前定义的泛型变量给函数 debounced 和函数 flush 添加类型声明。

```ts
const debounce = <T extends Function, U, V extends any[]>(
  func: T,
  wait: number = 0
) => {
  let timeout: number | null = null;

  let args: V;

  function debounced(...arg: V): Promise<U> {
    args = arg;

    if (timeout) {
      clearTimeout(timeout);

      timeout = null;
    } // 以 Promise 的形式返回函数执行结果

    return new Promise((res, rej) => {
      timeout = setTimeout(async () => {
        try {
          const result: U = await func.apply(this, args);

          res(result);
        } catch (e) {
          rej(e);
        }
      }, wait);
    });
  } // 允许取消

  function cancel() {
    clearTimeout(timeout);

    timeout = null;
  } // 允许立即执行

  function flush(): U {
    cancel();

    return func.apply(this, args);
  }

  debounced.cancel = cancel;

  debounced.flush = flush;

  return debounced;
};
```

## 浏览器如何执行 JavaScript 代码？

编译器的基本工作流程，大体上包括 3 个步骤：解析（Parsing）、转换（Transformation）及代码生成（Code Generation），JavaScript 引擎与之相比大体上也遵循这个过程，可分为解析、解释和优化 3 个步骤。下面我们就以 V8 引擎为例进行讲解。

### 解析

解析步骤又可以拆分成 2 个小步骤：

- 词法分析，将 JavaScript 代码解析成一个个的令牌（Token）；

- 语法分析，将令牌组装成一棵抽象的语法树（AST）。

下面是一段简单的代码，声明了一个字符串变量并调用函数 console.log 进行打印。

```js
var name = "web";
console.log(name);
```

通过词法分析会对这段代码逐个字符进行解析，生成类似下面结构的令牌（Token），这些令牌类型各不相同，有关键字、标识符、符号、字符串。

```js
Keyword(var)
Identifier(name)
Punctuator(=)
String('web')
Identifier(console)
Punctuator(.)
Identifier(log)
Punctuator(()
Identifier(name)
Punctuator())
```

语法分析阶段会用令牌生成类似下面结构的抽象语法树，生成树的过程并不是简单地把所有令牌都添加到树上，而是去除了不必要的符号令牌之后，按照语法规则来生成抽象语法树

![](https://s0.lgstatic.com/i/image/M00/27/1E/Ciqc1F70ZQSAGf1cAAEehLtbbTk491.png)

### 解释

JavaScript 引擎是通过解释器 Ignition 将 AST 转换成字节码。字节码是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，从而可以减少内存消耗。

下面代码是从示例代码生成的字节码中截取的一段。它的语法已经非常接近汇编语言了，有很多操作符，比如 StackCheck、Star、Return。考虑这些操作符过于底层，涉及处理器的累加器及寄存器操作，已经超出前端范围，这里就不详细介绍了。

```js
[generated bytecode for function: log (0x1e680d83fc59 <SharedFunctionInfo log>)]
Parameter count 1
Register count 6
Frame size 48
 9646 E> 0x376a94a60ea6 @    0 : a7                StackCheck 
         ......
         0x376a94a60ec9 @   35 : 26 f6             Star r5
 9683 E> 0x376a94a60ecb @   37 : 5a f9 02 f7 f6 06 CallProperty2 r2, <this>, r4, r5, [6]
         0x376a94a60ed1 @   43 : 0d                LdaUndefined 
 9729 S> 0x376a94a60ed2 @   44 : ab                Return 
Constant pool (size = 3)
Handler Table (size = 0)
Source Position Table (size = 24)
```

### 优化

解释器在得到 AST 之后，会按需进行解释和执行，也就是说如果某个函数没有被调用，则不会去解释执行它。

在这个过程中解释器会将一些重复可优化的操作（比如类型判断）收集起来生成分析数据，然后将生成的字节码和分析数据传给编译器 TurboFan，编译器会依据分析数据来生成高度优化的机器码。

优化后的机器码的作用和缓存很类似，当解释器再次遇到相同的内容时，就可以直接执行优化后的机器码。当然优化后的代码有时可能会无法运行（比如函数参数类型改变），那么会再次反优化为字节码交给解释器。

整个过程如下面流程图所示：

![](https://s0.lgstatic.com/i/image/M00/27/29/CgqCHl70ZTqAR9m6AAEz8M57qjs116.png)

### 内存管理

JavaScript 引擎的内存空间分为堆（Heap）和栈（Stack）。堆和栈是两种不同的数据结构，堆是具有树结构的数组，栈也是数组，但是遵循“先进后出”规则。

#### 栈

栈是一个临时存储空间，主要存储局部变量和函数调用（对于全局表达式会创建匿名函数并调用）。

对于基本数据类型（String、Undefined、Null、Boolean、Number、BigInt、Symbol）的局部变量，会直接在栈中创建，而对象数据类型局部变量会存储在堆中，栈中只存储它的引用地址，也就是我们常说的浅拷贝。全局变量以及闭包变量也是只存储引用地址。总而言之栈中存储的数据都是轻量的。

对于函数，解释器创建了“调用栈”（Call Stack）来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，解释器会为被添加进的函数创建一个栈帧 （Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）并立即执行。如果正在执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈并执行。一旦这个函数执行结束，对应的栈帧也会被立即销毁。

查看调用栈的方式有 2 种：

- 调用函数 console.trace() 打印到控制台；

- 利用浏览器开发者工具进行断点调试。

虽然栈很轻量，只会在使用时创建，使用结束时销毁，但它并不是可以无限增长的。当分配的调用栈空间被占满时，就会引发“栈溢出”错误。所以我们在编写递归函数的时候一定要注意函数执行边界，也就是退出递归的条件。

#### 尾调用

递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以通常是比较消耗内存的操作。对递归的优化一般有两个思路，减少递归次数和使用尾调用。

尾调用（Tail Call）是指函数的最后一步返回另一个函数的调用。例如下面的代码中，函数 a() 返回了函数 b() 的调用。

```js
function a(x) {
  return b(x);
}
```

像下面的示例中，返回缓存的函数调用结果，或者返回多个函数调用都不属于“尾调用”。

```js
function a(x) {
  let c = b(x);
  return c;
}
function a(x) {
  return b(x) + c(x);
}
function a() {
  b(x);
}
```

尾调用由于是在 return 语句中，并且是函数的最后一步操作，所以局部变量等信息不需要再用到，从而可以立即释放节省内存空间。

下面的示例代码通过递归实现了求斐波那契额数列第 n 个数的功能。函数 fibTail() 相对于函数 fib() 就同时使用了尾调用以及减少调用次数两种优化方式。

```js
function fib(n) {
  if (n < 3) return 1;
  return fib(n - 1) + fib(n - 2);
}
function fibTail(n, a = 0, b = 1) {
  if (n === 0) return a;
  return fibTail(n - 1, b, a + b);
}
```

但是由于尾调用也存在一些隐患，比如错误信息丢失、不方便调试，所以浏览器以及 Node.js 环境默认并没有支持这种优化方式

#### 新生代

大多数的对象最开始都会被分配在新生代，该存储空间相对较小，只有几十 MB，分为两个空间：from 空间和 to 空间。

程序中声明的对象首先会被分配到 from 空间，当进行垃圾回收时，会先将 from 空间中存活的的对象（存活对象可以理解为被引用的对象）复制到 to 空间进行保存，对未存活的对象空间进行回收。当复制完成后，from 空间和 to 空间进行调换，to 空间会变为新的 from 空间，原来的 from 空间则变为 to 空间，这种算法称之为 “Scanvage”。

新生代的内存回收频率很高、速度也很快，但空间利用率较低，因为让一半的内存空间处于“闲置”状态。

![](https://s0.lgstatic.com/i/image/M00/27/1E/Ciqc1F70ZbOAPf-KAACo3m70oGk582.png)

### 老生代

新生代中多次回收仍然存活的对象会被转移到空间较大的老生代。因为老生代空间较大，如果回收方式仍然采用 Scanvage 算法来频繁复制对象，那性能开销就太大了。

所以老生代采用的是另一种“标记清除”（Mark-Sweep）的方式来回收未存活的对象空间。

这种方式主要分为标记和清除两个阶段。标记阶段会遍历堆中所有对象，并对存活的对象进行标记；清除阶段则是对未标记对象的空间进行回收。

![](https://s0.lgstatic.com/i/image/M00/27/1E/Ciqc1F70ZZWAeo71AABOQKZ828k489.png)

由于标记清除不会对内存一分为二，所以不会浪费空间。但是进行过标记清除之后的内存空间会产生很多不连续的碎片空间，这种不连续的碎片空间中，在遇到较大对象时可能会由于空间不足而导致无法存储的情况。

为了解决内存碎片的问题，提高对内存的利用，还需要使用到标记整理（Mark-Compact） 算法。标记整理算法相对于标记清除算法在回收阶段进行了改进，标记整理对待未标记的对象并不是立即进行回收，而是将存活的对象移动到一边，然后再清理。当然这种移动对象的操作相对而言是比较耗时的，所以执行速度上，比标记清除要慢。

![](https://s0.lgstatic.com/i/image/M00/27/21/Ciqc1F70cS2AU5w_AABOiU6R39g235.png)
